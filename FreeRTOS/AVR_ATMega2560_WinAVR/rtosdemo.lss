
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000050  00800200  00002c3c  00002cd0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c3c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000686  00800250  00800250  00002d20  2**0
                  ALLOC
  3 .debug_aranges 000001c0  00000000  00000000  00002d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000092f  00000000  00000000  00002ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003763  00000000  00000000  0000380f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000fd0  00000000  00000000  00006f72  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003668  00000000  00000000  00007f42  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000730  00000000  00000000  0000b5ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001740  00000000  00000000  0000bcdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000212f  00000000  00000000  0000d41c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  0000f54b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 88 12 	jmp	0x2510	; 0x2510 <__vector_17>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 c0 01 	jmp	0x380	; 0x380 <__vector_25>
      68:	0c 94 79 01 	jmp	0x2f2	; 0x2f2 <__vector_26>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ec e3       	ldi	r30, 0x3C	; 60
      fc:	fc e2       	ldi	r31, 0x2C	; 44
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a0 35       	cpi	r26, 0x50	; 80
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	18 e0       	ldi	r17, 0x08	; 8
     110:	a0 e5       	ldi	r26, 0x50	; 80
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a6 3d       	cpi	r26, 0xD6	; 214
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 98 00 	call	0x130	; 0x130 <main>
     122:	0c 94 1c 16 	jmp	0x2c38	; 0x2c38 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     12a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vCoRoutineSchedule>
}
     12e:	08 95       	ret

00000130 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
     130:	ef 92       	push	r14
     132:	ff 92       	push	r15
     134:	0f 93       	push	r16
     136:	df 93       	push	r29
     138:	cf 93       	push	r28
     13a:	0f 92       	push	r0
     13c:	cd b7       	in	r28, 0x3d	; 61
     13e:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
     140:	ce 01       	movw	r24, r28
     142:	01 96       	adiw	r24, 0x01	; 1
     144:	60 e5       	ldi	r22, 0x50	; 80
     146:	70 e0       	ldi	r23, 0x00	; 0
     148:	41 e0       	ldi	r20, 0x01	; 1
     14a:	50 e0       	ldi	r21, 0x00	; 0
     14c:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <__eerd_block_m2560>
	ucCount++;
     150:	69 81       	ldd	r22, Y+1	; 0x01
     152:	6f 5f       	subi	r22, 0xFF	; 255
     154:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
     156:	80 e5       	ldi	r24, 0x50	; 80
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	0e 94 0e 16 	call	0x2c1c	; 0x2c1c <__eewr_byte_m2560>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
     15e:	0e 94 1c 01 	call	0x238	; 0x238 <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
     162:	80 e0       	ldi	r24, 0x00	; 0
     164:	0e 94 15 14 	call	0x282a	; 0x282a <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
     168:	82 e0       	ldi	r24, 0x02	; 2
     16a:	40 e0       	ldi	r20, 0x00	; 0
     16c:	56 e9       	ldi	r21, 0x96	; 150
     16e:	60 e0       	ldi	r22, 0x00	; 0
     170:	70 e0       	ldi	r23, 0x00	; 0
     172:	24 e0       	ldi	r18, 0x04	; 4
     174:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
     178:	82 e0       	ldi	r24, 0x02	; 2
     17a:	0e 94 36 14 	call	0x286c	; 0x286c <vStartPolledQueueTasks>
	vStartRegTestTasks();
     17e:	0e 94 c2 03 	call	0x784	; 0x784 <vStartRegTestTasks>

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
     182:	8c ed       	ldi	r24, 0xDC	; 220
     184:	90 e0       	ldi	r25, 0x00	; 0
     186:	60 e0       	ldi	r22, 0x00	; 0
     188:	72 e0       	ldi	r23, 0x02	; 2
     18a:	45 e5       	ldi	r20, 0x55	; 85
     18c:	50 e0       	ldi	r21, 0x00	; 0
     18e:	20 e0       	ldi	r18, 0x00	; 0
     190:	30 e0       	ldi	r19, 0x00	; 0
     192:	03 e0       	ldi	r16, 0x03	; 3
     194:	ee 24       	eor	r14, r14
     196:	ff 24       	eor	r15, r15
     198:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
     19c:	83 e0       	ldi	r24, 0x03	; 3
     19e:	0e 94 e7 12 	call	0x25ce	; 0x25ce <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     1a2:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <vTaskStartScheduler>

	return 0;
}
     1a6:	80 e0       	ldi	r24, 0x00	; 0
     1a8:	90 e0       	ldi	r25, 0x00	; 0
     1aa:	0f 90       	pop	r0
     1ac:	cf 91       	pop	r28
     1ae:	df 91       	pop	r29
     1b0:	0f 91       	pop	r16
     1b2:	ff 90       	pop	r15
     1b4:	ef 90       	pop	r14
     1b6:	08 95       	ret

000001b8 <vErrorChecks>:
/*-----------------------------------------------------------*/

static void vErrorChecks( void *pvParameters )
{
     1b8:	1f 93       	push	r17
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
     1ba:	11 e0       	ldi	r17, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
     1bc:	88 eb       	ldi	r24, 0xB8	; 184
     1be:	9b e0       	ldi	r25, 0x0B	; 11
     1c0:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
     1c4:	20 91 06 02 	lds	r18, 0x0206
     1c8:	30 91 07 02 	lds	r19, 0x0207
     1cc:	40 91 08 02 	lds	r20, 0x0208
     1d0:	50 91 09 02 	lds	r21, 0x0209
     1d4:	da 01       	movw	r26, r20
     1d6:	c9 01       	movw	r24, r18
     1d8:	88 0f       	add	r24, r24
     1da:	99 1f       	adc	r25, r25
     1dc:	aa 1f       	adc	r26, r26
     1de:	bb 1f       	adc	r27, r27
     1e0:	82 0f       	add	r24, r18
     1e2:	93 1f       	adc	r25, r19
     1e4:	a4 1f       	adc	r26, r20
     1e6:	b5 1f       	adc	r27, r21
     1e8:	80 93 06 02 	sts	0x0206, r24
     1ec:	90 93 07 02 	sts	0x0207, r25
     1f0:	a0 93 08 02 	sts	0x0208, r26
     1f4:	b0 93 09 02 	sts	0x0209, r27

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
     1f8:	0e 94 0e 14 	call	0x281c	; 0x281c <xAreIntegerMathsTaskStillRunning>
     1fc:	81 30       	cpi	r24, 0x01	; 1
     1fe:	11 f0       	breq	.+4      	; 0x204 <vErrorChecks+0x4c>
	{
		xErrorHasOccurred = pdTRUE;
     200:	10 93 50 02 	sts	0x0250, r17
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
     204:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xAreComTestTasksStillRunning>
     208:	81 30       	cpi	r24, 0x01	; 1
     20a:	11 f0       	breq	.+4      	; 0x210 <vErrorChecks+0x58>
	{
		xErrorHasOccurred = pdTRUE;
     20c:	10 93 50 02 	sts	0x0250, r17
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
     210:	0e 94 29 14 	call	0x2852	; 0x2852 <xArePollingQueuesStillRunning>
     214:	81 30       	cpi	r24, 0x01	; 1
     216:	11 f0       	breq	.+4      	; 0x21c <vErrorChecks+0x64>
	{
		xErrorHasOccurred = pdTRUE;
     218:	10 93 50 02 	sts	0x0250, r17
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
     21c:	0e 94 76 02 	call	0x4ec	; 0x4ec <xAreRegTestTasksStillRunning>
     220:	81 30       	cpi	r24, 0x01	; 1
     222:	11 f0       	breq	.+4      	; 0x228 <vErrorChecks+0x70>
	{
		xErrorHasOccurred = pdTRUE;
     224:	10 93 50 02 	sts	0x0250, r17
	}

	if( xErrorHasOccurred == pdFALSE )
     228:	80 91 50 02 	lds	r24, 0x0250
     22c:	88 23       	and	r24, r24
     22e:	31 f6       	brne	.-116    	; 0x1bc <vErrorChecks+0x4>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED( mainCHECK_TASK_LED );
     230:	87 e0       	ldi	r24, 0x07	; 7
     232:	0e 94 24 01 	call	0x248	; 0x248 <vParTestToggleLED>
     236:	c2 cf       	rjmp	.-124    	; 0x1bc <vErrorChecks+0x4>

00000238 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     238:	8f ef       	ldi	r24, 0xFF	; 255
     23a:	80 93 0a 02 	sts	0x020A, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     23e:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     240:	80 91 0a 02 	lds	r24, 0x020A
     244:	85 b9       	out	0x05, r24	; 5
}
     246:	08 95       	ret

00000248 <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     248:	1f 93       	push	r17
     24a:	28 2f       	mov	r18, r24
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     24c:	88 30       	cpi	r24, 0x08	; 8
     24e:	e8 f4       	brcc	.+58     	; 0x28a <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 c0       	rjmp	.+4      	; 0x25a <vParTestToggleLED+0x12>
     256:	88 0f       	add	r24, r24
     258:	99 1f       	adc	r25, r25
     25a:	2a 95       	dec	r18
     25c:	e2 f7       	brpl	.-8      	; 0x256 <vParTestToggleLED+0xe>
     25e:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     260:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     264:	80 91 0a 02 	lds	r24, 0x020A
     268:	81 23       	and	r24, r17
     26a:	29 f0       	breq	.+10     	; 0x276 <vParTestToggleLED+0x2e>
			{
				ucCurrentOutputValue &= ~ucBit;
     26c:	80 91 0a 02 	lds	r24, 0x020A
     270:	10 95       	com	r17
     272:	18 23       	and	r17, r24
     274:	03 c0       	rjmp	.+6      	; 0x27c <vParTestToggleLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     276:	80 91 0a 02 	lds	r24, 0x020A
     27a:	18 2b       	or	r17, r24
     27c:	10 93 0a 02 	sts	0x020A, r17
			}

			PORTB = ucCurrentOutputValue;
     280:	80 91 0a 02 	lds	r24, 0x020A
     284:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
     286:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
	}
}
     28a:	1f 91       	pop	r17
     28c:	08 95       	ret

0000028e <vParTestSetLED>:
	PORTB = ucCurrentOutputValue;
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	28 2f       	mov	r18, r24
     294:	06 2f       	mov	r16, r22
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     296:	88 30       	cpi	r24, 0x08	; 8
     298:	d8 f4       	brcc	.+54     	; 0x2d0 <vParTestSetLED+0x42>
	{
		ucBit <<= uxLED;	
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	02 c0       	rjmp	.+4      	; 0x2a4 <vParTestSetLED+0x16>
     2a0:	88 0f       	add	r24, r24
     2a2:	99 1f       	adc	r25, r25
     2a4:	2a 95       	dec	r18
     2a6:	e2 f7       	brpl	.-8      	; 0x2a0 <vParTestSetLED+0x12>
     2a8:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     2aa:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
     2ae:	01 30       	cpi	r16, 0x01	; 1
     2b0:	29 f4       	brne	.+10     	; 0x2bc <vParTestSetLED+0x2e>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     2b2:	80 91 0a 02 	lds	r24, 0x020A
     2b6:	10 95       	com	r17
     2b8:	18 23       	and	r17, r24
     2ba:	03 c0       	rjmp	.+6      	; 0x2c2 <vParTestSetLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     2bc:	80 91 0a 02 	lds	r24, 0x020A
     2c0:	18 2b       	or	r17, r24
     2c2:	10 93 0a 02 	sts	0x020A, r17
			}

			PORTB = ucCurrentOutputValue;
     2c6:	80 91 0a 02 	lds	r24, 0x020A
     2ca:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
     2cc:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
	}
}
     2d0:	1f 91       	pop	r17
     2d2:	0f 91       	pop	r16
     2d4:	08 95       	ret

000002d6 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     2d6:	0f b6       	in	r0, 0x3f	; 63
     2d8:	f8 94       	cli
     2da:	0f 92       	push	r0
	{
		vInterruptOff();
     2dc:	e1 ec       	ldi	r30, 0xC1	; 193
     2de:	f0 e0       	ldi	r31, 0x00	; 0
     2e0:	80 81       	ld	r24, Z
     2e2:	8f 7d       	andi	r24, 0xDF	; 223
     2e4:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     2e6:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     2e8:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     2ea:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     2ec:	0f 90       	pop	r0
     2ee:	0f be       	out	0x3f, r0	; 63
}
     2f0:	08 95       	ret

000002f2 <__vector_26>:
	}
}
/*-----------------------------------------------------------*/

SIGNAL( USART0_UDRE_vect )
{
     2f2:	1f 92       	push	r1
     2f4:	0f 92       	push	r0
     2f6:	0f b6       	in	r0, 0x3f	; 63
     2f8:	0f 92       	push	r0
     2fa:	0b b6       	in	r0, 0x3b	; 59
     2fc:	0f 92       	push	r0
     2fe:	11 24       	eor	r1, r1
     300:	2f 93       	push	r18
     302:	3f 93       	push	r19
     304:	4f 93       	push	r20
     306:	5f 93       	push	r21
     308:	6f 93       	push	r22
     30a:	7f 93       	push	r23
     30c:	8f 93       	push	r24
     30e:	9f 93       	push	r25
     310:	af 93       	push	r26
     312:	bf 93       	push	r27
     314:	ef 93       	push	r30
     316:	ff 93       	push	r31
     318:	df 93       	push	r29
     31a:	cf 93       	push	r28
     31c:	0f 92       	push	r0
     31e:	0f 92       	push	r0
     320:	cd b7       	in	r28, 0x3d	; 61
     322:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     324:	80 91 53 02 	lds	r24, 0x0253
     328:	90 91 54 02 	lds	r25, 0x0254
     32c:	be 01       	movw	r22, r28
     32e:	6f 5f       	subi	r22, 0xFF	; 255
     330:	7f 4f       	sbci	r23, 0xFF	; 255
     332:	ae 01       	movw	r20, r28
     334:	4e 5f       	subi	r20, 0xFE	; 254
     336:	5f 4f       	sbci	r21, 0xFF	; 255
     338:	0e 94 87 0c 	call	0x190e	; 0x190e <xQueueReceiveFromISR>
     33c:	81 30       	cpi	r24, 0x01	; 1
     33e:	21 f4       	brne	.+8      	; 0x348 <__vector_26+0x56>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     340:	89 81       	ldd	r24, Y+1	; 0x01
     342:	80 93 c6 00 	sts	0x00C6, r24
     346:	05 c0       	rjmp	.+10     	; 0x352 <__vector_26+0x60>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     348:	80 91 c1 00 	lds	r24, 0x00C1
     34c:	8f 7d       	andi	r24, 0xDF	; 223
     34e:	80 93 c1 00 	sts	0x00C1, r24
	}
}
     352:	0f 90       	pop	r0
     354:	0f 90       	pop	r0
     356:	cf 91       	pop	r28
     358:	df 91       	pop	r29
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	bf 91       	pop	r27
     360:	af 91       	pop	r26
     362:	9f 91       	pop	r25
     364:	8f 91       	pop	r24
     366:	7f 91       	pop	r23
     368:	6f 91       	pop	r22
     36a:	5f 91       	pop	r21
     36c:	4f 91       	pop	r20
     36e:	3f 91       	pop	r19
     370:	2f 91       	pop	r18
     372:	0f 90       	pop	r0
     374:	0b be       	out	0x3b, r0	; 59
     376:	0f 90       	pop	r0
     378:	0f be       	out	0x3f, r0	; 63
     37a:	0f 90       	pop	r0
     37c:	1f 90       	pop	r1
     37e:	18 95       	reti

00000380 <__vector_25>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART0_RX_vect )
{
     380:	1f 92       	push	r1
     382:	0f 92       	push	r0
     384:	0f b6       	in	r0, 0x3f	; 63
     386:	0f 92       	push	r0
     388:	0b b6       	in	r0, 0x3b	; 59
     38a:	0f 92       	push	r0
     38c:	11 24       	eor	r1, r1
     38e:	2f 93       	push	r18
     390:	3f 93       	push	r19
     392:	4f 93       	push	r20
     394:	5f 93       	push	r21
     396:	6f 93       	push	r22
     398:	7f 93       	push	r23
     39a:	8f 93       	push	r24
     39c:	9f 93       	push	r25
     39e:	af 93       	push	r26
     3a0:	bf 93       	push	r27
     3a2:	ef 93       	push	r30
     3a4:	ff 93       	push	r31
     3a6:	df 93       	push	r29
     3a8:	cf 93       	push	r28
     3aa:	0f 92       	push	r0
     3ac:	0f 92       	push	r0
     3ae:	cd b7       	in	r28, 0x3d	; 61
     3b0:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     3b2:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     3b4:	80 91 c6 00 	lds	r24, 0x00C6
     3b8:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     3ba:	80 91 51 02 	lds	r24, 0x0251
     3be:	90 91 52 02 	lds	r25, 0x0252
     3c2:	be 01       	movw	r22, r28
     3c4:	6f 5f       	subi	r22, 0xFF	; 255
     3c6:	7f 4f       	sbci	r23, 0xFF	; 255
     3c8:	ae 01       	movw	r20, r28
     3ca:	4e 5f       	subi	r20, 0xFE	; 254
     3cc:	5f 4f       	sbci	r21, 0xFF	; 255
     3ce:	20 e0       	ldi	r18, 0x00	; 0
     3d0:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     3d4:	8a 81       	ldd	r24, Y+2	; 0x02
     3d6:	88 23       	and	r24, r24
     3d8:	11 f0       	breq	.+4      	; 0x3de <__vector_25+0x5e>
	{
		taskYIELD();
     3da:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
	}
}
     3de:	0f 90       	pop	r0
     3e0:	0f 90       	pop	r0
     3e2:	cf 91       	pop	r28
     3e4:	df 91       	pop	r29
     3e6:	ff 91       	pop	r31
     3e8:	ef 91       	pop	r30
     3ea:	bf 91       	pop	r27
     3ec:	af 91       	pop	r26
     3ee:	9f 91       	pop	r25
     3f0:	8f 91       	pop	r24
     3f2:	7f 91       	pop	r23
     3f4:	6f 91       	pop	r22
     3f6:	5f 91       	pop	r21
     3f8:	4f 91       	pop	r20
     3fa:	3f 91       	pop	r19
     3fc:	2f 91       	pop	r18
     3fe:	0f 90       	pop	r0
     400:	0b be       	out	0x3b, r0	; 59
     402:	0f 90       	pop	r0
     404:	0f be       	out	0x3f, r0	; 63
     406:	0f 90       	pop	r0
     408:	1f 90       	pop	r1
     40a:	18 95       	reti

0000040c <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     40c:	df 93       	push	r29
     40e:	cf 93       	push	r28
     410:	0f 92       	push	r0
     412:	cd b7       	in	r28, 0x3d	; 61
     414:	de b7       	in	r29, 0x3e	; 62
     416:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     418:	80 91 53 02 	lds	r24, 0x0253
     41c:	90 91 54 02 	lds	r25, 0x0254
     420:	be 01       	movw	r22, r28
     422:	6f 5f       	subi	r22, 0xFF	; 255
     424:	7f 4f       	sbci	r23, 0xFF	; 255
     426:	20 e0       	ldi	r18, 0x00	; 0
     428:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <xQueueGenericSend>
     42c:	81 30       	cpi	r24, 0x01	; 1
     42e:	11 f0       	breq	.+4      	; 0x434 <xSerialPutChar+0x28>
     430:	80 e0       	ldi	r24, 0x00	; 0
     432:	06 c0       	rjmp	.+12     	; 0x440 <xSerialPutChar+0x34>
	{
		return pdFAIL;
	}

	vInterruptOn();
     434:	80 91 c1 00 	lds	r24, 0x00C1
     438:	80 62       	ori	r24, 0x20	; 32
     43a:	80 93 c1 00 	sts	0x00C1, r24
     43e:	81 e0       	ldi	r24, 0x01	; 1

	return pdPASS;
}
     440:	0f 90       	pop	r0
     442:	cf 91       	pop	r28
     444:	df 91       	pop	r29
     446:	08 95       	ret

00000448 <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     448:	80 91 51 02 	lds	r24, 0x0251
     44c:	90 91 52 02 	lds	r25, 0x0252
     450:	20 e0       	ldi	r18, 0x00	; 0
     452:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <xQueueGenericReceive>
     456:	81 11       	cpse	r24, r1
     458:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
     45a:	08 95       	ret

0000045c <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     45c:	df 92       	push	r13
     45e:	ef 92       	push	r14
     460:	ff 92       	push	r15
     462:	0f 93       	push	r16
     464:	1f 93       	push	r17
     466:	7b 01       	movw	r14, r22
     468:	8c 01       	movw	r16, r24
     46a:	d4 2e       	mov	r13, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     46c:	0f b6       	in	r0, 0x3f	; 63
     46e:	f8 94       	cli
     470:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     472:	84 2f       	mov	r24, r20
     474:	61 e0       	ldi	r22, 0x01	; 1
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericCreate>
     47c:	90 93 52 02 	sts	0x0252, r25
     480:	80 93 51 02 	sts	0x0251, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     484:	8d 2d       	mov	r24, r13
     486:	61 e0       	ldi	r22, 0x01	; 1
     488:	40 e0       	ldi	r20, 0x00	; 0
     48a:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericCreate>
     48e:	90 93 54 02 	sts	0x0254, r25
     492:	80 93 53 02 	sts	0x0253, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     496:	94 e0       	ldi	r25, 0x04	; 4
     498:	ee 0c       	add	r14, r14
     49a:	ff 1c       	adc	r15, r15
     49c:	00 1f       	adc	r16, r16
     49e:	11 1f       	adc	r17, r17
     4a0:	9a 95       	dec	r25
     4a2:	d1 f7       	brne	.-12     	; 0x498 <xSerialPortInitMinimal+0x3c>
     4a4:	60 e0       	ldi	r22, 0x00	; 0
     4a6:	74 e2       	ldi	r23, 0x24	; 36
     4a8:	84 ef       	ldi	r24, 0xF4	; 244
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	a8 01       	movw	r20, r16
     4ae:	97 01       	movw	r18, r14
     4b0:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <__udivmodsi4>
     4b4:	21 50       	subi	r18, 0x01	; 1
     4b6:	30 40       	sbci	r19, 0x00	; 0
     4b8:	40 40       	sbci	r20, 0x00	; 0
     4ba:	50 40       	sbci	r21, 0x00	; 0

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     4bc:	20 93 c4 00 	sts	0x00C4, r18

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     4c0:	23 2f       	mov	r18, r19
     4c2:	34 2f       	mov	r19, r20
     4c4:	45 2f       	mov	r20, r21
     4c6:	55 27       	eor	r21, r21
		UBRR0H = ucByte;
     4c8:	20 93 c5 00 	sts	0x00C5, r18

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     4cc:	88 e9       	ldi	r24, 0x98	; 152
     4ce:	80 93 c1 00 	sts	0x00C1, r24

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     4d2:	86 e8       	ldi	r24, 0x86	; 134
     4d4:	80 93 c2 00 	sts	0x00C2, r24
	}
	portEXIT_CRITICAL();
     4d8:	0f 90       	pop	r0
     4da:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	1f 91       	pop	r17
     4e2:	0f 91       	pop	r16
     4e4:	ff 90       	pop	r15
     4e6:	ef 90       	pop	r14
     4e8:	df 90       	pop	r13
     4ea:	08 95       	ret

000004ec <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	80 91 55 02 	lds	r24, 0x0255
     4f2:	88 23       	and	r24, r24
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <xAreRegTestTasksStillRunning+0xc>
     4f6:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4f8:	89 2f       	mov	r24, r25
     4fa:	08 95       	ret

000004fc <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     4fc:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     4fe:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     500:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     502:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     504:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     506:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     508:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     50a:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     50c:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     50e:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     510:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     512:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     514:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     516:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     518:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     51a:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     51c:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     51e:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     520:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     522:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     524:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     526:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     528:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     52a:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     52c:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     52e:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     530:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     532:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     534:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     536:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     538:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     53a:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     53c:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     53e:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     540:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     542:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     544:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     546:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     548:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     54a:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     54c:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     54e:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     550:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     552:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     554:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     556:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     558:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     55a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	6"			);
     55e:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     560:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     562:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	7"			);
     566:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     568:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     56a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	8"			);
     56e:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     570:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     572:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	9"			);
     576:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     578:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     57a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	10"			);
     57e:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     580:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     582:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	11"			);
     586:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     588:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     58a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	12"			);
     58e:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     590:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     592:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	13"			);
     596:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     598:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     59a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	14"			);
     59e:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     5a0:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     5a2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	15"			);
     5a6:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     5a8:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     5aa:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	16"			);
     5ae:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     5b0:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     5b2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	17"			);
     5b6:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     5b8:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     5ba:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	18"			);
     5be:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     5c0:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     5c2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	19"			);
     5c6:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     5c8:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     5ca:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	20"			);
     5ce:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     5d0:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     5d2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	21"			);
     5d6:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     5d8:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     5da:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	22"			);
     5de:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     5e0:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     5e2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	23"			);
     5e6:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     5e8:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     5ea:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	24"			);
     5ee:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     5f0:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     5f2:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	25"			);
     5f6:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     5f8:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     5fa:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	26"			);
     5fe:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     600:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     602:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	27"			);
     606:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     608:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     60a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	28"			);
     60e:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     610:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     612:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	29"			);
     616:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     618:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     61a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	30"			);
     61e:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     620:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     622:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	31"			);
     626:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     628:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     62a:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	32"			);
     62e:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     630:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     632:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	33"			);
     636:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     638:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     63a:	00 92 55 02 	sts	0x0255, r0
     63e:	5e cf       	rjmp	.-324    	; 0x4fc <prvRegisterCheck1>

00000640 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     640:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     642:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     644:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     646:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     648:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     64a:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     64c:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     64e:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     650:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     652:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     654:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     656:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     658:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     65a:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     65c:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     65e:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     660:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     662:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     664:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     666:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     668:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     66a:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     66c:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     66e:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     670:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     672:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     674:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     676:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     678:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     67a:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     67c:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     67e:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     680:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     682:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     684:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     686:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     688:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     68a:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     68c:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     68e:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     690:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     692:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     694:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     696:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     698:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     69a:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     69c:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     69e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	2"			);
     6a2:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     6a4:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     6a6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	3"			);
     6aa:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     6ac:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     6ae:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	4"			);
     6b2:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     6b4:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     6b6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	5"			);
     6ba:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     6bc:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     6be:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	6"			);
     6c2:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     6c4:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     6c6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	7"			);
     6ca:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     6cc:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     6ce:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	8"			);
     6d2:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     6d4:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     6d6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	9"			);
     6da:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     6dc:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     6de:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	10"			);
     6e2:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     6e4:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     6e6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	11"			);
     6ea:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     6ec:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     6ee:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	12"			);
     6f2:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     6f4:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     6f6:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	13"			);
     6fa:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     6fc:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     6fe:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	14"			);
     702:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     704:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     706:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	15"			);
     70a:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     70c:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     70e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	16"			);
     712:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     714:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     716:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	17"			);
     71a:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     71c:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     71e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	18"			);
     722:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     724:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     726:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	19"			);
     72a:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     72c:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     72e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	20"			);
     732:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     734:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     736:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	21"			);
     73a:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     73c:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     73e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	22"			);
     742:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     744:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     746:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	23"			);
     74a:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     74c:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     74e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	24"			);
     752:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     754:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     756:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	25"			);
     75a:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     75c:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     75e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	26"			);
     762:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     764:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     766:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	27"			);
     76a:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     76c:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     76e:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	28"			);
     772:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     774:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     776:	00 92 55 02 	sts	0x0255, r0
		asm(	"LDI	r31,	29"			);
     77a:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     77c:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     77e:	00 92 55 02 	sts	0x0255, r0
     782:	5e cf       	rjmp	.-324    	; 0x640 <prvRegisterCheck2>

00000784 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     784:	ef 92       	push	r14
     786:	ff 92       	push	r15
     788:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     78a:	8e e7       	ldi	r24, 0x7E	; 126
     78c:	92 e0       	ldi	r25, 0x02	; 2
     78e:	6b e0       	ldi	r22, 0x0B	; 11
     790:	72 e0       	ldi	r23, 0x02	; 2
     792:	45 e5       	ldi	r20, 0x55	; 85
     794:	50 e0       	ldi	r21, 0x00	; 0
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	00 e0       	ldi	r16, 0x00	; 0
     79c:	ee 24       	eor	r14, r14
     79e:	ff 24       	eor	r15, r15
     7a0:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     7a4:	80 e2       	ldi	r24, 0x20	; 32
     7a6:	93 e0       	ldi	r25, 0x03	; 3
     7a8:	60 e1       	ldi	r22, 0x10	; 16
     7aa:	72 e0       	ldi	r23, 0x02	; 2
     7ac:	45 e5       	ldi	r20, 0x55	; 85
     7ae:	50 e0       	ldi	r21, 0x00	; 0
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
}
     7b8:	0f 91       	pop	r16
     7ba:	ff 90       	pop	r15
     7bc:	ef 90       	pop	r14
     7be:	08 95       	ret

000007c0 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     7c0:	80 91 58 02 	lds	r24, 0x0258
     7c4:	8f 5f       	subi	r24, 0xFF	; 255
     7c6:	80 93 58 02 	sts	0x0258, r24
}
     7ca:	08 95       	ret

000007cc <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	f8 94       	cli
     7d0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     7d2:	20 91 5b 02 	lds	r18, 0x025B
     7d6:	30 91 5c 02 	lds	r19, 0x025C
	}
	portTICK_TYPE_EXIT_CRITICAL();
     7da:	0f 90       	pop	r0
     7dc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     7de:	c9 01       	movw	r24, r18
     7e0:	08 95       	ret

000007e2 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     7e2:	20 91 5b 02 	lds	r18, 0x025B
     7e6:	30 91 5c 02 	lds	r19, 0x025C
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7ea:	c9 01       	movw	r24, r18
     7ec:	08 95       	ret

000007ee <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     7ee:	80 91 61 02 	lds	r24, 0x0261
}
     7f2:	08 95       	ret

000007f4 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	21 f4       	brne	.+8      	; 0x800 <pcTaskGetName+0xc>
     7f8:	80 91 56 02 	lds	r24, 0x0256
     7fc:	90 91 57 02 	lds	r25, 0x0257
     800:	9c 01       	movw	r18, r24
     802:	27 5e       	subi	r18, 0xE7	; 231
     804:	3f 4f       	sbci	r19, 0xFF	; 255
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     806:	c9 01       	movw	r24, r18
     808:	08 95       	ret

0000080a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     80a:	80 91 58 02 	lds	r24, 0x0258
     80e:	88 23       	and	r24, r24
     810:	21 f0       	breq	.+8      	; 0x81a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	80 93 5a 02 	sts	0x025A, r24
     818:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     81a:	10 92 5a 02 	sts	0x025A, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     81e:	20 91 59 02 	lds	r18, 0x0259
     822:	99 e0       	ldi	r25, 0x09	; 9
     824:	01 c0       	rjmp	.+2      	; 0x828 <vTaskSwitchContext+0x1e>
     826:	21 50       	subi	r18, 0x01	; 1
     828:	29 9f       	mul	r18, r25
     82a:	d0 01       	movw	r26, r0
     82c:	11 24       	eor	r1, r1
     82e:	a9 59       	subi	r26, 0x99	; 153
     830:	bd 4f       	sbci	r27, 0xFD	; 253
     832:	8c 91       	ld	r24, X
     834:	88 23       	and	r24, r24
     836:	b9 f3       	breq	.-18     	; 0x826 <vTaskSwitchContext+0x1c>
     838:	11 96       	adiw	r26, 0x01	; 1
     83a:	ed 91       	ld	r30, X+
     83c:	fc 91       	ld	r31, X
     83e:	12 97       	sbiw	r26, 0x02	; 2
     840:	02 80       	ldd	r0, Z+2	; 0x02
     842:	f3 81       	ldd	r31, Z+3	; 0x03
     844:	e0 2d       	mov	r30, r0
     846:	12 96       	adiw	r26, 0x02	; 2
     848:	fc 93       	st	X, r31
     84a:	ee 93       	st	-X, r30
     84c:	11 97       	sbiw	r26, 0x01	; 1
     84e:	cd 01       	movw	r24, r26
     850:	03 96       	adiw	r24, 0x03	; 3
     852:	e8 17       	cp	r30, r24
     854:	f9 07       	cpc	r31, r25
     856:	31 f4       	brne	.+12     	; 0x864 <vTaskSwitchContext+0x5a>
     858:	82 81       	ldd	r24, Z+2	; 0x02
     85a:	93 81       	ldd	r25, Z+3	; 0x03
     85c:	12 96       	adiw	r26, 0x02	; 2
     85e:	9c 93       	st	X, r25
     860:	8e 93       	st	-X, r24
     862:	11 97       	sbiw	r26, 0x01	; 1
     864:	11 96       	adiw	r26, 0x01	; 1
     866:	ed 91       	ld	r30, X+
     868:	fc 91       	ld	r31, X
     86a:	12 97       	sbiw	r26, 0x02	; 2
     86c:	86 81       	ldd	r24, Z+6	; 0x06
     86e:	97 81       	ldd	r25, Z+7	; 0x07
     870:	90 93 57 02 	sts	0x0257, r25
     874:	80 93 56 02 	sts	0x0256, r24
     878:	20 93 59 02 	sts	0x0259, r18
     87c:	08 95       	ret

0000087e <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     87e:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     880:	80 91 5f 02 	lds	r24, 0x025F
     884:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     886:	80 91 5b 02 	lds	r24, 0x025B
     88a:	90 91 5c 02 	lds	r25, 0x025C
     88e:	92 83       	std	Z+2, r25	; 0x02
     890:	81 83       	std	Z+1, r24	; 0x01
}
     892:	08 95       	ret

00000894 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     894:	fc 01       	movw	r30, r24
     896:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     898:	0f b6       	in	r0, 0x3f	; 63
     89a:	f8 94       	cli
     89c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     89e:	40 91 5b 02 	lds	r20, 0x025B
     8a2:	50 91 5c 02 	lds	r21, 0x025C
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     8a6:	90 91 5f 02 	lds	r25, 0x025F
     8aa:	80 81       	ld	r24, Z
     8ac:	98 17       	cp	r25, r24
     8ae:	29 f0       	breq	.+10     	; 0x8ba <xTaskCheckForTimeOut+0x26>
     8b0:	81 81       	ldd	r24, Z+1	; 0x01
     8b2:	92 81       	ldd	r25, Z+2	; 0x02
     8b4:	48 17       	cp	r20, r24
     8b6:	59 07       	cpc	r21, r25
     8b8:	e0 f4       	brcc	.+56     	; 0x8f2 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     8ba:	21 81       	ldd	r18, Z+1	; 0x01
     8bc:	32 81       	ldd	r19, Z+2	; 0x02
     8be:	6d 91       	ld	r22, X+
     8c0:	7c 91       	ld	r23, X
     8c2:	11 97       	sbiw	r26, 0x01	; 1
     8c4:	ca 01       	movw	r24, r20
     8c6:	82 1b       	sub	r24, r18
     8c8:	93 0b       	sbc	r25, r19
     8ca:	86 17       	cp	r24, r22
     8cc:	97 07       	cpc	r25, r23
     8ce:	88 f4       	brcc	.+34     	; 0x8f2 <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
     8d0:	24 1b       	sub	r18, r20
     8d2:	35 0b       	sbc	r19, r21
     8d4:	26 0f       	add	r18, r22
     8d6:	37 1f       	adc	r19, r23
     8d8:	2d 93       	st	X+, r18
     8da:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     8dc:	80 91 5f 02 	lds	r24, 0x025F
     8e0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     8e2:	80 91 5b 02 	lds	r24, 0x025B
     8e6:	90 91 5c 02 	lds	r25, 0x025C
     8ea:	92 83       	std	Z+2, r25	; 0x02
     8ec:	81 83       	std	Z+1, r24	; 0x01
     8ee:	80 e0       	ldi	r24, 0x00	; 0
     8f0:	01 c0       	rjmp	.+2      	; 0x8f4 <xTaskCheckForTimeOut+0x60>
     8f2:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     8f4:	0f 90       	pop	r0
     8f6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     8f8:	08 95       	ret

000008fa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 93 5a 02 	sts	0x025A, r24
}
     900:	08 95       	ret

00000902 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     902:	e0 91 56 02 	lds	r30, 0x0256
     906:	f0 91 57 02 	lds	r31, 0x0257
     90a:	84 85       	ldd	r24, Z+12	; 0x0c
     90c:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     90e:	a0 91 56 02 	lds	r26, 0x0256
     912:	b0 91 57 02 	lds	r27, 0x0257
     916:	e0 91 56 02 	lds	r30, 0x0256
     91a:	f0 91 57 02 	lds	r31, 0x0257
     91e:	46 89       	ldd	r20, Z+22	; 0x16
     920:	24 e0       	ldi	r18, 0x04	; 4
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	24 1b       	sub	r18, r20
     926:	31 09       	sbc	r19, r1
     928:	1d 96       	adiw	r26, 0x0d	; 13
     92a:	3c 93       	st	X, r19
     92c:	2e 93       	st	-X, r18
     92e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
}
     930:	08 95       	ret

00000932 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	29 f4       	brne	.+10     	; 0x940 <xTaskNotifyStateClear+0xe>
     936:	e0 91 56 02 	lds	r30, 0x0256
     93a:	f0 91 57 02 	lds	r31, 0x0257
     93e:	01 c0       	rjmp	.+2      	; 0x942 <xTaskNotifyStateClear+0x10>
     940:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
     942:	0f b6       	in	r0, 0x3f	; 63
     944:	f8 94       	cli
     946:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
     948:	85 a1       	ldd	r24, Z+37	; 0x25
     94a:	82 30       	cpi	r24, 0x02	; 2
     94c:	11 f0       	breq	.+4      	; 0x952 <xTaskNotifyStateClear+0x20>
     94e:	80 e0       	ldi	r24, 0x00	; 0
     950:	02 c0       	rjmp	.+4      	; 0x956 <xTaskNotifyStateClear+0x24>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     952:	15 a2       	std	Z+37, r1	; 0x25
     954:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		taskEXIT_CRITICAL();
     956:	0f 90       	pop	r0
     958:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     95a:	08 95       	ret

0000095c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
     95c:	ef 92       	push	r14
     95e:	ff 92       	push	r15
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	7b 01       	movw	r14, r22
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     96a:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
     96c:	2d a1       	ldd	r18, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     96e:	82 e0       	ldi	r24, 0x02	; 2
     970:	8d a3       	std	Y+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
     972:	89 a1       	ldd	r24, Y+33	; 0x21
     974:	9a a1       	ldd	r25, Y+34	; 0x22
     976:	ab a1       	ldd	r26, Y+35	; 0x23
     978:	bc a1       	ldd	r27, Y+36	; 0x24
     97a:	01 96       	adiw	r24, 0x01	; 1
     97c:	a1 1d       	adc	r26, r1
     97e:	b1 1d       	adc	r27, r1
     980:	89 a3       	std	Y+33, r24	; 0x21
     982:	9a a3       	std	Y+34, r25	; 0x22
     984:	ab a3       	std	Y+35, r26	; 0x23
     986:	bc a3       	std	Y+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     988:	21 30       	cpi	r18, 0x01	; 1
     98a:	91 f5       	brne	.+100    	; 0x9f0 <vTaskNotifyGiveFromISR+0x94>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     98c:	80 91 58 02 	lds	r24, 0x0258
     990:	88 23       	and	r24, r24
     992:	a9 f4       	brne	.+42     	; 0x9be <vTaskNotifyGiveFromISR+0x62>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     994:	8e 01       	movw	r16, r28
     996:	0e 5f       	subi	r16, 0xFE	; 254
     998:	1f 4f       	sbci	r17, 0xFF	; 255
     99a:	c8 01       	movw	r24, r16
     99c:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     9a0:	9e 89       	ldd	r25, Y+22	; 0x16
     9a2:	80 91 59 02 	lds	r24, 0x0259
     9a6:	89 17       	cp	r24, r25
     9a8:	10 f4       	brcc	.+4      	; 0x9ae <vTaskNotifyGiveFromISR+0x52>
     9aa:	90 93 59 02 	sts	0x0259, r25
     9ae:	89 e0       	ldi	r24, 0x09	; 9
     9b0:	98 9f       	mul	r25, r24
     9b2:	c0 01       	movw	r24, r0
     9b4:	11 24       	eor	r1, r1
     9b6:	89 59       	subi	r24, 0x99	; 153
     9b8:	9d 4f       	sbci	r25, 0xFD	; 253
     9ba:	b8 01       	movw	r22, r16
     9bc:	05 c0       	rjmp	.+10     	; 0x9c8 <vTaskNotifyGiveFromISR+0x6c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     9be:	be 01       	movw	r22, r28
     9c0:	64 5f       	subi	r22, 0xF4	; 244
     9c2:	7f 4f       	sbci	r23, 0xFF	; 255
     9c4:	81 ea       	ldi	r24, 0xA1	; 161
     9c6:	92 e0       	ldi	r25, 0x02	; 2
     9c8:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     9cc:	e0 91 56 02 	lds	r30, 0x0256
     9d0:	f0 91 57 02 	lds	r31, 0x0257
     9d4:	9e 89       	ldd	r25, Y+22	; 0x16
     9d6:	86 89       	ldd	r24, Z+22	; 0x16
     9d8:	89 17       	cp	r24, r25
     9da:	50 f4       	brcc	.+20     	; 0x9f0 <vTaskNotifyGiveFromISR+0x94>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     9dc:	e1 14       	cp	r14, r1
     9de:	f1 04       	cpc	r15, r1
     9e0:	21 f0       	breq	.+8      	; 0x9ea <vTaskNotifyGiveFromISR+0x8e>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	f7 01       	movw	r30, r14
     9e6:	80 83       	st	Z, r24
     9e8:	03 c0       	rjmp	.+6      	; 0x9f0 <vTaskNotifyGiveFromISR+0x94>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	80 93 5a 02 	sts	0x025A, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	ff 90       	pop	r15
     9fa:	ef 90       	pop	r14
     9fc:	08 95       	ret

000009fe <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     9fe:	ef 92       	push	r14
     a00:	ff 92       	push	r15
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	f8 01       	movw	r30, r16
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     a0c:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     a0e:	01 15       	cp	r16, r1
     a10:	11 05       	cpc	r17, r1
     a12:	41 f0       	breq	.+16     	; 0xa24 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     a14:	89 a1       	ldd	r24, Y+33	; 0x21
     a16:	9a a1       	ldd	r25, Y+34	; 0x22
     a18:	ab a1       	ldd	r26, Y+35	; 0x23
     a1a:	bc a1       	ldd	r27, Y+36	; 0x24
     a1c:	80 83       	st	Z, r24
     a1e:	91 83       	std	Z+1, r25	; 0x01
     a20:	a2 83       	std	Z+2, r26	; 0x02
     a22:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     a24:	3d a1       	ldd	r19, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     a26:	82 e0       	ldi	r24, 0x02	; 2
     a28:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     a2a:	22 30       	cpi	r18, 0x02	; 2
     a2c:	99 f0       	breq	.+38     	; 0xa54 <xTaskGenericNotifyFromISR+0x56>
     a2e:	23 30       	cpi	r18, 0x03	; 3
     a30:	18 f4       	brcc	.+6      	; 0xa38 <xTaskGenericNotifyFromISR+0x3a>
     a32:	21 30       	cpi	r18, 0x01	; 1
     a34:	19 f5       	brne	.+70     	; 0xa7c <xTaskGenericNotifyFromISR+0x7e>
     a36:	05 c0       	rjmp	.+10     	; 0xa42 <xTaskGenericNotifyFromISR+0x44>
     a38:	23 30       	cpi	r18, 0x03	; 3
     a3a:	e1 f0       	breq	.+56     	; 0xa74 <xTaskGenericNotifyFromISR+0x76>
     a3c:	24 30       	cpi	r18, 0x04	; 4
     a3e:	f1 f4       	brne	.+60     	; 0xa7c <xTaskGenericNotifyFromISR+0x7e>
     a40:	15 c0       	rjmp	.+42     	; 0xa6c <xTaskGenericNotifyFromISR+0x6e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     a42:	89 a1       	ldd	r24, Y+33	; 0x21
     a44:	9a a1       	ldd	r25, Y+34	; 0x22
     a46:	ab a1       	ldd	r26, Y+35	; 0x23
     a48:	bc a1       	ldd	r27, Y+36	; 0x24
     a4a:	84 2b       	or	r24, r20
     a4c:	95 2b       	or	r25, r21
     a4e:	a6 2b       	or	r26, r22
     a50:	b7 2b       	or	r27, r23
     a52:	07 c0       	rjmp	.+14     	; 0xa62 <xTaskGenericNotifyFromISR+0x64>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     a54:	89 a1       	ldd	r24, Y+33	; 0x21
     a56:	9a a1       	ldd	r25, Y+34	; 0x22
     a58:	ab a1       	ldd	r26, Y+35	; 0x23
     a5a:	bc a1       	ldd	r27, Y+36	; 0x24
     a5c:	01 96       	adiw	r24, 0x01	; 1
     a5e:	a1 1d       	adc	r26, r1
     a60:	b1 1d       	adc	r27, r1
     a62:	89 a3       	std	Y+33, r24	; 0x21
     a64:	9a a3       	std	Y+34, r25	; 0x22
     a66:	ab a3       	std	Y+35, r26	; 0x23
     a68:	bc a3       	std	Y+36, r27	; 0x24
     a6a:	08 c0       	rjmp	.+16     	; 0xa7c <xTaskGenericNotifyFromISR+0x7e>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     a6c:	32 30       	cpi	r19, 0x02	; 2
     a6e:	11 f4       	brne	.+4      	; 0xa74 <xTaskGenericNotifyFromISR+0x76>
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	3a c0       	rjmp	.+116    	; 0xae8 <xTaskGenericNotifyFromISR+0xea>
					{
						pxTCB->ulNotifiedValue = ulValue;
     a74:	49 a3       	std	Y+33, r20	; 0x21
     a76:	5a a3       	std	Y+34, r21	; 0x22
     a78:	6b a3       	std	Y+35, r22	; 0x23
     a7a:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     a7c:	31 30       	cpi	r19, 0x01	; 1
     a7e:	99 f5       	brne	.+102    	; 0xae6 <xTaskGenericNotifyFromISR+0xe8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a80:	80 91 58 02 	lds	r24, 0x0258
     a84:	88 23       	and	r24, r24
     a86:	a9 f4       	brne	.+42     	; 0xab2 <xTaskGenericNotifyFromISR+0xb4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     a88:	8e 01       	movw	r16, r28
     a8a:	0e 5f       	subi	r16, 0xFE	; 254
     a8c:	1f 4f       	sbci	r17, 0xFF	; 255
     a8e:	c8 01       	movw	r24, r16
     a90:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a94:	9e 89       	ldd	r25, Y+22	; 0x16
     a96:	80 91 59 02 	lds	r24, 0x0259
     a9a:	89 17       	cp	r24, r25
     a9c:	10 f4       	brcc	.+4      	; 0xaa2 <xTaskGenericNotifyFromISR+0xa4>
     a9e:	90 93 59 02 	sts	0x0259, r25
     aa2:	89 e0       	ldi	r24, 0x09	; 9
     aa4:	98 9f       	mul	r25, r24
     aa6:	c0 01       	movw	r24, r0
     aa8:	11 24       	eor	r1, r1
     aaa:	89 59       	subi	r24, 0x99	; 153
     aac:	9d 4f       	sbci	r25, 0xFD	; 253
     aae:	b8 01       	movw	r22, r16
     ab0:	05 c0       	rjmp	.+10     	; 0xabc <xTaskGenericNotifyFromISR+0xbe>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     ab2:	be 01       	movw	r22, r28
     ab4:	64 5f       	subi	r22, 0xF4	; 244
     ab6:	7f 4f       	sbci	r23, 0xFF	; 255
     ab8:	81 ea       	ldi	r24, 0xA1	; 161
     aba:	92 e0       	ldi	r25, 0x02	; 2
     abc:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     ac0:	e0 91 56 02 	lds	r30, 0x0256
     ac4:	f0 91 57 02 	lds	r31, 0x0257
     ac8:	9e 89       	ldd	r25, Y+22	; 0x16
     aca:	86 89       	ldd	r24, Z+22	; 0x16
     acc:	89 17       	cp	r24, r25
     ace:	58 f4       	brcc	.+22     	; 0xae6 <xTaskGenericNotifyFromISR+0xe8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     ad0:	e1 14       	cp	r14, r1
     ad2:	f1 04       	cpc	r15, r1
     ad4:	21 f0       	breq	.+8      	; 0xade <xTaskGenericNotifyFromISR+0xe0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	f7 01       	movw	r30, r14
     ada:	80 83       	st	Z, r24
     adc:	05 c0       	rjmp	.+10     	; 0xae8 <xTaskGenericNotifyFromISR+0xea>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	80 93 5a 02 	sts	0x025A, r24
     ae4:	01 c0       	rjmp	.+2      	; 0xae8 <xTaskGenericNotifyFromISR+0xea>
     ae6:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	1f 91       	pop	r17
     aee:	0f 91       	pop	r16
     af0:	ff 90       	pop	r15
     af2:	ef 90       	pop	r14
     af4:	08 95       	ret

00000af6 <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	fc 01       	movw	r30, r24
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b00:	70 68       	ori	r23, 0x80	; 128
     b02:	71 83       	std	Z+1, r23	; 0x01
     b04:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
     b06:	c6 81       	ldd	r28, Z+6	; 0x06
     b08:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     b0a:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     b0e:	8e 01       	movw	r16, r28
     b10:	0e 5f       	subi	r16, 0xFE	; 254
     b12:	1f 4f       	sbci	r17, 0xFF	; 255
     b14:	c8 01       	movw	r24, r16
     b16:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     b1a:	9e 89       	ldd	r25, Y+22	; 0x16
     b1c:	80 91 59 02 	lds	r24, 0x0259
     b20:	89 17       	cp	r24, r25
     b22:	10 f4       	brcc	.+4      	; 0xb28 <xTaskRemoveFromUnorderedEventList+0x32>
     b24:	90 93 59 02 	sts	0x0259, r25
     b28:	89 e0       	ldi	r24, 0x09	; 9
     b2a:	98 9f       	mul	r25, r24
     b2c:	c0 01       	movw	r24, r0
     b2e:	11 24       	eor	r1, r1
     b30:	89 59       	subi	r24, 0x99	; 153
     b32:	9d 4f       	sbci	r25, 0xFD	; 253
     b34:	b8 01       	movw	r22, r16
     b36:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     b3a:	e0 91 56 02 	lds	r30, 0x0256
     b3e:	f0 91 57 02 	lds	r31, 0x0257
     b42:	9e 89       	ldd	r25, Y+22	; 0x16
     b44:	86 89       	ldd	r24, Z+22	; 0x16
     b46:	89 17       	cp	r24, r25
     b48:	10 f0       	brcs	.+4      	; 0xb4e <xTaskRemoveFromUnorderedEventList+0x58>
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	03 c0       	rjmp	.+6      	; 0xb54 <xTaskRemoveFromUnorderedEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	80 93 5a 02 	sts	0x025A, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     b54:	df 91       	pop	r29
     b56:	cf 91       	pop	r28
     b58:	1f 91       	pop	r17
     b5a:	0f 91       	pop	r16
     b5c:	08 95       	ret

00000b5e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     b5e:	0f 93       	push	r16
     b60:	1f 93       	push	r17
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     b66:	dc 01       	movw	r26, r24
     b68:	15 96       	adiw	r26, 0x05	; 5
     b6a:	ed 91       	ld	r30, X+
     b6c:	fc 91       	ld	r31, X
     b6e:	16 97       	sbiw	r26, 0x06	; 6
     b70:	c6 81       	ldd	r28, Z+6	; 0x06
     b72:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     b74:	8e 01       	movw	r16, r28
     b76:	04 5f       	subi	r16, 0xF4	; 244
     b78:	1f 4f       	sbci	r17, 0xFF	; 255
     b7a:	c8 01       	movw	r24, r16
     b7c:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b80:	80 91 58 02 	lds	r24, 0x0258
     b84:	88 23       	and	r24, r24
     b86:	a1 f4       	brne	.+40     	; 0xbb0 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     b88:	8e 01       	movw	r16, r28
     b8a:	0e 5f       	subi	r16, 0xFE	; 254
     b8c:	1f 4f       	sbci	r17, 0xFF	; 255
     b8e:	c8 01       	movw	r24, r16
     b90:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     b94:	9e 89       	ldd	r25, Y+22	; 0x16
     b96:	80 91 59 02 	lds	r24, 0x0259
     b9a:	89 17       	cp	r24, r25
     b9c:	10 f4       	brcc	.+4      	; 0xba2 <xTaskRemoveFromEventList+0x44>
     b9e:	90 93 59 02 	sts	0x0259, r25
     ba2:	89 e0       	ldi	r24, 0x09	; 9
     ba4:	98 9f       	mul	r25, r24
     ba6:	c0 01       	movw	r24, r0
     ba8:	11 24       	eor	r1, r1
     baa:	89 59       	subi	r24, 0x99	; 153
     bac:	9d 4f       	sbci	r25, 0xFD	; 253
     bae:	02 c0       	rjmp	.+4      	; 0xbb4 <xTaskRemoveFromEventList+0x56>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     bb0:	81 ea       	ldi	r24, 0xA1	; 161
     bb2:	92 e0       	ldi	r25, 0x02	; 2
     bb4:	b8 01       	movw	r22, r16
     bb6:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     bba:	e0 91 56 02 	lds	r30, 0x0256
     bbe:	f0 91 57 02 	lds	r31, 0x0257
     bc2:	9e 89       	ldd	r25, Y+22	; 0x16
     bc4:	86 89       	ldd	r24, Z+22	; 0x16
     bc6:	89 17       	cp	r24, r25
     bc8:	10 f0       	brcs	.+4      	; 0xbce <xTaskRemoveFromEventList+0x70>
     bca:	80 e0       	ldi	r24, 0x00	; 0
     bcc:	03 c0       	rjmp	.+6      	; 0xbd4 <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	80 93 5a 02 	sts	0x025A, r24
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	08 95       	ret

00000bde <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     bde:	cf 92       	push	r12
     be0:	df 92       	push	r13
     be2:	ef 92       	push	r14
     be4:	ff 92       	push	r15
     be6:	0f 93       	push	r16
     be8:	1f 93       	push	r17
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     bee:	80 91 58 02 	lds	r24, 0x0258
     bf2:	88 23       	and	r24, r24
     bf4:	09 f0       	breq	.+2      	; 0xbf8 <xTaskIncrementTick+0x1a>
     bf6:	a6 c0       	rjmp	.+332    	; 0xd44 <xTaskIncrementTick+0x166>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     bf8:	00 91 5b 02 	lds	r16, 0x025B
     bfc:	10 91 5c 02 	lds	r17, 0x025C
     c00:	0f 5f       	subi	r16, 0xFF	; 255
     c02:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     c04:	10 93 5c 02 	sts	0x025C, r17
     c08:	00 93 5b 02 	sts	0x025B, r16

		if( xConstTickCount == ( TickType_t ) 0U )
     c0c:	01 15       	cp	r16, r1
     c0e:	11 05       	cpc	r17, r1
     c10:	79 f5       	brne	.+94     	; 0xc70 <xTaskIncrementTick+0x92>
		{
			taskSWITCH_DELAYED_LISTS();
     c12:	20 91 9d 02 	lds	r18, 0x029D
     c16:	30 91 9e 02 	lds	r19, 0x029E
     c1a:	80 91 9f 02 	lds	r24, 0x029F
     c1e:	90 91 a0 02 	lds	r25, 0x02A0
     c22:	90 93 9e 02 	sts	0x029E, r25
     c26:	80 93 9d 02 	sts	0x029D, r24
     c2a:	30 93 a0 02 	sts	0x02A0, r19
     c2e:	20 93 9f 02 	sts	0x029F, r18
     c32:	80 91 5f 02 	lds	r24, 0x025F
     c36:	8f 5f       	subi	r24, 0xFF	; 255
     c38:	80 93 5f 02 	sts	0x025F, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     c3c:	e0 91 9d 02 	lds	r30, 0x029D
     c40:	f0 91 9e 02 	lds	r31, 0x029E
     c44:	80 81       	ld	r24, Z
     c46:	88 23       	and	r24, r24
     c48:	19 f4       	brne	.+6      	; 0xc50 <xTaskIncrementTick+0x72>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     c4a:	8f ef       	ldi	r24, 0xFF	; 255
     c4c:	9f ef       	ldi	r25, 0xFF	; 255
     c4e:	0c c0       	rjmp	.+24     	; 0xc68 <xTaskIncrementTick+0x8a>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     c50:	e0 91 9d 02 	lds	r30, 0x029D
     c54:	f0 91 9e 02 	lds	r31, 0x029E
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     c58:	05 80       	ldd	r0, Z+5	; 0x05
     c5a:	f6 81       	ldd	r31, Z+6	; 0x06
     c5c:	e0 2d       	mov	r30, r0
     c5e:	06 80       	ldd	r0, Z+6	; 0x06
     c60:	f7 81       	ldd	r31, Z+7	; 0x07
     c62:	e0 2d       	mov	r30, r0
     c64:	82 81       	ldd	r24, Z+2	; 0x02
     c66:	93 81       	ldd	r25, Z+3	; 0x03
     c68:	90 93 5e 02 	sts	0x025E, r25
     c6c:	80 93 5d 02 	sts	0x025D, r24

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     c70:	80 91 5d 02 	lds	r24, 0x025D
     c74:	90 91 5e 02 	lds	r25, 0x025E
     c78:	08 17       	cp	r16, r24
     c7a:	19 07       	cpc	r17, r25
     c7c:	08 f4       	brcc	.+2      	; 0xc80 <xTaskIncrementTick+0xa2>
     c7e:	4b c0       	rjmp	.+150    	; 0xd16 <xTaskIncrementTick+0x138>
     c80:	dd 24       	eor	r13, r13
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     c82:	49 e0       	ldi	r20, 0x09	; 9
     c84:	c4 2e       	mov	r12, r20
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     c86:	e0 91 9d 02 	lds	r30, 0x029D
     c8a:	f0 91 9e 02 	lds	r31, 0x029E
     c8e:	80 81       	ld	r24, Z
     c90:	88 23       	and	r24, r24
     c92:	19 f4       	brne	.+6      	; 0xc9a <xTaskIncrementTick+0xbc>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     c94:	8f ef       	ldi	r24, 0xFF	; 255
     c96:	9f ef       	ldi	r25, 0xFF	; 255
     c98:	0e c0       	rjmp	.+28     	; 0xcb6 <xTaskIncrementTick+0xd8>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     c9a:	e0 91 9d 02 	lds	r30, 0x029D
     c9e:	f0 91 9e 02 	lds	r31, 0x029E
     ca2:	05 80       	ldd	r0, Z+5	; 0x05
     ca4:	f6 81       	ldd	r31, Z+6	; 0x06
     ca6:	e0 2d       	mov	r30, r0
     ca8:	c6 81       	ldd	r28, Z+6	; 0x06
     caa:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     cac:	8a 81       	ldd	r24, Y+2	; 0x02
     cae:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     cb0:	08 17       	cp	r16, r24
     cb2:	19 07       	cpc	r17, r25
     cb4:	28 f4       	brcc	.+10     	; 0xcc0 <xTaskIncrementTick+0xe2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     cb6:	90 93 5e 02 	sts	0x025E, r25
     cba:	80 93 5d 02 	sts	0x025D, r24
     cbe:	2c c0       	rjmp	.+88     	; 0xd18 <xTaskIncrementTick+0x13a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     cc0:	32 e0       	ldi	r19, 0x02	; 2
     cc2:	e3 2e       	mov	r14, r19
     cc4:	f1 2c       	mov	r15, r1
     cc6:	ec 0e       	add	r14, r28
     cc8:	fd 1e       	adc	r15, r29
     cca:	c7 01       	movw	r24, r14
     ccc:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     cd0:	8c 89       	ldd	r24, Y+20	; 0x14
     cd2:	9d 89       	ldd	r25, Y+21	; 0x15
     cd4:	89 2b       	or	r24, r25
     cd6:	21 f0       	breq	.+8      	; 0xce0 <xTaskIncrementTick+0x102>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     cd8:	ce 01       	movw	r24, r28
     cda:	0c 96       	adiw	r24, 0x0c	; 12
     cdc:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     ce0:	9e 89       	ldd	r25, Y+22	; 0x16
     ce2:	80 91 59 02 	lds	r24, 0x0259
     ce6:	89 17       	cp	r24, r25
     ce8:	10 f4       	brcc	.+4      	; 0xcee <xTaskIncrementTick+0x110>
     cea:	90 93 59 02 	sts	0x0259, r25
     cee:	9c 9d       	mul	r25, r12
     cf0:	c0 01       	movw	r24, r0
     cf2:	11 24       	eor	r1, r1
     cf4:	89 59       	subi	r24, 0x99	; 153
     cf6:	9d 4f       	sbci	r25, 0xFD	; 253
     cf8:	b7 01       	movw	r22, r14
     cfa:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cfe:	e0 91 56 02 	lds	r30, 0x0256
     d02:	f0 91 57 02 	lds	r31, 0x0257
     d06:	9e 89       	ldd	r25, Y+22	; 0x16
     d08:	86 89       	ldd	r24, Z+22	; 0x16
     d0a:	98 17       	cp	r25, r24
     d0c:	08 f4       	brcc	.+2      	; 0xd10 <xTaskIncrementTick+0x132>
     d0e:	bb cf       	rjmp	.-138    	; 0xc86 <xTaskIncrementTick+0xa8>
     d10:	dd 24       	eor	r13, r13
     d12:	d3 94       	inc	r13
     d14:	b8 cf       	rjmp	.-144    	; 0xc86 <xTaskIncrementTick+0xa8>
     d16:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     d18:	e0 91 56 02 	lds	r30, 0x0256
     d1c:	f0 91 57 02 	lds	r31, 0x0257
     d20:	86 89       	ldd	r24, Z+22	; 0x16
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	fc 01       	movw	r30, r24
     d26:	23 e0       	ldi	r18, 0x03	; 3
     d28:	ee 0f       	add	r30, r30
     d2a:	ff 1f       	adc	r31, r31
     d2c:	2a 95       	dec	r18
     d2e:	e1 f7       	brne	.-8      	; 0xd28 <xTaskIncrementTick+0x14a>
     d30:	e8 0f       	add	r30, r24
     d32:	f9 1f       	adc	r31, r25
     d34:	e9 59       	subi	r30, 0x99	; 153
     d36:	fd 4f       	sbci	r31, 0xFD	; 253
     d38:	80 81       	ld	r24, Z
     d3a:	82 30       	cpi	r24, 0x02	; 2
     d3c:	48 f0       	brcs	.+18     	; 0xd50 <xTaskIncrementTick+0x172>
     d3e:	dd 24       	eor	r13, r13
     d40:	d3 94       	inc	r13
     d42:	06 c0       	rjmp	.+12     	; 0xd50 <xTaskIncrementTick+0x172>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     d44:	80 91 60 02 	lds	r24, 0x0260
     d48:	8f 5f       	subi	r24, 0xFF	; 255
     d4a:	80 93 60 02 	sts	0x0260, r24
     d4e:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     d50:	80 91 5a 02 	lds	r24, 0x025A
     d54:	88 23       	and	r24, r24
     d56:	11 f0       	breq	.+4      	; 0xd5c <xTaskIncrementTick+0x17e>
     d58:	dd 24       	eor	r13, r13
     d5a:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     d5c:	8d 2d       	mov	r24, r13
     d5e:	df 91       	pop	r29
     d60:	cf 91       	pop	r28
     d62:	1f 91       	pop	r17
     d64:	0f 91       	pop	r16
     d66:	ff 90       	pop	r15
     d68:	ef 90       	pop	r14
     d6a:	df 90       	pop	r13
     d6c:	cf 90       	pop	r12
     d6e:	08 95       	ret

00000d70 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     d70:	0f 93       	push	r16
     d72:	1f 93       	push	r17
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
     d78:	f8 01       	movw	r30, r16
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
     d7a:	ec 01       	movw	r28, r24

		taskENTER_CRITICAL();
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     d82:	01 15       	cp	r16, r1
     d84:	11 05       	cpc	r17, r1
     d86:	41 f0       	breq	.+16     	; 0xd98 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     d88:	89 a1       	ldd	r24, Y+33	; 0x21
     d8a:	9a a1       	ldd	r25, Y+34	; 0x22
     d8c:	ab a1       	ldd	r26, Y+35	; 0x23
     d8e:	bc a1       	ldd	r27, Y+36	; 0x24
     d90:	80 83       	st	Z, r24
     d92:	91 83       	std	Z+1, r25	; 0x01
     d94:	a2 83       	std	Z+2, r26	; 0x02
     d96:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     d98:	3d a1       	ldd	r19, Y+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     d9a:	82 e0       	ldi	r24, 0x02	; 2
     d9c:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     d9e:	22 30       	cpi	r18, 0x02	; 2
     da0:	99 f0       	breq	.+38     	; 0xdc8 <xTaskGenericNotify+0x58>
     da2:	23 30       	cpi	r18, 0x03	; 3
     da4:	18 f4       	brcc	.+6      	; 0xdac <xTaskGenericNotify+0x3c>
     da6:	21 30       	cpi	r18, 0x01	; 1
     da8:	19 f5       	brne	.+70     	; 0xdf0 <xTaskGenericNotify+0x80>
     daa:	05 c0       	rjmp	.+10     	; 0xdb6 <xTaskGenericNotify+0x46>
     dac:	23 30       	cpi	r18, 0x03	; 3
     dae:	e1 f0       	breq	.+56     	; 0xde8 <xTaskGenericNotify+0x78>
     db0:	24 30       	cpi	r18, 0x04	; 4
     db2:	f1 f4       	brne	.+60     	; 0xdf0 <xTaskGenericNotify+0x80>
     db4:	15 c0       	rjmp	.+42     	; 0xde0 <xTaskGenericNotify+0x70>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     db6:	89 a1       	ldd	r24, Y+33	; 0x21
     db8:	9a a1       	ldd	r25, Y+34	; 0x22
     dba:	ab a1       	ldd	r26, Y+35	; 0x23
     dbc:	bc a1       	ldd	r27, Y+36	; 0x24
     dbe:	84 2b       	or	r24, r20
     dc0:	95 2b       	or	r25, r21
     dc2:	a6 2b       	or	r26, r22
     dc4:	b7 2b       	or	r27, r23
     dc6:	07 c0       	rjmp	.+14     	; 0xdd6 <xTaskGenericNotify+0x66>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     dc8:	89 a1       	ldd	r24, Y+33	; 0x21
     dca:	9a a1       	ldd	r25, Y+34	; 0x22
     dcc:	ab a1       	ldd	r26, Y+35	; 0x23
     dce:	bc a1       	ldd	r27, Y+36	; 0x24
     dd0:	01 96       	adiw	r24, 0x01	; 1
     dd2:	a1 1d       	adc	r26, r1
     dd4:	b1 1d       	adc	r27, r1
     dd6:	89 a3       	std	Y+33, r24	; 0x21
     dd8:	9a a3       	std	Y+34, r25	; 0x22
     dda:	ab a3       	std	Y+35, r26	; 0x23
     ddc:	bc a3       	std	Y+36, r27	; 0x24
     dde:	08 c0       	rjmp	.+16     	; 0xdf0 <xTaskGenericNotify+0x80>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     de0:	32 30       	cpi	r19, 0x02	; 2
     de2:	11 f4       	brne	.+4      	; 0xde8 <xTaskGenericNotify+0x78>
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	27 c0       	rjmp	.+78     	; 0xe36 <xTaskGenericNotify+0xc6>
					{
						pxTCB->ulNotifiedValue = ulValue;
     de8:	49 a3       	std	Y+33, r20	; 0x21
     dea:	5a a3       	std	Y+34, r21	; 0x22
     dec:	6b a3       	std	Y+35, r22	; 0x23
     dee:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     df0:	31 30       	cpi	r19, 0x01	; 1
     df2:	01 f5       	brne	.+64     	; 0xe34 <xTaskGenericNotify+0xc4>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     df4:	8e 01       	movw	r16, r28
     df6:	0e 5f       	subi	r16, 0xFE	; 254
     df8:	1f 4f       	sbci	r17, 0xFF	; 255
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     e00:	9e 89       	ldd	r25, Y+22	; 0x16
     e02:	80 91 59 02 	lds	r24, 0x0259
     e06:	89 17       	cp	r24, r25
     e08:	10 f4       	brcc	.+4      	; 0xe0e <xTaskGenericNotify+0x9e>
     e0a:	90 93 59 02 	sts	0x0259, r25
     e0e:	89 e0       	ldi	r24, 0x09	; 9
     e10:	98 9f       	mul	r25, r24
     e12:	c0 01       	movw	r24, r0
     e14:	11 24       	eor	r1, r1
     e16:	89 59       	subi	r24, 0x99	; 153
     e18:	9d 4f       	sbci	r25, 0xFD	; 253
     e1a:	b8 01       	movw	r22, r16
     e1c:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     e20:	e0 91 56 02 	lds	r30, 0x0256
     e24:	f0 91 57 02 	lds	r31, 0x0257
     e28:	9e 89       	ldd	r25, Y+22	; 0x16
     e2a:	86 89       	ldd	r24, Z+22	; 0x16
     e2c:	89 17       	cp	r24, r25
     e2e:	10 f4       	brcc	.+4      	; 0xe34 <xTaskGenericNotify+0xc4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     e30:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
     e34:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e36:	0f 90       	pop	r0
     e38:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     e3a:	df 91       	pop	r29
     e3c:	cf 91       	pop	r28
     e3e:	1f 91       	pop	r17
     e40:	0f 91       	pop	r16
     e42:	08 95       	ret

00000e44 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     e44:	ef 92       	push	r14
     e46:	ff 92       	push	r15
     e48:	0f 93       	push	r16
     e4a:	1f 93       	push	r17
     e4c:	cf 93       	push	r28
     e4e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     e56:	80 91 58 02 	lds	r24, 0x0258
     e5a:	81 50       	subi	r24, 0x01	; 1
     e5c:	80 93 58 02 	sts	0x0258, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e60:	80 91 58 02 	lds	r24, 0x0258
     e64:	88 23       	and	r24, r24
     e66:	09 f0       	breq	.+2      	; 0xe6a <xTaskResumeAll+0x26>
     e68:	6c c0       	rjmp	.+216    	; 0xf42 <xTaskResumeAll+0xfe>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     e6a:	80 91 61 02 	lds	r24, 0x0261
     e6e:	88 23       	and	r24, r24
     e70:	09 f4       	brne	.+2      	; 0xe74 <xTaskResumeAll+0x30>
     e72:	67 c0       	rjmp	.+206    	; 0xf42 <xTaskResumeAll+0xfe>
     e74:	c0 e0       	ldi	r28, 0x00	; 0
     e76:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     e78:	59 e0       	ldi	r21, 0x09	; 9
     e7a:	e5 2e       	mov	r14, r21

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     e7c:	ff 24       	eor	r15, r15
     e7e:	f3 94       	inc	r15
     e80:	29 c0       	rjmp	.+82     	; 0xed4 <xTaskResumeAll+0x90>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     e82:	e0 91 a6 02 	lds	r30, 0x02A6
     e86:	f0 91 a7 02 	lds	r31, 0x02A7
     e8a:	c6 81       	ldd	r28, Z+6	; 0x06
     e8c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     e8e:	ce 01       	movw	r24, r28
     e90:	0c 96       	adiw	r24, 0x0c	; 12
     e92:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     e96:	8e 01       	movw	r16, r28
     e98:	0e 5f       	subi	r16, 0xFE	; 254
     e9a:	1f 4f       	sbci	r17, 0xFF	; 255
     e9c:	c8 01       	movw	r24, r16
     e9e:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ea2:	9e 89       	ldd	r25, Y+22	; 0x16
     ea4:	80 91 59 02 	lds	r24, 0x0259
     ea8:	89 17       	cp	r24, r25
     eaa:	10 f4       	brcc	.+4      	; 0xeb0 <xTaskResumeAll+0x6c>
     eac:	90 93 59 02 	sts	0x0259, r25
     eb0:	9e 9d       	mul	r25, r14
     eb2:	c0 01       	movw	r24, r0
     eb4:	11 24       	eor	r1, r1
     eb6:	89 59       	subi	r24, 0x99	; 153
     eb8:	9d 4f       	sbci	r25, 0xFD	; 253
     eba:	b8 01       	movw	r22, r16
     ebc:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ec0:	e0 91 56 02 	lds	r30, 0x0256
     ec4:	f0 91 57 02 	lds	r31, 0x0257
     ec8:	9e 89       	ldd	r25, Y+22	; 0x16
     eca:	86 89       	ldd	r24, Z+22	; 0x16
     ecc:	98 17       	cp	r25, r24
     ece:	10 f0       	brcs	.+4      	; 0xed4 <xTaskResumeAll+0x90>
					{
						xYieldPending = pdTRUE;
     ed0:	f0 92 5a 02 	sts	0x025A, r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     ed4:	80 91 a1 02 	lds	r24, 0x02A1
     ed8:	88 23       	and	r24, r24
     eda:	99 f6       	brne	.-90     	; 0xe82 <xTaskResumeAll+0x3e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     edc:	cd 2b       	or	r28, r29
     ede:	d1 f0       	breq	.+52     	; 0xf14 <xTaskResumeAll+0xd0>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     ee0:	e0 91 9d 02 	lds	r30, 0x029D
     ee4:	f0 91 9e 02 	lds	r31, 0x029E
     ee8:	80 81       	ld	r24, Z
     eea:	88 23       	and	r24, r24
     eec:	19 f4       	brne	.+6      	; 0xef4 <xTaskResumeAll+0xb0>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     eee:	8f ef       	ldi	r24, 0xFF	; 255
     ef0:	9f ef       	ldi	r25, 0xFF	; 255
     ef2:	0c c0       	rjmp	.+24     	; 0xf0c <xTaskResumeAll+0xc8>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     ef4:	e0 91 9d 02 	lds	r30, 0x029D
     ef8:	f0 91 9e 02 	lds	r31, 0x029E
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     efc:	05 80       	ldd	r0, Z+5	; 0x05
     efe:	f6 81       	ldd	r31, Z+6	; 0x06
     f00:	e0 2d       	mov	r30, r0
     f02:	06 80       	ldd	r0, Z+6	; 0x06
     f04:	f7 81       	ldd	r31, Z+7	; 0x07
     f06:	e0 2d       	mov	r30, r0
     f08:	82 81       	ldd	r24, Z+2	; 0x02
     f0a:	93 81       	ldd	r25, Z+3	; 0x03
     f0c:	90 93 5e 02 	sts	0x025E, r25
     f10:	80 93 5d 02 	sts	0x025D, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     f14:	10 91 60 02 	lds	r17, 0x0260

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     f18:	11 23       	and	r17, r17
     f1a:	59 f0       	breq	.+22     	; 0xf32 <xTaskResumeAll+0xee>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     f1c:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     f1e:	0e 94 ef 05 	call	0xbde	; 0xbde <xTaskIncrementTick>
     f22:	88 23       	and	r24, r24
     f24:	11 f0       	breq	.+4      	; 0xf2a <xTaskResumeAll+0xe6>
							{
								xYieldPending = pdTRUE;
     f26:	00 93 5a 02 	sts	0x025A, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     f2a:	11 50       	subi	r17, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     f2c:	c1 f7       	brne	.-16     	; 0xf1e <xTaskResumeAll+0xda>

						uxPendedTicks = 0;
     f2e:	10 92 60 02 	sts	0x0260, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     f32:	80 91 5a 02 	lds	r24, 0x025A
     f36:	88 23       	and	r24, r24
     f38:	21 f0       	breq	.+8      	; 0xf42 <xTaskResumeAll+0xfe>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     f3a:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	01 c0       	rjmp	.+2      	; 0xf44 <xTaskResumeAll+0x100>
     f42:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     f44:	0f 90       	pop	r0
     f46:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	1f 91       	pop	r17
     f4e:	0f 91       	pop	r16
     f50:	ff 90       	pop	r15
     f52:	ef 90       	pop	r14
     f54:	08 95       	ret

00000f56 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     f60:	00 91 5b 02 	lds	r16, 0x025B
     f64:	10 91 5c 02 	lds	r17, 0x025C
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     f68:	80 91 56 02 	lds	r24, 0x0256
     f6c:	90 91 57 02 	lds	r25, 0x0257
     f70:	02 96       	adiw	r24, 0x02	; 2
     f72:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     f76:	c0 0f       	add	r28, r16
     f78:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     f7a:	e0 91 56 02 	lds	r30, 0x0256
     f7e:	f0 91 57 02 	lds	r31, 0x0257
     f82:	d3 83       	std	Z+3, r29	; 0x03
     f84:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
     f86:	c0 17       	cp	r28, r16
     f88:	d1 07       	cpc	r29, r17
     f8a:	68 f4       	brcc	.+26     	; 0xfa6 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     f8c:	80 91 9f 02 	lds	r24, 0x029F
     f90:	90 91 a0 02 	lds	r25, 0x02A0
     f94:	60 91 56 02 	lds	r22, 0x0256
     f98:	70 91 57 02 	lds	r23, 0x0257
     f9c:	6e 5f       	subi	r22, 0xFE	; 254
     f9e:	7f 4f       	sbci	r23, 0xFF	; 255
     fa0:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vListInsert>
     fa4:	17 c0       	rjmp	.+46     	; 0xfd4 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     fa6:	80 91 9d 02 	lds	r24, 0x029D
     faa:	90 91 9e 02 	lds	r25, 0x029E
     fae:	60 91 56 02 	lds	r22, 0x0256
     fb2:	70 91 57 02 	lds	r23, 0x0257
     fb6:	6e 5f       	subi	r22, 0xFE	; 254
     fb8:	7f 4f       	sbci	r23, 0xFF	; 255
     fba:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     fbe:	80 91 5d 02 	lds	r24, 0x025D
     fc2:	90 91 5e 02 	lds	r25, 0x025E
     fc6:	c8 17       	cp	r28, r24
     fc8:	d9 07       	cpc	r29, r25
     fca:	20 f4       	brcc	.+8      	; 0xfd4 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
     fcc:	d0 93 5e 02 	sts	0x025E, r29
     fd0:	c0 93 5d 02 	sts	0x025D, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     fd4:	df 91       	pop	r29
     fd6:	cf 91       	pop	r28
     fd8:	1f 91       	pop	r17
     fda:	0f 91       	pop	r16
     fdc:	08 95       	ret

00000fde <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     fde:	6f 92       	push	r6
     fe0:	7f 92       	push	r7
     fe2:	8f 92       	push	r8
     fe4:	9f 92       	push	r9
     fe6:	af 92       	push	r10
     fe8:	bf 92       	push	r11
     fea:	cf 92       	push	r12
     fec:	df 92       	push	r13
     fee:	ef 92       	push	r14
     ff0:	ff 92       	push	r15
     ff2:	0f 93       	push	r16
     ff4:	1f 93       	push	r17
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	5b 01       	movw	r10, r22
     ffc:	6c 01       	movw	r12, r24
     ffe:	39 01       	movw	r6, r18
    1000:	4a 01       	movw	r8, r20
    1002:	e8 01       	movw	r28, r16
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1004:	0f b6       	in	r0, 0x3f	; 63
    1006:	f8 94       	cli
    1008:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    100a:	e0 91 56 02 	lds	r30, 0x0256
    100e:	f0 91 57 02 	lds	r31, 0x0257
    1012:	85 a1       	ldd	r24, Z+37	; 0x25
    1014:	82 30       	cpi	r24, 0x02	; 2
    1016:	19 f1       	breq	.+70     	; 0x105e <xTaskNotifyWait+0x80>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1018:	e0 91 56 02 	lds	r30, 0x0256
    101c:	f0 91 57 02 	lds	r31, 0x0257
    1020:	81 a1       	ldd	r24, Z+33	; 0x21
    1022:	92 a1       	ldd	r25, Z+34	; 0x22
    1024:	a3 a1       	ldd	r26, Z+35	; 0x23
    1026:	b4 a1       	ldd	r27, Z+36	; 0x24
    1028:	a0 94       	com	r10
    102a:	b0 94       	com	r11
    102c:	c0 94       	com	r12
    102e:	d0 94       	com	r13
    1030:	8a 21       	and	r24, r10
    1032:	9b 21       	and	r25, r11
    1034:	ac 21       	and	r26, r12
    1036:	bd 21       	and	r27, r13
    1038:	81 a3       	std	Z+33, r24	; 0x21
    103a:	92 a3       	std	Z+34, r25	; 0x22
    103c:	a3 a3       	std	Z+35, r26	; 0x23
    103e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1040:	e0 91 56 02 	lds	r30, 0x0256
    1044:	f0 91 57 02 	lds	r31, 0x0257
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    104c:	e1 14       	cp	r14, r1
    104e:	f1 04       	cpc	r15, r1
    1050:	31 f0       	breq	.+12     	; 0x105e <xTaskNotifyWait+0x80>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1052:	c7 01       	movw	r24, r14
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    105a:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    105e:	0f 90       	pop	r0
    1060:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1062:	0f b6       	in	r0, 0x3f	; 63
    1064:	f8 94       	cli
    1066:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1068:	20 97       	sbiw	r28, 0x00	; 0
    106a:	61 f0       	breq	.+24     	; 0x1084 <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    106c:	e0 91 56 02 	lds	r30, 0x0256
    1070:	f0 91 57 02 	lds	r31, 0x0257
    1074:	81 a1       	ldd	r24, Z+33	; 0x21
    1076:	92 a1       	ldd	r25, Z+34	; 0x22
    1078:	a3 a1       	ldd	r26, Z+35	; 0x23
    107a:	b4 a1       	ldd	r27, Z+36	; 0x24
    107c:	88 83       	st	Y, r24
    107e:	99 83       	std	Y+1, r25	; 0x01
    1080:	aa 83       	std	Y+2, r26	; 0x02
    1082:	bb 83       	std	Y+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    1084:	e0 91 56 02 	lds	r30, 0x0256
    1088:	f0 91 57 02 	lds	r31, 0x0257
    108c:	85 a1       	ldd	r24, Z+37	; 0x25
    108e:	81 30       	cpi	r24, 0x01	; 1
    1090:	11 f4       	brne	.+4      	; 0x1096 <xTaskNotifyWait+0xb8>
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	15 c0       	rjmp	.+42     	; 0x10c0 <xTaskNotifyWait+0xe2>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1096:	e0 91 56 02 	lds	r30, 0x0256
    109a:	f0 91 57 02 	lds	r31, 0x0257
    109e:	81 a1       	ldd	r24, Z+33	; 0x21
    10a0:	92 a1       	ldd	r25, Z+34	; 0x22
    10a2:	a3 a1       	ldd	r26, Z+35	; 0x23
    10a4:	b4 a1       	ldd	r27, Z+36	; 0x24
    10a6:	60 94       	com	r6
    10a8:	70 94       	com	r7
    10aa:	80 94       	com	r8
    10ac:	90 94       	com	r9
    10ae:	86 21       	and	r24, r6
    10b0:	97 21       	and	r25, r7
    10b2:	a8 21       	and	r26, r8
    10b4:	b9 21       	and	r27, r9
    10b6:	81 a3       	std	Z+33, r24	; 0x21
    10b8:	92 a3       	std	Z+34, r25	; 0x22
    10ba:	a3 a3       	std	Z+35, r26	; 0x23
    10bc:	b4 a3       	std	Z+36, r27	; 0x24
    10be:	81 e0       	ldi	r24, 0x01	; 1
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    10c0:	e0 91 56 02 	lds	r30, 0x0256
    10c4:	f0 91 57 02 	lds	r31, 0x0257
    10c8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	df 90       	pop	r13
    10dc:	cf 90       	pop	r12
    10de:	bf 90       	pop	r11
    10e0:	af 90       	pop	r10
    10e2:	9f 90       	pop	r9
    10e4:	8f 90       	pop	r8
    10e6:	7f 90       	pop	r7
    10e8:	6f 90       	pop	r6
    10ea:	08 95       	ret

000010ec <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    10ec:	1f 93       	push	r17
    10ee:	18 2f       	mov	r17, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    10f0:	0f b6       	in	r0, 0x3f	; 63
    10f2:	f8 94       	cli
    10f4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    10f6:	e0 91 56 02 	lds	r30, 0x0256
    10fa:	f0 91 57 02 	lds	r31, 0x0257
    10fe:	81 a1       	ldd	r24, Z+33	; 0x21
    1100:	92 a1       	ldd	r25, Z+34	; 0x22
    1102:	a3 a1       	ldd	r26, Z+35	; 0x23
    1104:	b4 a1       	ldd	r27, Z+36	; 0x24
    1106:	00 97       	sbiw	r24, 0x00	; 0
    1108:	a1 05       	cpc	r26, r1
    110a:	b1 05       	cpc	r27, r1
    110c:	79 f4       	brne	.+30     	; 0x112c <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    110e:	e0 91 56 02 	lds	r30, 0x0256
    1112:	f0 91 57 02 	lds	r31, 0x0257
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    111a:	61 15       	cp	r22, r1
    111c:	71 05       	cpc	r23, r1
    111e:	31 f0       	breq	.+12     	; 0x112c <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1120:	cb 01       	movw	r24, r22
    1122:	61 e0       	ldi	r22, 0x01	; 1
    1124:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1128:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1136:	e0 91 56 02 	lds	r30, 0x0256
    113a:	f0 91 57 02 	lds	r31, 0x0257
    113e:	21 a1       	ldd	r18, Z+33	; 0x21
    1140:	32 a1       	ldd	r19, Z+34	; 0x22
    1142:	43 a1       	ldd	r20, Z+35	; 0x23
    1144:	54 a1       	ldd	r21, Z+36	; 0x24

			if( ulReturn != 0UL )
    1146:	21 15       	cp	r18, r1
    1148:	31 05       	cpc	r19, r1
    114a:	41 05       	cpc	r20, r1
    114c:	51 05       	cpc	r21, r1
    114e:	d9 f0       	breq	.+54     	; 0x1186 <ulTaskNotifyTake+0x9a>
			{
				if( xClearCountOnExit != pdFALSE )
    1150:	11 23       	and	r17, r17
    1152:	49 f0       	breq	.+18     	; 0x1166 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1154:	e0 91 56 02 	lds	r30, 0x0256
    1158:	f0 91 57 02 	lds	r31, 0x0257
    115c:	11 a2       	std	Z+33, r1	; 0x21
    115e:	12 a2       	std	Z+34, r1	; 0x22
    1160:	13 a2       	std	Z+35, r1	; 0x23
    1162:	14 a2       	std	Z+36, r1	; 0x24
    1164:	10 c0       	rjmp	.+32     	; 0x1186 <ulTaskNotifyTake+0x9a>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    1166:	e0 91 56 02 	lds	r30, 0x0256
    116a:	f0 91 57 02 	lds	r31, 0x0257
    116e:	21 50       	subi	r18, 0x01	; 1
    1170:	30 40       	sbci	r19, 0x00	; 0
    1172:	40 40       	sbci	r20, 0x00	; 0
    1174:	50 40       	sbci	r21, 0x00	; 0
    1176:	21 a3       	std	Z+33, r18	; 0x21
    1178:	32 a3       	std	Z+34, r19	; 0x22
    117a:	43 a3       	std	Z+35, r20	; 0x23
    117c:	54 a3       	std	Z+36, r21	; 0x24
    117e:	2f 5f       	subi	r18, 0xFF	; 255
    1180:	3f 4f       	sbci	r19, 0xFF	; 255
    1182:	4f 4f       	sbci	r20, 0xFF	; 255
    1184:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1186:	e0 91 56 02 	lds	r30, 0x0256
    118a:	f0 91 57 02 	lds	r31, 0x0257
    118e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1190:	0f 90       	pop	r0
    1192:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1194:	b9 01       	movw	r22, r18
    1196:	ca 01       	movw	r24, r20
    1198:	1f 91       	pop	r17
    119a:	08 95       	ret

0000119c <vTaskPlaceOnUnorderedEventList>:
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	8a 01       	movw	r16, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    11a2:	e0 91 56 02 	lds	r30, 0x0256
    11a6:	f0 91 57 02 	lds	r31, 0x0257
    11aa:	70 68       	ori	r23, 0x80	; 128
    11ac:	75 87       	std	Z+13, r23	; 0x0d
    11ae:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    11b0:	60 91 56 02 	lds	r22, 0x0256
    11b4:	70 91 57 02 	lds	r23, 0x0257
    11b8:	64 5f       	subi	r22, 0xF4	; 244
    11ba:	7f 4f       	sbci	r23, 0xFF	; 255
    11bc:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    11c0:	c8 01       	movw	r24, r16
    11c2:	61 e0       	ldi	r22, 0x01	; 1
    11c4:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>
}
    11c8:	1f 91       	pop	r17
    11ca:	0f 91       	pop	r16
    11cc:	08 95       	ret

000011ce <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    11ce:	9c 01       	movw	r18, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    11d0:	00 97       	sbiw	r24, 0x00	; 0
    11d2:	69 f0       	breq	.+26     	; 0x11ee <vTaskDelay+0x20>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    11d4:	80 91 58 02 	lds	r24, 0x0258
    11d8:	8f 5f       	subi	r24, 0xFF	; 255
    11da:	80 93 58 02 	sts	0x0258, r24
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    11de:	c9 01       	movw	r24, r18
    11e0:	60 e0       	ldi	r22, 0x00	; 0
    11e2:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    11e6:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    11ea:	88 23       	and	r24, r24
    11ec:	11 f4       	brne	.+4      	; 0x11f2 <vTaskDelay+0x24>
		{
			portYIELD_WITHIN_API();
    11ee:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    11f2:	08 95       	ret

000011f4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    11f4:	fc 01       	movw	r30, r24
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    11f6:	80 91 58 02 	lds	r24, 0x0258
    11fa:	8f 5f       	subi	r24, 0xFF	; 255
    11fc:	80 93 58 02 	sts	0x0258, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1200:	40 91 5b 02 	lds	r20, 0x025B
    1204:	50 91 5c 02 	lds	r21, 0x025C

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1208:	20 81       	ld	r18, Z
    120a:	31 81       	ldd	r19, Z+1	; 0x01
    120c:	62 0f       	add	r22, r18
    120e:	73 1f       	adc	r23, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    1210:	42 17       	cp	r20, r18
    1212:	53 07       	cpc	r21, r19
    1214:	28 f4       	brcc	.+10     	; 0x1220 <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1216:	62 17       	cp	r22, r18
    1218:	73 07       	cpc	r23, r19
    121a:	28 f0       	brcs	.+10     	; 0x1226 <vTaskDelayUntil+0x32>
    121c:	80 e0       	ldi	r24, 0x00	; 0
    121e:	08 c0       	rjmp	.+16     	; 0x1230 <vTaskDelayUntil+0x3c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1220:	62 17       	cp	r22, r18
    1222:	73 07       	cpc	r23, r19
    1224:	20 f0       	brcs	.+8      	; 0x122e <vTaskDelayUntil+0x3a>
    1226:	80 e0       	ldi	r24, 0x00	; 0
    1228:	46 17       	cp	r20, r22
    122a:	57 07       	cpc	r21, r23
    122c:	08 f4       	brcc	.+2      	; 0x1230 <vTaskDelayUntil+0x3c>
    122e:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1230:	71 83       	std	Z+1, r23	; 0x01
    1232:	60 83       	st	Z, r22

			if( xShouldDelay != pdFALSE )
    1234:	88 23       	and	r24, r24
    1236:	31 f0       	breq	.+12     	; 0x1244 <vTaskDelayUntil+0x50>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1238:	cb 01       	movw	r24, r22
    123a:	84 1b       	sub	r24, r20
    123c:	95 0b       	sbc	r25, r21
    123e:	60 e0       	ldi	r22, 0x00	; 0
    1240:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1244:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1248:	88 23       	and	r24, r24
    124a:	11 f4       	brne	.+4      	; 0x1250 <vTaskDelayUntil+0x5c>
		{
			portYIELD_WITHIN_API();
    124c:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    1250:	08 95       	ret

00001252 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1252:	0f 93       	push	r16
    1254:	1f 93       	push	r17
    1256:	8b 01       	movw	r16, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1258:	60 91 56 02 	lds	r22, 0x0256
    125c:	70 91 57 02 	lds	r23, 0x0257
    1260:	64 5f       	subi	r22, 0xF4	; 244
    1262:	7f 4f       	sbci	r23, 0xFF	; 255
    1264:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1268:	c8 01       	movw	r24, r16
    126a:	61 e0       	ldi	r22, 0x01	; 1
    126c:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvAddCurrentTaskToDelayedList>
}
    1270:	1f 91       	pop	r17
    1272:	0f 91       	pop	r16
    1274:	08 95       	ret

00001276 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1276:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1278:	10 92 62 02 	sts	0x0262, r1
	vPortEndScheduler();
    127c:	0e 94 2a 12 	call	0x2454	; 0x2454 <vPortEndScheduler>
}
    1280:	08 95       	ret

00001282 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	2c c0       	rjmp	.+88     	; 0x12e0 <prvIdleTask+0x5e>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1288:	80 91 58 02 	lds	r24, 0x0258
    128c:	8f 5f       	subi	r24, 0xFF	; 255
    128e:	80 93 58 02 	sts	0x0258, r24
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1292:	10 91 aa 02 	lds	r17, 0x02AA
			}
			( void ) xTaskResumeAll();
    1296:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    129a:	11 23       	and	r17, r17
    129c:	09 f1       	breq	.+66     	; 0x12e0 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    12a4:	e0 91 af 02 	lds	r30, 0x02AF
    12a8:	f0 91 b0 02 	lds	r31, 0x02B0
    12ac:	06 81       	ldd	r16, Z+6	; 0x06
    12ae:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    12b0:	c8 01       	movw	r24, r16
    12b2:	02 96       	adiw	r24, 0x02	; 2
    12b4:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
					--uxCurrentNumberOfTasks;
    12b8:	80 91 61 02 	lds	r24, 0x0261
    12bc:	81 50       	subi	r24, 0x01	; 1
    12be:	80 93 61 02 	sts	0x0261, r24
					--uxDeletedTasksWaitingCleanUp;
    12c2:	80 91 65 02 	lds	r24, 0x0265
    12c6:	81 50       	subi	r24, 0x01	; 1
    12c8:	80 93 65 02 	sts	0x0265, r24
				}
				taskEXIT_CRITICAL();
    12cc:	0f 90       	pop	r0
    12ce:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    12d0:	f8 01       	movw	r30, r16
    12d2:	87 89       	ldd	r24, Z+23	; 0x17
    12d4:	90 8d       	ldd	r25, Z+24	; 0x18
    12d6:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>
			vPortFree( pxTCB );
    12da:	c8 01       	movw	r24, r16
    12dc:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    12e0:	80 91 65 02 	lds	r24, 0x0265
    12e4:	88 23       	and	r24, r24
    12e6:	81 f6       	brne	.-96     	; 0x1288 <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    12e8:	80 91 67 02 	lds	r24, 0x0267
    12ec:	82 30       	cpi	r24, 0x02	; 2
    12ee:	10 f0       	brcs	.+4      	; 0x12f4 <prvIdleTask+0x72>
			{
				taskYIELD();
    12f0:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    12f4:	0e 94 95 00 	call	0x12a	; 0x12a <vApplicationIdleHook>
    12f8:	f3 cf       	rjmp	.-26     	; 0x12e0 <prvIdleTask+0x5e>

000012fa <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    12fa:	0f 93       	push	r16
    12fc:	1f 93       	push	r17
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	f8 94       	cli
    1306:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1308:	00 97       	sbiw	r24, 0x00	; 0
    130a:	29 f4       	brne	.+10     	; 0x1316 <vTaskDelete+0x1c>
    130c:	c0 91 56 02 	lds	r28, 0x0256
    1310:	d0 91 57 02 	lds	r29, 0x0257
    1314:	01 c0       	rjmp	.+2      	; 0x1318 <vTaskDelete+0x1e>
    1316:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1318:	8e 01       	movw	r16, r28
    131a:	0e 5f       	subi	r16, 0xFE	; 254
    131c:	1f 4f       	sbci	r17, 0xFF	; 255
    131e:	c8 01       	movw	r24, r16
    1320:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1324:	8c 89       	ldd	r24, Y+20	; 0x14
    1326:	9d 89       	ldd	r25, Y+21	; 0x15
    1328:	89 2b       	or	r24, r25
    132a:	21 f0       	breq	.+8      	; 0x1334 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    132c:	ce 01       	movw	r24, r28
    132e:	0c 96       	adiw	r24, 0x0c	; 12
    1330:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1334:	80 91 66 02 	lds	r24, 0x0266
    1338:	8f 5f       	subi	r24, 0xFF	; 255
    133a:	80 93 66 02 	sts	0x0266, r24

			if( pxTCB == pxCurrentTCB )
    133e:	80 91 56 02 	lds	r24, 0x0256
    1342:	90 91 57 02 	lds	r25, 0x0257
    1346:	c8 17       	cp	r28, r24
    1348:	d9 07       	cpc	r29, r25
    134a:	59 f4       	brne	.+22     	; 0x1362 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    134c:	8a ea       	ldi	r24, 0xAA	; 170
    134e:	92 e0       	ldi	r25, 0x02	; 2
    1350:	b8 01       	movw	r22, r16
    1352:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1356:	80 91 65 02 	lds	r24, 0x0265
    135a:	8f 5f       	subi	r24, 0xFF	; 255
    135c:	80 93 65 02 	sts	0x0265, r24
    1360:	26 c0       	rjmp	.+76     	; 0x13ae <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1362:	80 91 61 02 	lds	r24, 0x0261
    1366:	81 50       	subi	r24, 0x01	; 1
    1368:	80 93 61 02 	sts	0x0261, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    136c:	8f 89       	ldd	r24, Y+23	; 0x17
    136e:	98 8d       	ldd	r25, Y+24	; 0x18
    1370:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>
			vPortFree( pxTCB );
    1374:	ce 01       	movw	r24, r28
    1376:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    137a:	e0 91 9d 02 	lds	r30, 0x029D
    137e:	f0 91 9e 02 	lds	r31, 0x029E
    1382:	80 81       	ld	r24, Z
    1384:	88 23       	and	r24, r24
    1386:	19 f4       	brne	.+6      	; 0x138e <vTaskDelete+0x94>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1388:	8f ef       	ldi	r24, 0xFF	; 255
    138a:	9f ef       	ldi	r25, 0xFF	; 255
    138c:	0c c0       	rjmp	.+24     	; 0x13a6 <vTaskDelete+0xac>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    138e:	e0 91 9d 02 	lds	r30, 0x029D
    1392:	f0 91 9e 02 	lds	r31, 0x029E
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1396:	05 80       	ldd	r0, Z+5	; 0x05
    1398:	f6 81       	ldd	r31, Z+6	; 0x06
    139a:	e0 2d       	mov	r30, r0
    139c:	06 80       	ldd	r0, Z+6	; 0x06
    139e:	f7 81       	ldd	r31, Z+7	; 0x07
    13a0:	e0 2d       	mov	r30, r0
    13a2:	82 81       	ldd	r24, Z+2	; 0x02
    13a4:	93 81       	ldd	r25, Z+3	; 0x03
    13a6:	90 93 5e 02 	sts	0x025E, r25
    13aa:	80 93 5d 02 	sts	0x025D, r24
				prvResetNextTaskUnblockTime();
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    13ae:	0f 90       	pop	r0
    13b0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    13b2:	80 91 62 02 	lds	r24, 0x0262
    13b6:	88 23       	and	r24, r24
    13b8:	49 f0       	breq	.+18     	; 0x13cc <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    13ba:	80 91 56 02 	lds	r24, 0x0256
    13be:	90 91 57 02 	lds	r25, 0x0257
    13c2:	c8 17       	cp	r28, r24
    13c4:	d9 07       	cpc	r29, r25
    13c6:	11 f4       	brne	.+4      	; 0x13cc <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    13c8:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	08 95       	ret

000013d6 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    13d6:	4f 92       	push	r4
    13d8:	5f 92       	push	r5
    13da:	6f 92       	push	r6
    13dc:	7f 92       	push	r7
    13de:	8f 92       	push	r8
    13e0:	9f 92       	push	r9
    13e2:	af 92       	push	r10
    13e4:	bf 92       	push	r11
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    13f6:	2c 01       	movw	r4, r24
    13f8:	16 2f       	mov	r17, r22
    13fa:	97 2e       	mov	r9, r23
    13fc:	6a 01       	movw	r12, r20
    13fe:	39 01       	movw	r6, r18
    1400:	57 01       	movw	r10, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1402:	ca 01       	movw	r24, r20
    1404:	0e 94 76 11 	call	0x22ec	; 0x22ec <pvPortMalloc>
    1408:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    140a:	00 97       	sbiw	r24, 0x00	; 0
    140c:	99 f0       	breq	.+38     	; 0x1434 <xTaskCreate+0x5e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    140e:	86 e2       	ldi	r24, 0x26	; 38
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	0e 94 76 11 	call	0x22ec	; 0x22ec <pvPortMalloc>
    1416:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1418:	00 97       	sbiw	r24, 0x00	; 0
    141a:	49 f0       	breq	.+18     	; 0x142e <xTaskCreate+0x58>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    141c:	f8 8e       	std	Y+24, r15	; 0x18
    141e:	ef 8a       	std	Y+23, r14	; 0x17
    1420:	81 2f       	mov	r24, r17
    1422:	99 2d       	mov	r25, r9
    1424:	9c 01       	movw	r18, r24
    1426:	f9 01       	movw	r30, r18
    1428:	de 01       	movw	r26, r28
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	05 c0       	rjmp	.+10     	; 0x1438 <xTaskCreate+0x62>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    142e:	c7 01       	movw	r24, r14
    1430:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>
    1434:	8f ef       	ldi	r24, 0xFF	; 255
    1436:	b7 c0       	rjmp	.+366    	; 0x15a6 <xTaskCreate+0x1d0>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1438:	80 81       	ld	r24, Z
    143a:	59 96       	adiw	r26, 0x19	; 25
    143c:	8c 93       	st	X, r24
    143e:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1440:	80 81       	ld	r24, Z
    1442:	88 23       	and	r24, r24
    1444:	29 f0       	breq	.+10     	; 0x1450 <xTaskCreate+0x7a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1446:	9f 5f       	subi	r25, 0xFF	; 255
    1448:	31 96       	adiw	r30, 0x01	; 1
    144a:	11 96       	adiw	r26, 0x01	; 1
    144c:	98 30       	cpi	r25, 0x08	; 8
    144e:	a1 f7       	brne	.-24     	; 0x1438 <xTaskCreate+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1450:	18 a2       	std	Y+32, r1	; 0x20
    1452:	04 30       	cpi	r16, 0x04	; 4
    1454:	08 f0       	brcs	.+2      	; 0x1458 <xTaskCreate+0x82>
    1456:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1458:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    145a:	72 e0       	ldi	r23, 0x02	; 2
    145c:	87 2e       	mov	r8, r23
    145e:	91 2c       	mov	r9, r1
    1460:	8c 0e       	add	r8, r28
    1462:	9d 1e       	adc	r9, r29
    1464:	c4 01       	movw	r24, r8
    1466:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    146a:	ce 01       	movw	r24, r28
    146c:	0c 96       	adiw	r24, 0x0c	; 12
    146e:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1472:	d9 87       	std	Y+9, r29	; 0x09
    1474:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1476:	84 e0       	ldi	r24, 0x04	; 4
    1478:	90 e0       	ldi	r25, 0x00	; 0
    147a:	80 1b       	sub	r24, r16
    147c:	91 09       	sbc	r25, r1
    147e:	9d 87       	std	Y+13, r25	; 0x0d
    1480:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1482:	db 8b       	std	Y+19, r29	; 0x13
    1484:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1486:	19 a2       	std	Y+33, r1	; 0x21
    1488:	1a a2       	std	Y+34, r1	; 0x22
    148a:	1b a2       	std	Y+35, r1	; 0x23
    148c:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    148e:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1490:	08 94       	sec
    1492:	c1 08       	sbc	r12, r1
    1494:	d1 08       	sbc	r13, r1
    1496:	c7 01       	movw	r24, r14
    1498:	8c 0d       	add	r24, r12
    149a:	9d 1d       	adc	r25, r13
    149c:	b2 01       	movw	r22, r4
    149e:	a3 01       	movw	r20, r6
    14a0:	0e 94 a8 11 	call	0x2350	; 0x2350 <pxPortInitialiseStack>
    14a4:	99 83       	std	Y+1, r25	; 0x01
    14a6:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    14a8:	a1 14       	cp	r10, r1
    14aa:	b1 04       	cpc	r11, r1
    14ac:	19 f0       	breq	.+6      	; 0x14b4 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    14ae:	f5 01       	movw	r30, r10
    14b0:	d1 83       	std	Z+1, r29	; 0x01
    14b2:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	f8 94       	cli
    14b8:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    14ba:	80 91 61 02 	lds	r24, 0x0261
    14be:	8f 5f       	subi	r24, 0xFF	; 255
    14c0:	80 93 61 02 	sts	0x0261, r24
		if( pxCurrentTCB == NULL )
    14c4:	80 91 56 02 	lds	r24, 0x0256
    14c8:	90 91 57 02 	lds	r25, 0x0257
    14cc:	89 2b       	or	r24, r25
    14ce:	a9 f5       	brne	.+106    	; 0x153a <xTaskCreate+0x164>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    14d0:	d0 93 57 02 	sts	0x0257, r29
    14d4:	c0 93 56 02 	sts	0x0256, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    14d8:	80 91 61 02 	lds	r24, 0x0261
    14dc:	81 30       	cpi	r24, 0x01	; 1
    14de:	e9 f5       	brne	.+122    	; 0x155a <xTaskCreate+0x184>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    14e0:	87 e6       	ldi	r24, 0x67	; 103
    14e2:	92 e0       	ldi	r25, 0x02	; 2
    14e4:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
    14e8:	80 e7       	ldi	r24, 0x70	; 112
    14ea:	92 e0       	ldi	r25, 0x02	; 2
    14ec:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
    14f0:	89 e7       	ldi	r24, 0x79	; 121
    14f2:	92 e0       	ldi	r25, 0x02	; 2
    14f4:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
    14f8:	82 e8       	ldi	r24, 0x82	; 130
    14fa:	92 e0       	ldi	r25, 0x02	; 2
    14fc:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1500:	6b e8       	ldi	r22, 0x8B	; 139
    1502:	e6 2e       	mov	r14, r22
    1504:	62 e0       	ldi	r22, 0x02	; 2
    1506:	f6 2e       	mov	r15, r22
    1508:	c7 01       	movw	r24, r14
    150a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    150e:	04 e9       	ldi	r16, 0x94	; 148
    1510:	12 e0       	ldi	r17, 0x02	; 2
    1512:	c8 01       	movw	r24, r16
    1514:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1518:	81 ea       	ldi	r24, 0xA1	; 161
    151a:	92 e0       	ldi	r25, 0x02	; 2
    151c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1520:	8a ea       	ldi	r24, 0xAA	; 170
    1522:	92 e0       	ldi	r25, 0x02	; 2
    1524:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1528:	f0 92 9e 02 	sts	0x029E, r15
    152c:	e0 92 9d 02 	sts	0x029D, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1530:	10 93 a0 02 	sts	0x02A0, r17
    1534:	00 93 9f 02 	sts	0x029F, r16
    1538:	10 c0       	rjmp	.+32     	; 0x155a <xTaskCreate+0x184>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    153a:	80 91 62 02 	lds	r24, 0x0262
    153e:	88 23       	and	r24, r24
    1540:	61 f4       	brne	.+24     	; 0x155a <xTaskCreate+0x184>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1542:	e0 91 56 02 	lds	r30, 0x0256
    1546:	f0 91 57 02 	lds	r31, 0x0257
    154a:	96 89       	ldd	r25, Z+22	; 0x16
    154c:	8e 89       	ldd	r24, Y+22	; 0x16
    154e:	89 17       	cp	r24, r25
    1550:	20 f0       	brcs	.+8      	; 0x155a <xTaskCreate+0x184>
				{
					pxCurrentTCB = pxNewTCB;
    1552:	d0 93 57 02 	sts	0x0257, r29
    1556:	c0 93 56 02 	sts	0x0256, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    155a:	80 91 66 02 	lds	r24, 0x0266
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	80 93 66 02 	sts	0x0266, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1564:	9e 89       	ldd	r25, Y+22	; 0x16
    1566:	80 91 59 02 	lds	r24, 0x0259
    156a:	89 17       	cp	r24, r25
    156c:	10 f4       	brcc	.+4      	; 0x1572 <xTaskCreate+0x19c>
    156e:	90 93 59 02 	sts	0x0259, r25
    1572:	89 e0       	ldi	r24, 0x09	; 9
    1574:	98 9f       	mul	r25, r24
    1576:	c0 01       	movw	r24, r0
    1578:	11 24       	eor	r1, r1
    157a:	89 59       	subi	r24, 0x99	; 153
    157c:	9d 4f       	sbci	r25, 0xFD	; 253
    157e:	b4 01       	movw	r22, r8
    1580:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1588:	80 91 62 02 	lds	r24, 0x0262
    158c:	88 23       	and	r24, r24
    158e:	51 f0       	breq	.+20     	; 0x15a4 <xTaskCreate+0x1ce>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1590:	e0 91 56 02 	lds	r30, 0x0256
    1594:	f0 91 57 02 	lds	r31, 0x0257
    1598:	96 89       	ldd	r25, Z+22	; 0x16
    159a:	8e 89       	ldd	r24, Y+22	; 0x16
    159c:	98 17       	cp	r25, r24
    159e:	10 f4       	brcc	.+4      	; 0x15a4 <xTaskCreate+0x1ce>
		{
			taskYIELD_IF_USING_PREEMPTION();
    15a0:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    15a4:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	1f 91       	pop	r17
    15ac:	0f 91       	pop	r16
    15ae:	ff 90       	pop	r15
    15b0:	ef 90       	pop	r14
    15b2:	df 90       	pop	r13
    15b4:	cf 90       	pop	r12
    15b6:	bf 90       	pop	r11
    15b8:	af 90       	pop	r10
    15ba:	9f 90       	pop	r9
    15bc:	8f 90       	pop	r8
    15be:	7f 90       	pop	r7
    15c0:	6f 90       	pop	r6
    15c2:	5f 90       	pop	r5
    15c4:	4f 90       	pop	r4
    15c6:	08 95       	ret

000015c8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    15c8:	ef 92       	push	r14
    15ca:	ff 92       	push	r15
    15cc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    15ce:	81 e4       	ldi	r24, 0x41	; 65
    15d0:	99 e0       	ldi	r25, 0x09	; 9
    15d2:	65 e1       	ldi	r22, 0x15	; 21
    15d4:	72 e0       	ldi	r23, 0x02	; 2
    15d6:	45 e5       	ldi	r20, 0x55	; 85
    15d8:	50 e0       	ldi	r21, 0x00	; 0
    15da:	20 e0       	ldi	r18, 0x00	; 0
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	00 e0       	ldi	r16, 0x00	; 0
    15e0:	e3 e6       	ldi	r30, 0x63	; 99
    15e2:	ee 2e       	mov	r14, r30
    15e4:	e2 e0       	ldi	r30, 0x02	; 2
    15e6:	fe 2e       	mov	r15, r30
    15e8:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    15ec:	81 30       	cpi	r24, 0x01	; 1
    15ee:	81 f4       	brne	.+32     	; 0x1610 <vTaskStartScheduler+0x48>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    15f0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    15f2:	8f ef       	ldi	r24, 0xFF	; 255
    15f4:	9f ef       	ldi	r25, 0xFF	; 255
    15f6:	90 93 5e 02 	sts	0x025E, r25
    15fa:	80 93 5d 02 	sts	0x025D, r24
		xSchedulerRunning = pdTRUE;
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	80 93 62 02 	sts	0x0262, r24
		xTickCount = ( TickType_t ) 0U;
    1604:	10 92 5c 02 	sts	0x025C, r1
    1608:	10 92 5b 02 	sts	0x025B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    160c:	0e 94 f0 11 	call	0x23e0	; 0x23e0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1610:	0f 91       	pop	r16
    1612:	ff 90       	pop	r15
    1614:	ef 90       	pop	r14
    1616:	08 95       	ret

00001618 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    161e:	fc 01       	movw	r30, r24
    1620:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1622:	0f 90       	pop	r0
    1624:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1626:	08 95       	ret

00001628 <uxQueueSpacesAvailable>:
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    1628:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    162a:	0f b6       	in	r0, 0x3f	; 63
    162c:	f8 94       	cli
    162e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1630:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1632:	0f 90       	pop	r0
    1634:	0f be       	out	0x3f, r0	; 63
    1636:	83 8d       	ldd	r24, Z+27	; 0x1b

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1638:	89 1b       	sub	r24, r25
    163a:	08 95       	ret

0000163c <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    163c:	fc 01       	movw	r30, r24
    163e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1640:	08 95       	ret

00001642 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1642:	fc 01       	movw	r30, r24
    1644:	82 8d       	ldd	r24, Z+26	; 0x1a
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	88 23       	and	r24, r24
    164a:	09 f4       	brne	.+2      	; 0x164e <xQueueIsQueueEmptyFromISR+0xc>
    164c:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    164e:	89 2f       	mov	r24, r25
    1650:	08 95       	ret

00001652 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1652:	fc 01       	movw	r30, r24
    1654:	92 8d       	ldd	r25, Z+26	; 0x1a
    1656:	20 e0       	ldi	r18, 0x00	; 0
    1658:	83 8d       	ldd	r24, Z+27	; 0x1b
    165a:	98 17       	cp	r25, r24
    165c:	09 f4       	brne	.+2      	; 0x1660 <xQueueIsQueueFullFromISR+0xe>
    165e:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1660:	82 2f       	mov	r24, r18
    1662:	08 95       	ret

00001664 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1664:	0f 93       	push	r16
    1666:	1f 93       	push	r17
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	ec 01       	movw	r28, r24
    166e:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1670:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1672:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1674:	44 23       	and	r20, r20
    1676:	c1 f1       	breq	.+112    	; 0x16e8 <prvCopyDataToQueue+0x84>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1678:	00 23       	and	r16, r16
    167a:	b1 f4       	brne	.+44     	; 0x16a8 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    167c:	8c 81       	ldd	r24, Y+4	; 0x04
    167e:	9d 81       	ldd	r25, Y+5	; 0x05
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	0e 94 f5 15 	call	0x2bea	; 0x2bea <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1686:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1688:	2c 81       	ldd	r18, Y+4	; 0x04
    168a:	3d 81       	ldd	r19, Y+5	; 0x05
    168c:	28 0f       	add	r18, r24
    168e:	31 1d       	adc	r19, r1
    1690:	3d 83       	std	Y+5, r19	; 0x05
    1692:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	9b 81       	ldd	r25, Y+3	; 0x03
    1698:	28 17       	cp	r18, r24
    169a:	39 07       	cpc	r19, r25
    169c:	28 f1       	brcs	.+74     	; 0x16e8 <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    169e:	88 81       	ld	r24, Y
    16a0:	99 81       	ldd	r25, Y+1	; 0x01
    16a2:	9d 83       	std	Y+5, r25	; 0x05
    16a4:	8c 83       	std	Y+4, r24	; 0x04
    16a6:	20 c0       	rjmp	.+64     	; 0x16e8 <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16a8:	8e 81       	ldd	r24, Y+6	; 0x06
    16aa:	9f 81       	ldd	r25, Y+7	; 0x07
    16ac:	50 e0       	ldi	r21, 0x00	; 0
    16ae:	0e 94 f5 15 	call	0x2bea	; 0x2bea <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    16b2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16b4:	90 e0       	ldi	r25, 0x00	; 0
    16b6:	44 27       	eor	r20, r20
    16b8:	55 27       	eor	r21, r21
    16ba:	48 1b       	sub	r20, r24
    16bc:	59 0b       	sbc	r21, r25
    16be:	8e 81       	ldd	r24, Y+6	; 0x06
    16c0:	9f 81       	ldd	r25, Y+7	; 0x07
    16c2:	84 0f       	add	r24, r20
    16c4:	95 1f       	adc	r25, r21
    16c6:	9f 83       	std	Y+7, r25	; 0x07
    16c8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16ca:	28 81       	ld	r18, Y
    16cc:	39 81       	ldd	r19, Y+1	; 0x01
    16ce:	82 17       	cp	r24, r18
    16d0:	93 07       	cpc	r25, r19
    16d2:	30 f4       	brcc	.+12     	; 0x16e0 <prvCopyDataToQueue+0x7c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16d4:	8a 81       	ldd	r24, Y+2	; 0x02
    16d6:	9b 81       	ldd	r25, Y+3	; 0x03
    16d8:	84 0f       	add	r24, r20
    16da:	95 1f       	adc	r25, r21
    16dc:	9f 83       	std	Y+7, r25	; 0x07
    16de:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    16e0:	02 30       	cpi	r16, 0x02	; 2
    16e2:	11 f4       	brne	.+4      	; 0x16e8 <prvCopyDataToQueue+0x84>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16e4:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    16e6:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    16e8:	1f 5f       	subi	r17, 0xFF	; 255
    16ea:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    16ec:	80 e0       	ldi	r24, 0x00	; 0
    16ee:	df 91       	pop	r29
    16f0:	cf 91       	pop	r28
    16f2:	1f 91       	pop	r17
    16f4:	0f 91       	pop	r16
    16f6:	08 95       	ret

000016f8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    16f8:	fc 01       	movw	r30, r24
    16fa:	56 2f       	mov	r21, r22
    16fc:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    16fe:	24 8d       	ldd	r18, Z+28	; 0x1c
    1700:	22 23       	and	r18, r18
    1702:	b9 f0       	breq	.+46     	; 0x1732 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1704:	86 81       	ldd	r24, Z+6	; 0x06
    1706:	97 81       	ldd	r25, Z+7	; 0x07
    1708:	82 0f       	add	r24, r18
    170a:	91 1d       	adc	r25, r1
    170c:	97 83       	std	Z+7, r25	; 0x07
    170e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1710:	22 81       	ldd	r18, Z+2	; 0x02
    1712:	33 81       	ldd	r19, Z+3	; 0x03
    1714:	82 17       	cp	r24, r18
    1716:	93 07       	cpc	r25, r19
    1718:	20 f0       	brcs	.+8      	; 0x1722 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    171a:	80 81       	ld	r24, Z
    171c:	91 81       	ldd	r25, Z+1	; 0x01
    171e:	97 83       	std	Z+7, r25	; 0x07
    1720:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1722:	44 8d       	ldd	r20, Z+28	; 0x1c
    1724:	66 81       	ldd	r22, Z+6	; 0x06
    1726:	77 81       	ldd	r23, Z+7	; 0x07
    1728:	85 2f       	mov	r24, r21
    172a:	9a 2f       	mov	r25, r26
    172c:	50 e0       	ldi	r21, 0x00	; 0
    172e:	0e 94 f5 15 	call	0x2bea	; 0x2bea <memcpy>
    1732:	08 95       	ret

00001734 <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1734:	0f 93       	push	r16
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    173c:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    173e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1740:	88 23       	and	r24, r24
    1742:	41 f0       	breq	.+16     	; 0x1754 <xQueuePeekFromISR+0x20>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1744:	0e 81       	ldd	r16, Y+6	; 0x06
    1746:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1748:	ce 01       	movw	r24, r28
    174a:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    174e:	1f 83       	std	Y+7, r17	; 0x07
    1750:	0e 83       	std	Y+6, r16	; 0x06
    1752:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	1f 91       	pop	r17
    175a:	0f 91       	pop	r16
    175c:	08 95       	ret

0000175e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    175e:	0f 93       	push	r16
    1760:	1f 93       	push	r17
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
    1766:	fb 01       	movw	r30, r22
    1768:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    176a:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    176c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    176e:	88 23       	and	r24, r24
    1770:	61 f1       	breq	.+88     	; 0x17ca <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1772:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1774:	2e 81       	ldd	r18, Y+6	; 0x06
    1776:	3f 81       	ldd	r19, Y+7	; 0x07
    1778:	28 0f       	add	r18, r24
    177a:	31 1d       	adc	r19, r1
    177c:	3f 83       	std	Y+7, r19	; 0x07
    177e:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1780:	8a 81       	ldd	r24, Y+2	; 0x02
    1782:	9b 81       	ldd	r25, Y+3	; 0x03
    1784:	28 17       	cp	r18, r24
    1786:	39 07       	cpc	r19, r25
    1788:	20 f0       	brcs	.+8      	; 0x1792 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    178a:	88 81       	ld	r24, Y
    178c:	99 81       	ldd	r25, Y+1	; 0x01
    178e:	9f 83       	std	Y+7, r25	; 0x07
    1790:	8e 83       	std	Y+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1792:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1798:	4c 8d       	ldd	r20, Y+28	; 0x1c
    179a:	6e 81       	ldd	r22, Y+6	; 0x06
    179c:	7f 81       	ldd	r23, Y+7	; 0x07
    179e:	cf 01       	movw	r24, r30
    17a0:	50 e0       	ldi	r21, 0x00	; 0
    17a2:	0e 94 f5 15 	call	0x2bea	; 0x2bea <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    17a6:	f8 01       	movw	r30, r16
    17a8:	80 81       	ld	r24, Z
    17aa:	88 23       	and	r24, r24
    17ac:	69 f4       	brne	.+26     	; 0x17c8 <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17ae:	88 85       	ldd	r24, Y+8	; 0x08
    17b0:	88 23       	and	r24, r24
    17b2:	51 f0       	breq	.+20     	; 0x17c8 <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17b4:	ce 01       	movw	r24, r28
    17b6:	08 96       	adiw	r24, 0x08	; 8
    17b8:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <xCoRoutineRemoveFromEventList>
    17bc:	88 23       	and	r24, r24
    17be:	21 f0       	breq	.+8      	; 0x17c8 <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    17c0:	81 e0       	ldi	r24, 0x01	; 1
    17c2:	f8 01       	movw	r30, r16
    17c4:	80 83       	st	Z, r24
    17c6:	01 c0       	rjmp	.+2      	; 0x17ca <xQueueCRReceiveFromISR+0x6c>
    17c8:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	08 95       	ret

000017d4 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    17d4:	1f 93       	push	r17
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    17da:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    17dc:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17de:	9a 8d       	ldd	r25, Y+26	; 0x1a
    17e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    17e2:	98 17       	cp	r25, r24
    17e4:	88 f4       	brcc	.+34     	; 0x1808 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    17e6:	ce 01       	movw	r24, r28
    17e8:	40 e0       	ldi	r20, 0x00	; 0
    17ea:	0e 94 32 0b 	call	0x1664	; 0x1664 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    17ee:	11 23       	and	r17, r17
    17f0:	59 f4       	brne	.+22     	; 0x1808 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17f2:	89 89       	ldd	r24, Y+17	; 0x11
    17f4:	88 23       	and	r24, r24
    17f6:	41 f0       	breq	.+16     	; 0x1808 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17f8:	ce 01       	movw	r24, r28
    17fa:	41 96       	adiw	r24, 0x11	; 17
    17fc:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <xCoRoutineRemoveFromEventList>
    1800:	48 2f       	mov	r20, r24
    1802:	81 11       	cpse	r24, r1
    1804:	41 e0       	ldi	r20, 0x01	; 1
    1806:	14 2f       	mov	r17, r20
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1808:	81 2f       	mov	r24, r17
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	1f 91       	pop	r17
    1810:	08 95       	ret

00001812 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
    1816:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1818:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    181a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    181c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    181e:	88 23       	and	r24, r24
    1820:	71 f4       	brne	.+28     	; 0x183e <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1822:	41 15       	cp	r20, r1
    1824:	51 05       	cpc	r21, r1
    1826:	41 f0       	breq	.+16     	; 0x1838 <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1828:	61 96       	adiw	r28, 0x11	; 17
    182a:	ca 01       	movw	r24, r20
    182c:	be 01       	movw	r22, r28
    182e:	0e 94 af 10 	call	0x215e	; 0x215e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1832:	78 94       	sei
    1834:	8c ef       	ldi	r24, 0xFC	; 252
    1836:	2f c0       	rjmp	.+94     	; 0x1896 <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1838:	78 94       	sei
    183a:	80 e0       	ldi	r24, 0x00	; 0
    183c:	2c c0       	rjmp	.+88     	; 0x1896 <xQueueCRReceive+0x84>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    183e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1840:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1842:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1844:	88 23       	and	r24, r24
    1846:	31 f1       	breq	.+76     	; 0x1894 <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1848:	8c 8d       	ldd	r24, Y+28	; 0x1c
    184a:	2e 81       	ldd	r18, Y+6	; 0x06
    184c:	3f 81       	ldd	r19, Y+7	; 0x07
    184e:	28 0f       	add	r18, r24
    1850:	31 1d       	adc	r19, r1
    1852:	3f 83       	std	Y+7, r19	; 0x07
    1854:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1856:	8a 81       	ldd	r24, Y+2	; 0x02
    1858:	9b 81       	ldd	r25, Y+3	; 0x03
    185a:	28 17       	cp	r18, r24
    185c:	39 07       	cpc	r19, r25
    185e:	20 f0       	brcs	.+8      	; 0x1868 <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1860:	88 81       	ld	r24, Y
    1862:	99 81       	ldd	r25, Y+1	; 0x01
    1864:	9f 83       	std	Y+7, r25	; 0x07
    1866:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1868:	8a 8d       	ldd	r24, Y+26	; 0x1a
    186a:	81 50       	subi	r24, 0x01	; 1
    186c:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    186e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1870:	6e 81       	ldd	r22, Y+6	; 0x06
    1872:	7f 81       	ldd	r23, Y+7	; 0x07
    1874:	cf 01       	movw	r24, r30
    1876:	50 e0       	ldi	r21, 0x00	; 0
    1878:	0e 94 f5 15 	call	0x2bea	; 0x2bea <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    187c:	88 85       	ldd	r24, Y+8	; 0x08
    187e:	88 23       	and	r24, r24
    1880:	41 f0       	breq	.+16     	; 0x1892 <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1882:	ce 01       	movw	r24, r28
    1884:	08 96       	adiw	r24, 0x08	; 8
    1886:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <xCoRoutineRemoveFromEventList>
    188a:	88 23       	and	r24, r24
    188c:	11 f0       	breq	.+4      	; 0x1892 <xQueueCRReceive+0x80>
    188e:	8b ef       	ldi	r24, 0xFB	; 251
    1890:	01 c0       	rjmp	.+2      	; 0x1894 <xQueueCRReceive+0x82>
    1892:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1894:	78 94       	sei

		return xReturn;
	}
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	08 95       	ret

0000189c <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18a0:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    18a2:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18a4:	0f b6       	in	r0, 0x3f	; 63
    18a6:	f8 94       	cli
    18a8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    18aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18ac:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18b2:	89 17       	cp	r24, r25
    18b4:	71 f4       	brne	.+28     	; 0x18d2 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    18b6:	41 15       	cp	r20, r1
    18b8:	51 05       	cpc	r21, r1
    18ba:	41 f0       	breq	.+16     	; 0x18cc <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    18bc:	28 96       	adiw	r28, 0x08	; 8
    18be:	ca 01       	movw	r24, r20
    18c0:	be 01       	movw	r22, r28
    18c2:	0e 94 af 10 	call	0x215e	; 0x215e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    18c6:	78 94       	sei
    18c8:	8c ef       	ldi	r24, 0xFC	; 252
    18ca:	1b c0       	rjmp	.+54     	; 0x1902 <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    18cc:	78 94       	sei
    18ce:	80 e0       	ldi	r24, 0x00	; 0
    18d0:	18 c0       	rjmp	.+48     	; 0x1902 <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    18d2:	78 94       	sei

		portDISABLE_INTERRUPTS();
    18d4:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18d8:	89 17       	cp	r24, r25
    18da:	10 f0       	brcs	.+4      	; 0x18e0 <xQueueCRSend+0x44>
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	10 c0       	rjmp	.+32     	; 0x1900 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    18e0:	ce 01       	movw	r24, r28
    18e2:	40 e0       	ldi	r20, 0x00	; 0
    18e4:	0e 94 32 0b 	call	0x1664	; 0x1664 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18e8:	89 89       	ldd	r24, Y+17	; 0x11
    18ea:	88 23       	and	r24, r24
    18ec:	41 f0       	breq	.+16     	; 0x18fe <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ee:	ce 01       	movw	r24, r28
    18f0:	41 96       	adiw	r24, 0x11	; 17
    18f2:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <xCoRoutineRemoveFromEventList>
    18f6:	88 23       	and	r24, r24
    18f8:	11 f0       	breq	.+4      	; 0x18fe <xQueueCRSend+0x62>
    18fa:	8b ef       	ldi	r24, 0xFB	; 251
    18fc:	01 c0       	rjmp	.+2      	; 0x1900 <xQueueCRSend+0x64>
    18fe:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1900:	78 94       	sei

		return xReturn;
	}
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1908:	0e 94 66 11 	call	0x22cc	; 0x22cc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    190c:	08 95       	ret

0000190e <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    190e:	ef 92       	push	r14
    1910:	ff 92       	push	r15
    1912:	0f 93       	push	r16
    1914:	1f 93       	push	r17
    1916:	cf 93       	push	r28
    1918:	df 93       	push	r29
    191a:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    191c:	ec 01       	movw	r28, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    191e:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1920:	11 23       	and	r17, r17
    1922:	11 f4       	brne	.+4      	; 0x1928 <xQueueReceiveFromISR+0x1a>
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	1a c0       	rjmp	.+52     	; 0x195c <xQueueReceiveFromISR+0x4e>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1928:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    192a:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    192e:	11 50       	subi	r17, 0x01	; 1
    1930:	1a 8f       	std	Y+26, r17	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1932:	0f 3f       	cpi	r16, 0xFF	; 255
    1934:	81 f4       	brne	.+32     	; 0x1956 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1936:	88 85       	ldd	r24, Y+8	; 0x08
    1938:	88 23       	and	r24, r24
    193a:	79 f0       	breq	.+30     	; 0x195a <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    193c:	ce 01       	movw	r24, r28
    193e:	08 96       	adiw	r24, 0x08	; 8
    1940:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1944:	88 23       	and	r24, r24
    1946:	49 f0       	breq	.+18     	; 0x195a <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1948:	e1 14       	cp	r14, r1
    194a:	f1 04       	cpc	r15, r1
    194c:	31 f0       	breq	.+12     	; 0x195a <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    194e:	81 e0       	ldi	r24, 0x01	; 1
    1950:	f7 01       	movw	r30, r14
    1952:	80 83       	st	Z, r24
    1954:	03 c0       	rjmp	.+6      	; 0x195c <xQueueReceiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1956:	0f 5f       	subi	r16, 0xFF	; 255
    1958:	0d 8f       	std	Y+29, r16	; 0x1d
    195a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    195c:	df 91       	pop	r29
    195e:	cf 91       	pop	r28
    1960:	1f 91       	pop	r17
    1962:	0f 91       	pop	r16
    1964:	ff 90       	pop	r15
    1966:	ef 90       	pop	r14
    1968:	08 95       	ret

0000196a <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    196a:	cf 93       	push	r28
    196c:	df 93       	push	r29
    196e:	eb 01       	movw	r28, r22
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1970:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1972:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1974:	83 8d       	ldd	r24, Z+27	; 0x1b
    1976:	98 17       	cp	r25, r24
    1978:	10 f0       	brcs	.+4      	; 0x197e <xQueueGiveFromISR+0x14>
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	16 c0       	rjmp	.+44     	; 0x19aa <xQueueGiveFromISR+0x40>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    197e:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1980:	9f 5f       	subi	r25, 0xFF	; 255
    1982:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1984:	8f 3f       	cpi	r24, 0xFF	; 255
    1986:	71 f4       	brne	.+28     	; 0x19a4 <xQueueGiveFromISR+0x3a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1988:	81 89       	ldd	r24, Z+17	; 0x11
    198a:	88 23       	and	r24, r24
    198c:	69 f0       	breq	.+26     	; 0x19a8 <xQueueGiveFromISR+0x3e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    198e:	cf 01       	movw	r24, r30
    1990:	41 96       	adiw	r24, 0x11	; 17
    1992:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1996:	88 23       	and	r24, r24
    1998:	39 f0       	breq	.+14     	; 0x19a8 <xQueueGiveFromISR+0x3e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    199a:	20 97       	sbiw	r28, 0x00	; 0
    199c:	29 f0       	breq	.+10     	; 0x19a8 <xQueueGiveFromISR+0x3e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	88 83       	st	Y, r24
    19a2:	03 c0       	rjmp	.+6      	; 0x19aa <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    19a4:	8f 5f       	subi	r24, 0xFF	; 255
    19a6:	86 8f       	std	Z+30, r24	; 0x1e
    19a8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	08 95       	ret

000019b0 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19b0:	ef 92       	push	r14
    19b2:	ff 92       	push	r15
    19b4:	1f 93       	push	r17
    19b6:	cf 93       	push	r28
    19b8:	df 93       	push	r29
    19ba:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    19bc:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19be:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19c0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19c2:	98 17       	cp	r25, r24
    19c4:	20 f0       	brcs	.+8      	; 0x19ce <xQueueGenericSendFromISR+0x1e>
    19c6:	22 30       	cpi	r18, 0x02	; 2
    19c8:	11 f0       	breq	.+4      	; 0x19ce <xQueueGenericSendFromISR+0x1e>
    19ca:	80 e0       	ldi	r24, 0x00	; 0
    19cc:	1a c0       	rjmp	.+52     	; 0x1a02 <xQueueGenericSendFromISR+0x52>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    19ce:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19d0:	ce 01       	movw	r24, r28
    19d2:	42 2f       	mov	r20, r18
    19d4:	0e 94 32 0b 	call	0x1664	; 0x1664 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    19d8:	1f 3f       	cpi	r17, 0xFF	; 255
    19da:	81 f4       	brne	.+32     	; 0x19fc <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19dc:	89 89       	ldd	r24, Y+17	; 0x11
    19de:	88 23       	and	r24, r24
    19e0:	79 f0       	breq	.+30     	; 0x1a00 <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19e2:	ce 01       	movw	r24, r28
    19e4:	41 96       	adiw	r24, 0x11	; 17
    19e6:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    19ea:	88 23       	and	r24, r24
    19ec:	49 f0       	breq	.+18     	; 0x1a00 <xQueueGenericSendFromISR+0x50>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    19ee:	e1 14       	cp	r14, r1
    19f0:	f1 04       	cpc	r15, r1
    19f2:	31 f0       	breq	.+12     	; 0x1a00 <xQueueGenericSendFromISR+0x50>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    19f4:	81 e0       	ldi	r24, 0x01	; 1
    19f6:	f7 01       	movw	r30, r14
    19f8:	80 83       	st	Z, r24
    19fa:	03 c0       	rjmp	.+6      	; 0x1a02 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    19fc:	1f 5f       	subi	r17, 0xFF	; 255
    19fe:	1e 8f       	std	Y+30, r17	; 0x1e
    1a00:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a02:	df 91       	pop	r29
    1a04:	cf 91       	pop	r28
    1a06:	1f 91       	pop	r17
    1a08:	ff 90       	pop	r15
    1a0a:	ef 90       	pop	r14
    1a0c:	08 95       	ret

00001a0e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1a0e:	ef 92       	push	r14
    1a10:	ff 92       	push	r15
    1a12:	1f 93       	push	r17
    1a14:	cf 93       	push	r28
    1a16:	df 93       	push	r29
    1a18:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1a1a:	0f b6       	in	r0, 0x3f	; 63
    1a1c:	f8 94       	cli
    1a1e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1a20:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a22:	91 e1       	ldi	r25, 0x11	; 17
    1a24:	e9 2e       	mov	r14, r25
    1a26:	f1 2c       	mov	r15, r1
    1a28:	ec 0e       	add	r14, r28
    1a2a:	fd 1e       	adc	r15, r29
    1a2c:	0b c0       	rjmp	.+22     	; 0x1a44 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a2e:	89 89       	ldd	r24, Y+17	; 0x11
    1a30:	88 23       	and	r24, r24
    1a32:	51 f0       	breq	.+20     	; 0x1a48 <prvUnlockQueue+0x3a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a34:	c7 01       	movw	r24, r14
    1a36:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1a3a:	88 23       	and	r24, r24
    1a3c:	11 f0       	breq	.+4      	; 0x1a42 <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1a3e:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1a42:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1a44:	11 16       	cp	r1, r17
    1a46:	9c f3       	brlt	.-26     	; 0x1a2e <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1a48:	8f ef       	ldi	r24, 0xFF	; 255
    1a4a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1a56:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a58:	88 e0       	ldi	r24, 0x08	; 8
    1a5a:	e8 2e       	mov	r14, r24
    1a5c:	f1 2c       	mov	r15, r1
    1a5e:	ec 0e       	add	r14, r28
    1a60:	fd 1e       	adc	r15, r29
    1a62:	0b c0       	rjmp	.+22     	; 0x1a7a <prvUnlockQueue+0x6c>
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a64:	88 85       	ldd	r24, Y+8	; 0x08
    1a66:	88 23       	and	r24, r24
    1a68:	51 f0       	breq	.+20     	; 0x1a7e <prvUnlockQueue+0x70>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a6a:	c7 01       	movw	r24, r14
    1a6c:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1a70:	88 23       	and	r24, r24
    1a72:	11 f0       	breq	.+4      	; 0x1a78 <prvUnlockQueue+0x6a>
				{
					vTaskMissedYield();
    1a74:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1a78:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1a7a:	11 16       	cp	r1, r17
    1a7c:	9c f3       	brlt	.-26     	; 0x1a64 <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1a7e:	8f ef       	ldi	r24, 0xFF	; 255
    1a80:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
}
    1a86:	df 91       	pop	r29
    1a88:	cf 91       	pop	r28
    1a8a:	1f 91       	pop	r17
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	08 95       	ret

00001a92 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a92:	6f 92       	push	r6
    1a94:	7f 92       	push	r7
    1a96:	8f 92       	push	r8
    1a98:	9f 92       	push	r9
    1a9a:	af 92       	push	r10
    1a9c:	bf 92       	push	r11
    1a9e:	cf 92       	push	r12
    1aa0:	df 92       	push	r13
    1aa2:	ef 92       	push	r14
    1aa4:	ff 92       	push	r15
    1aa6:	0f 93       	push	r16
    1aa8:	1f 93       	push	r17
    1aaa:	df 93       	push	r29
    1aac:	cf 93       	push	r28
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <xQueueGenericReceive+0x1e>
    1ab0:	0f 92       	push	r0
    1ab2:	0f 92       	push	r0
    1ab4:	cd b7       	in	r28, 0x3d	; 61
    1ab6:	de b7       	in	r29, 0x3e	; 62
    1ab8:	4b 01       	movw	r8, r22
    1aba:	5d 83       	std	Y+5, r21	; 0x05
    1abc:	4c 83       	std	Y+4, r20	; 0x04
    1abe:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1ac0:	8c 01       	movw	r16, r24
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ac2:	41 e1       	ldi	r20, 0x11	; 17
    1ac4:	a4 2e       	mov	r10, r20
    1ac6:	b1 2c       	mov	r11, r1
    1ac8:	a8 0e       	add	r10, r24
    1aca:	b9 1e       	adc	r11, r25
    1acc:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ace:	6e 01       	movw	r12, r28
    1ad0:	08 94       	sec
    1ad2:	c1 1c       	adc	r12, r1
    1ad4:	d1 1c       	adc	r13, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ad6:	34 e0       	ldi	r19, 0x04	; 4
    1ad8:	63 2e       	mov	r6, r19
    1ada:	71 2c       	mov	r7, r1
    1adc:	6c 0e       	add	r6, r28
    1ade:	7d 1e       	adc	r7, r29
    1ae0:	01 c0       	rjmp	.+2      	; 0x1ae4 <xQueueGenericReceive+0x52>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ae2:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ae4:	0f b6       	in	r0, 0x3f	; 63
    1ae6:	f8 94       	cli
    1ae8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1aea:	f8 01       	movw	r30, r16
    1aec:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aee:	ff 20       	and	r15, r15
    1af0:	11 f1       	breq	.+68     	; 0x1b36 <xQueueGenericReceive+0xa4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1af2:	c6 80       	ldd	r12, Z+6	; 0x06
    1af4:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1af6:	c8 01       	movw	r24, r16
    1af8:	b4 01       	movw	r22, r8
    1afa:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1afe:	ee 20       	and	r14, r14
    1b00:	49 f4       	brne	.+18     	; 0x1b14 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1b02:	fa 94       	dec	r15
    1b04:	f8 01       	movw	r30, r16
    1b06:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b08:	80 85       	ldd	r24, Z+8	; 0x08
    1b0a:	88 23       	and	r24, r24
    1b0c:	81 f0       	breq	.+32     	; 0x1b2e <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b0e:	c8 01       	movw	r24, r16
    1b10:	08 96       	adiw	r24, 0x08	; 8
    1b12:	07 c0       	rjmp	.+14     	; 0x1b22 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b14:	f8 01       	movw	r30, r16
    1b16:	d7 82       	std	Z+7, r13	; 0x07
    1b18:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b1a:	81 89       	ldd	r24, Z+17	; 0x11
    1b1c:	88 23       	and	r24, r24
    1b1e:	39 f0       	breq	.+14     	; 0x1b2e <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b20:	c5 01       	movw	r24, r10
    1b22:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1b26:	88 23       	and	r24, r24
    1b28:	11 f0       	breq	.+4      	; 0x1b2e <xQueueGenericReceive+0x9c>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b2a:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b2e:	0f 90       	pop	r0
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	81 e0       	ldi	r24, 0x01	; 1
    1b34:	54 c0       	rjmp	.+168    	; 0x1bde <xQueueGenericReceive+0x14c>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b36:	8c 81       	ldd	r24, Y+4	; 0x04
    1b38:	9d 81       	ldd	r25, Y+5	; 0x05
    1b3a:	89 2b       	or	r24, r25
    1b3c:	21 f4       	brne	.+8      	; 0x1b46 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b3e:	0f 90       	pop	r0
    1b40:	0f be       	out	0x3f, r0	; 63
    1b42:	80 e0       	ldi	r24, 0x00	; 0
    1b44:	4c c0       	rjmp	.+152    	; 0x1bde <xQueueGenericReceive+0x14c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1b46:	22 23       	and	r18, r18
    1b48:	19 f4       	brne	.+6      	; 0x1b50 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b4a:	c6 01       	movw	r24, r12
    1b4c:	0e 94 3f 04 	call	0x87e	; 0x87e <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b50:	0f 90       	pop	r0
    1b52:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b54:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b58:	0f b6       	in	r0, 0x3f	; 63
    1b5a:	f8 94       	cli
    1b5c:	0f 92       	push	r0
    1b5e:	f8 01       	movw	r30, r16
    1b60:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b62:	8f 3f       	cpi	r24, 0xFF	; 255
    1b64:	09 f4       	brne	.+2      	; 0x1b68 <xQueueGenericReceive+0xd6>
    1b66:	15 8e       	std	Z+29, r1	; 0x1d
    1b68:	f8 01       	movw	r30, r16
    1b6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b6c:	8f 3f       	cpi	r24, 0xFF	; 255
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <xQueueGenericReceive+0xe0>
    1b70:	16 8e       	std	Z+30, r1	; 0x1e
    1b72:	0f 90       	pop	r0
    1b74:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b76:	c6 01       	movw	r24, r12
    1b78:	b3 01       	movw	r22, r6
    1b7a:	0e 94 4a 04 	call	0x894	; 0x894 <xTaskCheckForTimeOut>
    1b7e:	88 23       	and	r24, r24
    1b80:	f9 f4       	brne	.+62     	; 0x1bc0 <xQueueGenericReceive+0x12e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b88:	f8 01       	movw	r30, r16
    1b8a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b8c:	0f 90       	pop	r0
    1b8e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b90:	88 23       	and	r24, r24
    1b92:	81 f4       	brne	.+32     	; 0x1bb4 <xQueueGenericReceive+0x122>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b94:	6c 81       	ldd	r22, Y+4	; 0x04
    1b96:	7d 81       	ldd	r23, Y+5	; 0x05
    1b98:	c5 01       	movw	r24, r10
    1b9a:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b9e:	c8 01       	movw	r24, r16
    1ba0:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ba4:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
    1ba8:	88 23       	and	r24, r24
    1baa:	09 f0       	breq	.+2      	; 0x1bae <xQueueGenericReceive+0x11c>
    1bac:	9a cf       	rjmp	.-204    	; 0x1ae2 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    1bae:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    1bb2:	97 cf       	rjmp	.-210    	; 0x1ae2 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bba:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
    1bbe:	91 cf       	rjmp	.-222    	; 0x1ae2 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1bc0:	c8 01       	movw	r24, r16
    1bc2:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bc6:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1bca:	0f b6       	in	r0, 0x3f	; 63
    1bcc:	f8 94       	cli
    1bce:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1bd4:	0f 90       	pop	r0
    1bd6:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bd8:	88 23       	and	r24, r24
    1bda:	09 f0       	breq	.+2      	; 0x1bde <xQueueGenericReceive+0x14c>
    1bdc:	82 cf       	rjmp	.-252    	; 0x1ae2 <xQueueGenericReceive+0x50>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1bde:	0f 90       	pop	r0
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
    1be8:	cf 91       	pop	r28
    1bea:	df 91       	pop	r29
    1bec:	1f 91       	pop	r17
    1bee:	0f 91       	pop	r16
    1bf0:	ff 90       	pop	r15
    1bf2:	ef 90       	pop	r14
    1bf4:	df 90       	pop	r13
    1bf6:	cf 90       	pop	r12
    1bf8:	bf 90       	pop	r11
    1bfa:	af 90       	pop	r10
    1bfc:	9f 90       	pop	r9
    1bfe:	8f 90       	pop	r8
    1c00:	7f 90       	pop	r7
    1c02:	6f 90       	pop	r6
    1c04:	08 95       	ret

00001c06 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1c06:	6f 92       	push	r6
    1c08:	7f 92       	push	r7
    1c0a:	9f 92       	push	r9
    1c0c:	af 92       	push	r10
    1c0e:	bf 92       	push	r11
    1c10:	cf 92       	push	r12
    1c12:	df 92       	push	r13
    1c14:	ef 92       	push	r14
    1c16:	ff 92       	push	r15
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	df 93       	push	r29
    1c1e:	cf 93       	push	r28
    1c20:	00 d0       	rcall	.+0      	; 0x1c22 <xQueueGenericSend+0x1c>
    1c22:	0f 92       	push	r0
    1c24:	0f 92       	push	r0
    1c26:	cd b7       	in	r28, 0x3d	; 61
    1c28:	de b7       	in	r29, 0x3e	; 62
    1c2a:	6b 01       	movw	r12, r22
    1c2c:	5d 83       	std	Y+5, r21	; 0x05
    1c2e:	4c 83       	std	Y+4, r20	; 0x04
    1c30:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1c32:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c34:	68 e0       	ldi	r22, 0x08	; 8
    1c36:	e6 2e       	mov	r14, r22
    1c38:	f1 2c       	mov	r15, r1
    1c3a:	e8 0e       	add	r14, r24
    1c3c:	f9 1e       	adc	r15, r25
    1c3e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c40:	5e 01       	movw	r10, r28
    1c42:	08 94       	sec
    1c44:	a1 1c       	adc	r10, r1
    1c46:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c48:	54 e0       	ldi	r21, 0x04	; 4
    1c4a:	65 2e       	mov	r6, r21
    1c4c:	71 2c       	mov	r7, r1
    1c4e:	6c 0e       	add	r6, r28
    1c50:	7d 1e       	adc	r7, r29
    1c52:	01 c0       	rjmp	.+2      	; 0x1c56 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c54:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c56:	0f b6       	in	r0, 0x3f	; 63
    1c58:	f8 94       	cli
    1c5a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c5c:	f8 01       	movw	r30, r16
    1c5e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c60:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c62:	98 17       	cp	r25, r24
    1c64:	18 f0       	brcs	.+6      	; 0x1c6c <xQueueGenericSend+0x66>
    1c66:	f2 e0       	ldi	r31, 0x02	; 2
    1c68:	9f 16       	cp	r9, r31
    1c6a:	c9 f4       	brne	.+50     	; 0x1c9e <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c6c:	c8 01       	movw	r24, r16
    1c6e:	b6 01       	movw	r22, r12
    1c70:	49 2d       	mov	r20, r9
    1c72:	0e 94 32 0b 	call	0x1664	; 0x1664 <prvCopyDataToQueue>
    1c76:	98 2f       	mov	r25, r24
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c78:	f8 01       	movw	r30, r16
    1c7a:	81 89       	ldd	r24, Z+17	; 0x11
    1c7c:	88 23       	and	r24, r24
    1c7e:	39 f0       	breq	.+14     	; 0x1c8e <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c80:	c8 01       	movw	r24, r16
    1c82:	41 96       	adiw	r24, 0x11	; 17
    1c84:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1c88:	88 23       	and	r24, r24
    1c8a:	29 f0       	breq	.+10     	; 0x1c96 <xQueueGenericSend+0x90>
    1c8c:	02 c0       	rjmp	.+4      	; 0x1c92 <xQueueGenericSend+0x8c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1c8e:	99 23       	and	r25, r25
    1c90:	11 f0       	breq	.+4      	; 0x1c96 <xQueueGenericSend+0x90>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1c92:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	4c c0       	rjmp	.+152    	; 0x1d36 <xQueueGenericSend+0x130>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1ca0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ca2:	89 2b       	or	r24, r25
    1ca4:	19 f4       	brne	.+6      	; 0x1cac <xQueueGenericSend+0xa6>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ca6:	0f 90       	pop	r0
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	44 c0       	rjmp	.+136    	; 0x1d34 <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1cac:	22 23       	and	r18, r18
    1cae:	19 f4       	brne	.+6      	; 0x1cb6 <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1cb0:	c5 01       	movw	r24, r10
    1cb2:	0e 94 3f 04 	call	0x87e	; 0x87e <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1cb6:	0f 90       	pop	r0
    1cb8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1cba:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	0f 92       	push	r0
    1cc4:	f8 01       	movw	r30, r16
    1cc6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cca:	09 f4       	brne	.+2      	; 0x1cce <xQueueGenericSend+0xc8>
    1ccc:	15 8e       	std	Z+29, r1	; 0x1d
    1cce:	f8 01       	movw	r30, r16
    1cd0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd4:	09 f4       	brne	.+2      	; 0x1cd8 <xQueueGenericSend+0xd2>
    1cd6:	16 8e       	std	Z+30, r1	; 0x1e
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cdc:	c5 01       	movw	r24, r10
    1cde:	b3 01       	movw	r22, r6
    1ce0:	0e 94 4a 04 	call	0x894	; 0x894 <xTaskCheckForTimeOut>
    1ce4:	88 23       	and	r24, r24
    1ce6:	09 f5       	brne	.+66     	; 0x1d2a <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	f8 94       	cli
    1cec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cee:	f8 01       	movw	r30, r16
    1cf0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1cf6:	f8 01       	movw	r30, r16
    1cf8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cfa:	98 17       	cp	r25, r24
    1cfc:	81 f4       	brne	.+32     	; 0x1d1e <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1cfe:	6c 81       	ldd	r22, Y+4	; 0x04
    1d00:	7d 81       	ldd	r23, Y+5	; 0x05
    1d02:	c7 01       	movw	r24, r14
    1d04:	0e 94 29 09 	call	0x1252	; 0x1252 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d08:	c8 01       	movw	r24, r16
    1d0a:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d0e:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
    1d12:	88 23       	and	r24, r24
    1d14:	09 f0       	breq	.+2      	; 0x1d18 <xQueueGenericSend+0x112>
    1d16:	9e cf       	rjmp	.-196    	; 0x1c54 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1d18:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    1d1c:	9b cf       	rjmp	.-202    	; 0x1c54 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d1e:	c8 01       	movw	r24, r16
    1d20:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d24:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
    1d28:	95 cf       	rjmp	.-214    	; 0x1c54 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d2a:	c8 01       	movw	r24, r16
    1d2c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d30:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
    1d34:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	0f 90       	pop	r0
    1d3e:	0f 90       	pop	r0
    1d40:	cf 91       	pop	r28
    1d42:	df 91       	pop	r29
    1d44:	1f 91       	pop	r17
    1d46:	0f 91       	pop	r16
    1d48:	ff 90       	pop	r15
    1d4a:	ef 90       	pop	r14
    1d4c:	df 90       	pop	r13
    1d4e:	cf 90       	pop	r12
    1d50:	bf 90       	pop	r11
    1d52:	af 90       	pop	r10
    1d54:	9f 90       	pop	r9
    1d56:	7f 90       	pop	r7
    1d58:	6f 90       	pop	r6
    1d5a:	08 95       	ret

00001d5c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d60:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1d68:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1d6a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1d6c:	e2 9f       	mul	r30, r18
    1d6e:	c0 01       	movw	r24, r0
    1d70:	11 24       	eor	r1, r1
    1d72:	48 81       	ld	r20, Y
    1d74:	59 81       	ldd	r21, Y+1	; 0x01
    1d76:	84 0f       	add	r24, r20
    1d78:	95 1f       	adc	r25, r21
    1d7a:	9b 83       	std	Y+3, r25	; 0x03
    1d7c:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1d7e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1d80:	5d 83       	std	Y+5, r21	; 0x05
    1d82:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1d84:	30 e0       	ldi	r19, 0x00	; 0
    1d86:	21 50       	subi	r18, 0x01	; 1
    1d88:	30 40       	sbci	r19, 0x00	; 0
    1d8a:	f0 e0       	ldi	r31, 0x00	; 0
    1d8c:	2e 9f       	mul	r18, r30
    1d8e:	c0 01       	movw	r24, r0
    1d90:	2f 9f       	mul	r18, r31
    1d92:	90 0d       	add	r25, r0
    1d94:	3e 9f       	mul	r19, r30
    1d96:	90 0d       	add	r25, r0
    1d98:	11 24       	eor	r1, r1
    1d9a:	48 0f       	add	r20, r24
    1d9c:	59 1f       	adc	r21, r25
    1d9e:	5f 83       	std	Y+7, r21	; 0x07
    1da0:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1da2:	8f ef       	ldi	r24, 0xFF	; 255
    1da4:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1da6:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1da8:	66 23       	and	r22, r22
    1daa:	61 f4       	brne	.+24     	; 0x1dc4 <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dac:	88 85       	ldd	r24, Y+8	; 0x08
    1dae:	88 23       	and	r24, r24
    1db0:	89 f0       	breq	.+34     	; 0x1dd4 <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1db2:	ce 01       	movw	r24, r28
    1db4:	08 96       	adiw	r24, 0x08	; 8
    1db6:	0e 94 af 05 	call	0xb5e	; 0xb5e <xTaskRemoveFromEventList>
    1dba:	88 23       	and	r24, r24
    1dbc:	59 f0       	breq	.+22     	; 0x1dd4 <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1dbe:	0e 94 8b 12 	call	0x2516	; 0x2516 <vPortYield>
    1dc2:	08 c0       	rjmp	.+16     	; 0x1dd4 <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1dc4:	ce 01       	movw	r24, r28
    1dc6:	08 96       	adiw	r24, 0x08	; 8
    1dc8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1dcc:	ce 01       	movw	r24, r28
    1dce:	41 96       	adiw	r24, 0x11	; 17
    1dd0:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1dd4:	0f 90       	pop	r0
    1dd6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	08 95       	ret

00001de0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1de0:	0f 93       	push	r16
    1de2:	1f 93       	push	r17
    1de4:	cf 93       	push	r28
    1de6:	df 93       	push	r29
    1de8:	08 2f       	mov	r16, r24
    1dea:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1dec:	66 23       	and	r22, r22
    1dee:	19 f4       	brne	.+6      	; 0x1df6 <xQueueGenericCreate+0x16>
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	90 e0       	ldi	r25, 0x00	; 0
    1df4:	03 c0       	rjmp	.+6      	; 0x1dfc <xQueueGenericCreate+0x1c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1df6:	68 9f       	mul	r22, r24
    1df8:	c0 01       	movw	r24, r0
    1dfa:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1dfc:	4f 96       	adiw	r24, 0x1f	; 31
    1dfe:	0e 94 76 11 	call	0x22ec	; 0x22ec <pvPortMalloc>
    1e02:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	71 f0       	breq	.+28     	; 0x1e24 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1e08:	11 23       	and	r17, r17
    1e0a:	19 f4       	brne	.+6      	; 0x1e12 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1e0c:	99 83       	std	Y+1, r25	; 0x01
    1e0e:	88 83       	st	Y, r24
    1e10:	03 c0       	rjmp	.+6      	; 0x1e18 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1e12:	4f 96       	adiw	r24, 0x1f	; 31
    1e14:	99 83       	std	Y+1, r25	; 0x01
    1e16:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1e18:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1e1a:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1e1c:	ce 01       	movw	r24, r28
    1e1e:	61 e0       	ldi	r22, 0x01	; 1
    1e20:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1e24:	ce 01       	movw	r24, r28
    1e26:	df 91       	pop	r29
    1e28:	cf 91       	pop	r28
    1e2a:	1f 91       	pop	r17
    1e2c:	0f 91       	pop	r16
    1e2e:	08 95       	ret

00001e30 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1e30:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e32:	9c 01       	movw	r18, r24
    1e34:	2d 5f       	subi	r18, 0xFD	; 253
    1e36:	3f 4f       	sbci	r19, 0xFF	; 255
    1e38:	32 83       	std	Z+2, r19	; 0x02
    1e3a:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e3c:	8f ef       	ldi	r24, 0xFF	; 255
    1e3e:	9f ef       	ldi	r25, 0xFF	; 255
    1e40:	94 83       	std	Z+4, r25	; 0x04
    1e42:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e44:	36 83       	std	Z+6, r19	; 0x06
    1e46:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e48:	30 87       	std	Z+8, r19	; 0x08
    1e4a:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1e4c:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1e4e:	08 95       	ret

00001e50 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e50:	fc 01       	movw	r30, r24
    1e52:	11 86       	std	Z+9, r1	; 0x09
    1e54:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1e56:	08 95       	ret

00001e58 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1e58:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	a1 81       	ldd	r26, Z+1	; 0x01
    1e5e:	b2 81       	ldd	r27, Z+2	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1e60:	fb 01       	movw	r30, r22
    1e62:	b3 83       	std	Z+3, r27	; 0x03
    1e64:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1e66:	14 96       	adiw	r26, 0x04	; 4
    1e68:	8d 91       	ld	r24, X+
    1e6a:	9c 91       	ld	r25, X
    1e6c:	15 97       	sbiw	r26, 0x05	; 5
    1e6e:	95 83       	std	Z+5, r25	; 0x05
    1e70:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1e72:	14 96       	adiw	r26, 0x04	; 4
    1e74:	ed 91       	ld	r30, X+
    1e76:	fc 91       	ld	r31, X
    1e78:	15 97       	sbiw	r26, 0x05	; 5
    1e7a:	73 83       	std	Z+3, r23	; 0x03
    1e7c:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1e7e:	15 96       	adiw	r26, 0x05	; 5
    1e80:	7c 93       	st	X, r23
    1e82:	6e 93       	st	-X, r22
    1e84:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e86:	fb 01       	movw	r30, r22
    1e88:	51 87       	std	Z+9, r21	; 0x09
    1e8a:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    1e8c:	fa 01       	movw	r30, r20
    1e8e:	80 81       	ld	r24, Z
    1e90:	8f 5f       	subi	r24, 0xFF	; 255
    1e92:	80 83       	st	Z, r24
}
    1e94:	08 95       	ret

00001e96 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1e96:	cf 93       	push	r28
    1e98:	df 93       	push	r29
    1e9a:	9c 01       	movw	r18, r24
    1e9c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1e9e:	48 81       	ld	r20, Y
    1ea0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1ea2:	8f ef       	ldi	r24, 0xFF	; 255
    1ea4:	4f 3f       	cpi	r20, 0xFF	; 255
    1ea6:	58 07       	cpc	r21, r24
    1ea8:	21 f4       	brne	.+8      	; 0x1eb2 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1eaa:	f9 01       	movw	r30, r18
    1eac:	a7 81       	ldd	r26, Z+7	; 0x07
    1eae:	b0 85       	ldd	r27, Z+8	; 0x08
    1eb0:	0d c0       	rjmp	.+26     	; 0x1ecc <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eb2:	d9 01       	movw	r26, r18
    1eb4:	13 96       	adiw	r26, 0x03	; 3
    1eb6:	12 96       	adiw	r26, 0x02	; 2
    1eb8:	ed 91       	ld	r30, X+
    1eba:	fc 91       	ld	r31, X
    1ebc:	13 97       	sbiw	r26, 0x03	; 3
    1ebe:	80 81       	ld	r24, Z
    1ec0:	91 81       	ldd	r25, Z+1	; 0x01
    1ec2:	48 17       	cp	r20, r24
    1ec4:	59 07       	cpc	r21, r25
    1ec6:	10 f0       	brcs	.+4      	; 0x1ecc <vListInsert+0x36>
    1ec8:	df 01       	movw	r26, r30
    1eca:	f5 cf       	rjmp	.-22     	; 0x1eb6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1ecc:	12 96       	adiw	r26, 0x02	; 2
    1ece:	ed 91       	ld	r30, X+
    1ed0:	fc 91       	ld	r31, X
    1ed2:	13 97       	sbiw	r26, 0x03	; 3
    1ed4:	fb 83       	std	Y+3, r31	; 0x03
    1ed6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1ed8:	d5 83       	std	Z+5, r29	; 0x05
    1eda:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1edc:	bd 83       	std	Y+5, r27	; 0x05
    1ede:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1ee0:	13 96       	adiw	r26, 0x03	; 3
    1ee2:	dc 93       	st	X, r29
    1ee4:	ce 93       	st	-X, r28
    1ee6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ee8:	39 87       	std	Y+9, r19	; 0x09
    1eea:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1eec:	f9 01       	movw	r30, r18
    1eee:	80 81       	ld	r24, Z
    1ef0:	8f 5f       	subi	r24, 0xFF	; 255
    1ef2:	80 83       	st	Z, r24
}
    1ef4:	df 91       	pop	r29
    1ef6:	cf 91       	pop	r28
    1ef8:	08 95       	ret

00001efa <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1efa:	cf 93       	push	r28
    1efc:	df 93       	push	r29
    1efe:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1f00:	18 96       	adiw	r26, 0x08	; 8
    1f02:	cd 91       	ld	r28, X+
    1f04:	dc 91       	ld	r29, X
    1f06:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f08:	12 96       	adiw	r26, 0x02	; 2
    1f0a:	4d 91       	ld	r20, X+
    1f0c:	5c 91       	ld	r21, X
    1f0e:	13 97       	sbiw	r26, 0x03	; 3
    1f10:	14 96       	adiw	r26, 0x04	; 4
    1f12:	8d 91       	ld	r24, X+
    1f14:	9c 91       	ld	r25, X
    1f16:	15 97       	sbiw	r26, 0x05	; 5
    1f18:	fa 01       	movw	r30, r20
    1f1a:	95 83       	std	Z+5, r25	; 0x05
    1f1c:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f1e:	14 96       	adiw	r26, 0x04	; 4
    1f20:	2d 91       	ld	r18, X+
    1f22:	3c 91       	ld	r19, X
    1f24:	15 97       	sbiw	r26, 0x05	; 5
    1f26:	f9 01       	movw	r30, r18
    1f28:	53 83       	std	Z+3, r21	; 0x03
    1f2a:	42 83       	std	Z+2, r20	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
    1f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f30:	8a 17       	cp	r24, r26
    1f32:	9b 07       	cpc	r25, r27
    1f34:	11 f4       	brne	.+4      	; 0x1f3a <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f36:	3a 83       	std	Y+2, r19	; 0x02
    1f38:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1f3a:	19 96       	adiw	r26, 0x09	; 9
    1f3c:	1c 92       	st	X, r1
    1f3e:	1e 92       	st	-X, r1
    1f40:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1f42:	88 81       	ld	r24, Y
    1f44:	81 50       	subi	r24, 0x01	; 1
    1f46:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	08 95       	ret

00001f4e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1f4e:	ef 92       	push	r14
    1f50:	ff 92       	push	r15
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1f56:	dc 01       	movw	r26, r24
    1f58:	15 96       	adiw	r26, 0x05	; 5
    1f5a:	ed 91       	ld	r30, X+
    1f5c:	fc 91       	ld	r31, X
    1f5e:	16 97       	sbiw	r26, 0x06	; 6
    1f60:	e6 80       	ldd	r14, Z+6	; 0x06
    1f62:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f64:	87 01       	movw	r16, r14
    1f66:	04 5f       	subi	r16, 0xF4	; 244
    1f68:	1f 4f       	sbci	r17, 0xFF	; 255
    1f6a:	c8 01       	movw	r24, r16
    1f6c:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1f70:	84 ee       	ldi	r24, 0xE4	; 228
    1f72:	92 e0       	ldi	r25, 0x02	; 2
    1f74:	b8 01       	movw	r22, r16
    1f76:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
    1f7a:	20 e0       	ldi	r18, 0x00	; 0
    1f7c:	e0 91 b3 02 	lds	r30, 0x02B3
    1f80:	f0 91 b4 02 	lds	r31, 0x02B4
    1f84:	d7 01       	movw	r26, r14
    1f86:	56 96       	adiw	r26, 0x16	; 22
    1f88:	9c 91       	ld	r25, X
    1f8a:	86 89       	ldd	r24, Z+22	; 0x16
    1f8c:	98 17       	cp	r25, r24
    1f8e:	08 f0       	brcs	.+2      	; 0x1f92 <xCoRoutineRemoveFromEventList+0x44>
    1f90:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1f92:	82 2f       	mov	r24, r18
    1f94:	1f 91       	pop	r17
    1f96:	0f 91       	pop	r16
    1f98:	ff 90       	pop	r15
    1f9a:	ef 90       	pop	r14
    1f9c:	08 95       	ret

00001f9e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1f9e:	ff 92       	push	r15
    1fa0:	0f 93       	push	r16
    1fa2:	1f 93       	push	r17
    1fa4:	cf 93       	push	r28
    1fa6:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1fa8:	99 e0       	ldi	r25, 0x09	; 9
    1faa:	f9 2e       	mov	r15, r25
    1fac:	21 c0       	rjmp	.+66     	; 0x1ff0 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1fae:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1fb0:	e0 91 e9 02 	lds	r30, 0x02E9
    1fb4:	f0 91 ea 02 	lds	r31, 0x02EA
    1fb8:	06 81       	ldd	r16, Z+6	; 0x06
    1fba:	17 81       	ldd	r17, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1fbc:	c8 01       	movw	r24, r16
    1fbe:	0c 96       	adiw	r24, 0x0c	; 12
    1fc0:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1fc4:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1fc6:	e8 01       	movw	r28, r16
    1fc8:	22 96       	adiw	r28, 0x02	; 2
    1fca:	ce 01       	movw	r24, r28
    1fcc:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1fd0:	f8 01       	movw	r30, r16
    1fd2:	96 89       	ldd	r25, Z+22	; 0x16
    1fd4:	80 91 b5 02 	lds	r24, 0x02B5
    1fd8:	89 17       	cp	r24, r25
    1fda:	10 f4       	brcc	.+4      	; 0x1fe0 <vCoRoutineSchedule+0x42>
    1fdc:	90 93 b5 02 	sts	0x02B5, r25
    1fe0:	9f 9d       	mul	r25, r15
    1fe2:	c0 01       	movw	r24, r0
    1fe4:	11 24       	eor	r1, r1
    1fe6:	84 54       	subi	r24, 0x44	; 68
    1fe8:	9d 4f       	sbci	r25, 0xFD	; 253
    1fea:	be 01       	movw	r22, r28
    1fec:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1ff0:	80 91 e4 02 	lds	r24, 0x02E4
    1ff4:	88 23       	and	r24, r24
    1ff6:	d9 f6       	brne	.-74     	; 0x1fae <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1ff8:	0e 94 e6 03 	call	0x7cc	; 0x7cc <xTaskGetTickCount>
    1ffc:	20 91 b6 02 	lds	r18, 0x02B6
    2000:	30 91 b7 02 	lds	r19, 0x02B7
    2004:	82 1b       	sub	r24, r18
    2006:	93 0b       	sbc	r25, r19
    2008:	90 93 b9 02 	sts	0x02B9, r25
    200c:	80 93 b8 02 	sts	0x02B8, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2010:	89 e0       	ldi	r24, 0x09	; 9
    2012:	f8 2e       	mov	r15, r24
    2014:	53 c0       	rjmp	.+166    	; 0x20bc <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2016:	01 96       	adiw	r24, 0x01	; 1
    2018:	90 93 bb 02 	sts	0x02BB, r25
    201c:	80 93 ba 02 	sts	0x02BA, r24
		xPassedTicks--;
    2020:	21 50       	subi	r18, 0x01	; 1
    2022:	30 40       	sbci	r19, 0x00	; 0
    2024:	30 93 b9 02 	sts	0x02B9, r19
    2028:	20 93 b8 02 	sts	0x02B8, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    202c:	89 2b       	or	r24, r25
    202e:	09 f0       	breq	.+2      	; 0x2032 <vCoRoutineSchedule+0x94>
    2030:	3e c0       	rjmp	.+124    	; 0x20ae <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2032:	20 91 e0 02 	lds	r18, 0x02E0
    2036:	30 91 e1 02 	lds	r19, 0x02E1
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    203a:	80 91 e2 02 	lds	r24, 0x02E2
    203e:	90 91 e3 02 	lds	r25, 0x02E3
    2042:	90 93 e1 02 	sts	0x02E1, r25
    2046:	80 93 e0 02 	sts	0x02E0, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    204a:	30 93 e3 02 	sts	0x02E3, r19
    204e:	20 93 e2 02 	sts	0x02E2, r18
    2052:	2d c0       	rjmp	.+90     	; 0x20ae <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2054:	05 80       	ldd	r0, Z+5	; 0x05
    2056:	f6 81       	ldd	r31, Z+6	; 0x06
    2058:	e0 2d       	mov	r30, r0
    205a:	c6 81       	ldd	r28, Z+6	; 0x06
    205c:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    205e:	20 91 ba 02 	lds	r18, 0x02BA
    2062:	30 91 bb 02 	lds	r19, 0x02BB
    2066:	8a 81       	ldd	r24, Y+2	; 0x02
    2068:	9b 81       	ldd	r25, Y+3	; 0x03
    206a:	28 17       	cp	r18, r24
    206c:	39 07       	cpc	r19, r25
    206e:	30 f1       	brcs	.+76     	; 0x20bc <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2070:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2072:	8e 01       	movw	r16, r28
    2074:	0e 5f       	subi	r16, 0xFE	; 254
    2076:	1f 4f       	sbci	r17, 0xFF	; 255
    2078:	c8 01       	movw	r24, r16
    207a:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    207e:	8c 89       	ldd	r24, Y+20	; 0x14
    2080:	9d 89       	ldd	r25, Y+21	; 0x15
    2082:	89 2b       	or	r24, r25
    2084:	21 f0       	breq	.+8      	; 0x208e <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2086:	ce 01       	movw	r24, r28
    2088:	0c 96       	adiw	r24, 0x0c	; 12
    208a:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    208e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2090:	9e 89       	ldd	r25, Y+22	; 0x16
    2092:	80 91 b5 02 	lds	r24, 0x02B5
    2096:	89 17       	cp	r24, r25
    2098:	10 f4       	brcc	.+4      	; 0x209e <vCoRoutineSchedule+0x100>
    209a:	90 93 b5 02 	sts	0x02B5, r25
    209e:	9f 9d       	mul	r25, r15
    20a0:	c0 01       	movw	r24, r0
    20a2:	11 24       	eor	r1, r1
    20a4:	84 54       	subi	r24, 0x44	; 68
    20a6:	9d 4f       	sbci	r25, 0xFD	; 253
    20a8:	b8 01       	movw	r22, r16
    20aa:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    20ae:	e0 91 e0 02 	lds	r30, 0x02E0
    20b2:	f0 91 e1 02 	lds	r31, 0x02E1
    20b6:	80 81       	ld	r24, Z
    20b8:	88 23       	and	r24, r24
    20ba:	61 f6       	brne	.-104    	; 0x2054 <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    20bc:	20 91 b8 02 	lds	r18, 0x02B8
    20c0:	30 91 b9 02 	lds	r19, 0x02B9
    20c4:	80 91 ba 02 	lds	r24, 0x02BA
    20c8:	90 91 bb 02 	lds	r25, 0x02BB
    20cc:	21 15       	cp	r18, r1
    20ce:	31 05       	cpc	r19, r1
    20d0:	09 f0       	breq	.+2      	; 0x20d4 <vCoRoutineSchedule+0x136>
    20d2:	a1 cf       	rjmp	.-190    	; 0x2016 <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    20d4:	90 93 b7 02 	sts	0x02B7, r25
    20d8:	80 93 b6 02 	sts	0x02B6, r24
    20dc:	90 91 b5 02 	lds	r25, 0x02B5

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    20e0:	29 e0       	ldi	r18, 0x09	; 9
    20e2:	06 c0       	rjmp	.+12     	; 0x20f0 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    20e4:	99 23       	and	r25, r25
    20e6:	19 f4       	brne	.+6      	; 0x20ee <vCoRoutineSchedule+0x150>
    20e8:	10 92 b5 02 	sts	0x02B5, r1
    20ec:	32 c0       	rjmp	.+100    	; 0x2152 <vCoRoutineSchedule+0x1b4>
    20ee:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    20f0:	92 9f       	mul	r25, r18
    20f2:	d0 01       	movw	r26, r0
    20f4:	11 24       	eor	r1, r1
    20f6:	a4 54       	subi	r26, 0x44	; 68
    20f8:	bd 4f       	sbci	r27, 0xFD	; 253
    20fa:	8c 91       	ld	r24, X
    20fc:	88 23       	and	r24, r24
    20fe:	91 f3       	breq	.-28     	; 0x20e4 <vCoRoutineSchedule+0x146>
    2100:	90 93 b5 02 	sts	0x02B5, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2104:	11 96       	adiw	r26, 0x01	; 1
    2106:	ed 91       	ld	r30, X+
    2108:	fc 91       	ld	r31, X
    210a:	12 97       	sbiw	r26, 0x02	; 2
    210c:	02 80       	ldd	r0, Z+2	; 0x02
    210e:	f3 81       	ldd	r31, Z+3	; 0x03
    2110:	e0 2d       	mov	r30, r0
    2112:	12 96       	adiw	r26, 0x02	; 2
    2114:	fc 93       	st	X, r31
    2116:	ee 93       	st	-X, r30
    2118:	11 97       	sbiw	r26, 0x01	; 1
    211a:	cd 01       	movw	r24, r26
    211c:	03 96       	adiw	r24, 0x03	; 3
    211e:	e8 17       	cp	r30, r24
    2120:	f9 07       	cpc	r31, r25
    2122:	31 f4       	brne	.+12     	; 0x2130 <vCoRoutineSchedule+0x192>
    2124:	82 81       	ldd	r24, Z+2	; 0x02
    2126:	93 81       	ldd	r25, Z+3	; 0x03
    2128:	12 96       	adiw	r26, 0x02	; 2
    212a:	9c 93       	st	X, r25
    212c:	8e 93       	st	-X, r24
    212e:	11 97       	sbiw	r26, 0x01	; 1
    2130:	11 96       	adiw	r26, 0x01	; 1
    2132:	ed 91       	ld	r30, X+
    2134:	fc 91       	ld	r31, X
    2136:	12 97       	sbiw	r26, 0x02	; 2
    2138:	06 80       	ldd	r0, Z+6	; 0x06
    213a:	f7 81       	ldd	r31, Z+7	; 0x07
    213c:	e0 2d       	mov	r30, r0
    213e:	f0 93 b4 02 	sts	0x02B4, r31
    2142:	e0 93 b3 02 	sts	0x02B3, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2146:	20 81       	ld	r18, Z
    2148:	31 81       	ldd	r19, Z+1	; 0x01
    214a:	cf 01       	movw	r24, r30
    214c:	67 89       	ldd	r22, Z+23	; 0x17
    214e:	f9 01       	movw	r30, r18
    2150:	19 95       	eicall

	return;
}
    2152:	df 91       	pop	r29
    2154:	cf 91       	pop	r28
    2156:	1f 91       	pop	r17
    2158:	0f 91       	pop	r16
    215a:	ff 90       	pop	r15
    215c:	08 95       	ret

0000215e <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    215e:	0f 93       	push	r16
    2160:	1f 93       	push	r17
    2162:	cf 93       	push	r28
    2164:	df 93       	push	r29
    2166:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2168:	00 91 ba 02 	lds	r16, 0x02BA
    216c:	10 91 bb 02 	lds	r17, 0x02BB
    2170:	08 0f       	add	r16, r24
    2172:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2174:	80 91 b3 02 	lds	r24, 0x02B3
    2178:	90 91 b4 02 	lds	r25, 0x02B4
    217c:	02 96       	adiw	r24, 0x02	; 2
    217e:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2182:	e0 91 b3 02 	lds	r30, 0x02B3
    2186:	f0 91 b4 02 	lds	r31, 0x02B4
    218a:	13 83       	std	Z+3, r17	; 0x03
    218c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    218e:	80 91 ba 02 	lds	r24, 0x02BA
    2192:	90 91 bb 02 	lds	r25, 0x02BB
    2196:	bf 01       	movw	r22, r30
    2198:	6e 5f       	subi	r22, 0xFE	; 254
    219a:	7f 4f       	sbci	r23, 0xFF	; 255
    219c:	08 17       	cp	r16, r24
    219e:	19 07       	cpc	r17, r25
    21a0:	28 f4       	brcc	.+10     	; 0x21ac <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    21a2:	80 91 e2 02 	lds	r24, 0x02E2
    21a6:	90 91 e3 02 	lds	r25, 0x02E3
    21aa:	04 c0       	rjmp	.+8      	; 0x21b4 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    21ac:	80 91 e0 02 	lds	r24, 0x02E0
    21b0:	90 91 e1 02 	lds	r25, 0x02E1
    21b4:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vListInsert>
	}

	if( pxEventList )
    21b8:	20 97       	sbiw	r28, 0x00	; 0
    21ba:	49 f0       	breq	.+18     	; 0x21ce <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    21bc:	60 91 b3 02 	lds	r22, 0x02B3
    21c0:	70 91 b4 02 	lds	r23, 0x02B4
    21c4:	64 5f       	subi	r22, 0xF4	; 244
    21c6:	7f 4f       	sbci	r23, 0xFF	; 255
    21c8:	ce 01       	movw	r24, r28
    21ca:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vListInsert>
	}
}
    21ce:	df 91       	pop	r29
    21d0:	cf 91       	pop	r28
    21d2:	1f 91       	pop	r17
    21d4:	0f 91       	pop	r16
    21d6:	08 95       	ret

000021d8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    21d8:	af 92       	push	r10
    21da:	bf 92       	push	r11
    21dc:	cf 92       	push	r12
    21de:	df 92       	push	r13
    21e0:	ef 92       	push	r14
    21e2:	ff 92       	push	r15
    21e4:	0f 93       	push	r16
    21e6:	1f 93       	push	r17
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
    21ec:	6c 01       	movw	r12, r24
    21ee:	b6 2e       	mov	r11, r22
    21f0:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    21f2:	8a e1       	ldi	r24, 0x1A	; 26
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	0e 94 76 11 	call	0x22ec	; 0x22ec <pvPortMalloc>
    21fa:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    21fc:	00 97       	sbiw	r24, 0x00	; 0
    21fe:	11 f4       	brne	.+4      	; 0x2204 <__stack+0x5>
    2200:	8f ef       	ldi	r24, 0xFF	; 255
    2202:	59 c0       	rjmp	.+178    	; 0x22b6 <__stack+0xb7>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2204:	80 91 b3 02 	lds	r24, 0x02B3
    2208:	90 91 b4 02 	lds	r25, 0x02B4
    220c:	89 2b       	or	r24, r25
    220e:	21 f5       	brne	.+72     	; 0x2258 <__stack+0x59>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2210:	d0 93 b4 02 	sts	0x02B4, r29
    2214:	c0 93 b3 02 	sts	0x02B3, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2218:	8c eb       	ldi	r24, 0xBC	; 188
    221a:	92 e0       	ldi	r25, 0x02	; 2
    221c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
    2220:	85 ec       	ldi	r24, 0xC5	; 197
    2222:	92 e0       	ldi	r25, 0x02	; 2
    2224:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2228:	2e ec       	ldi	r18, 0xCE	; 206
    222a:	e2 2e       	mov	r14, r18
    222c:	22 e0       	ldi	r18, 0x02	; 2
    222e:	f2 2e       	mov	r15, r18
    2230:	c7 01       	movw	r24, r14
    2232:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2236:	07 ed       	ldi	r16, 0xD7	; 215
    2238:	12 e0       	ldi	r17, 0x02	; 2
    223a:	c8 01       	movw	r24, r16
    223c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    2240:	84 ee       	ldi	r24, 0xE4	; 228
    2242:	92 e0       	ldi	r25, 0x02	; 2
    2244:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2248:	f0 92 e1 02 	sts	0x02E1, r15
    224c:	e0 92 e0 02 	sts	0x02E0, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2250:	10 93 e3 02 	sts	0x02E3, r17
    2254:	00 93 e2 02 	sts	0x02E2, r16
    2258:	eb 2c       	mov	r14, r11
    225a:	bb 20       	and	r11, r11
    225c:	11 f0       	breq	.+4      	; 0x2262 <__stack+0x63>
    225e:	ee 24       	eor	r14, r14
    2260:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2262:	19 8e       	std	Y+25, r1	; 0x19
    2264:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2266:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2268:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    226a:	fe 01       	movw	r30, r28
    226c:	c1 92       	st	Z+, r12
    226e:	d1 92       	st	Z+, r13
    2270:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2272:	cf 01       	movw	r24, r30
    2274:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2278:	ce 01       	movw	r24, r28
    227a:	0c 96       	adiw	r24, 0x0c	; 12
    227c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2280:	d9 87       	std	Y+9, r29	; 0x09
    2282:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2284:	db 8b       	std	Y+19, r29	; 0x13
    2286:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2288:	82 e0       	ldi	r24, 0x02	; 2
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	8e 19       	sub	r24, r14
    228e:	91 09       	sbc	r25, r1
    2290:	9d 87       	std	Y+13, r25	; 0x0d
    2292:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2294:	9e 89       	ldd	r25, Y+22	; 0x16
    2296:	80 91 b5 02 	lds	r24, 0x02B5
    229a:	89 17       	cp	r24, r25
    229c:	10 f4       	brcc	.+4      	; 0x22a2 <__stack+0xa3>
    229e:	90 93 b5 02 	sts	0x02B5, r25
    22a2:	89 e0       	ldi	r24, 0x09	; 9
    22a4:	98 9f       	mul	r25, r24
    22a6:	c0 01       	movw	r24, r0
    22a8:	11 24       	eor	r1, r1
    22aa:	84 54       	subi	r24, 0x44	; 68
    22ac:	9d 4f       	sbci	r25, 0xFD	; 253
    22ae:	b8 01       	movw	r22, r16
    22b0:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <vListInsertEnd>
    22b4:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    22b6:	df 91       	pop	r29
    22b8:	cf 91       	pop	r28
    22ba:	1f 91       	pop	r17
    22bc:	0f 91       	pop	r16
    22be:	ff 90       	pop	r15
    22c0:	ef 90       	pop	r14
    22c2:	df 90       	pop	r13
    22c4:	cf 90       	pop	r12
    22c6:	bf 90       	pop	r11
    22c8:	af 90       	pop	r10
    22ca:	08 95       	ret

000022cc <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    22cc:	08 95       	ret

000022ce <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    22ce:	10 92 ee 02 	sts	0x02EE, r1
    22d2:	10 92 ed 02 	sts	0x02ED, r1
}
    22d6:	08 95       	ret

000022d8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    22d8:	2b ed       	ldi	r18, 0xDB	; 219
    22da:	35 e0       	ldi	r19, 0x05	; 5
    22dc:	80 91 ed 02 	lds	r24, 0x02ED
    22e0:	90 91 ee 02 	lds	r25, 0x02EE
    22e4:	28 1b       	sub	r18, r24
    22e6:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    22e8:	c9 01       	movw	r24, r18
    22ea:	08 95       	ret

000022ec <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    22ec:	cf 93       	push	r28
    22ee:	df 93       	push	r29
    22f0:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    22f2:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    22f6:	80 91 ef 02 	lds	r24, 0x02EF
    22fa:	90 91 f0 02 	lds	r25, 0x02F0
    22fe:	89 2b       	or	r24, r25
    2300:	31 f4       	brne	.+12     	; 0x230e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2302:	82 ef       	ldi	r24, 0xF2	; 242
    2304:	92 e0       	ldi	r25, 0x02	; 2
    2306:	90 93 f0 02 	sts	0x02F0, r25
    230a:	80 93 ef 02 	sts	0x02EF, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    230e:	20 91 ed 02 	lds	r18, 0x02ED
    2312:	30 91 ee 02 	lds	r19, 0x02EE
    2316:	ce 01       	movw	r24, r28
    2318:	82 0f       	add	r24, r18
    231a:	93 1f       	adc	r25, r19
    231c:	45 e0       	ldi	r20, 0x05	; 5
    231e:	8b 3d       	cpi	r24, 0xDB	; 219
    2320:	94 07       	cpc	r25, r20
    2322:	70 f4       	brcc	.+28     	; 0x2340 <pvPortMalloc+0x54>
    2324:	28 17       	cp	r18, r24
    2326:	39 07       	cpc	r19, r25
    2328:	58 f4       	brcc	.+22     	; 0x2340 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    232a:	c0 91 ef 02 	lds	r28, 0x02EF
    232e:	d0 91 f0 02 	lds	r29, 0x02F0
    2332:	c2 0f       	add	r28, r18
    2334:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2336:	90 93 ee 02 	sts	0x02EE, r25
    233a:	80 93 ed 02 	sts	0x02ED, r24
    233e:	02 c0       	rjmp	.+4      	; 0x2344 <pvPortMalloc+0x58>
    2340:	c0 e0       	ldi	r28, 0x00	; 0
    2342:	d0 e0       	ldi	r29, 0x00	; 0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2344:	0e 94 22 07 	call	0xe44	; 0xe44 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2348:	ce 01       	movw	r24, r28
    234a:	df 91       	pop	r29
    234c:	cf 91       	pop	r28
    234e:	08 95       	ret

00002350 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2350:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2352:	91 e1       	ldi	r25, 0x11	; 17
    2354:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2356:	22 e2       	ldi	r18, 0x22	; 34
    2358:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    235a:	83 e3       	ldi	r24, 0x33	; 51
    235c:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    235e:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2360:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2362:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2364:	80 e8       	ldi	r24, 0x80	; 128
    2366:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2368:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    236a:	82 e0       	ldi	r24, 0x02	; 2
    236c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    236e:	83 e0       	ldi	r24, 0x03	; 3
    2370:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2372:	84 e0       	ldi	r24, 0x04	; 4
    2374:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2376:	85 e0       	ldi	r24, 0x05	; 5
    2378:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    237a:	86 e0       	ldi	r24, 0x06	; 6
    237c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    237e:	87 e0       	ldi	r24, 0x07	; 7
    2380:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2382:	88 e0       	ldi	r24, 0x08	; 8
    2384:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2386:	89 e0       	ldi	r24, 0x09	; 9
    2388:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    238a:	80 e1       	ldi	r24, 0x10	; 16
    238c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    238e:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2390:	82 e1       	ldi	r24, 0x12	; 18
    2392:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2394:	83 e1       	ldi	r24, 0x13	; 19
    2396:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2398:	84 e1       	ldi	r24, 0x14	; 20
    239a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    239c:	85 e1       	ldi	r24, 0x15	; 21
    239e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    23a0:	86 e1       	ldi	r24, 0x16	; 22
    23a2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    23a4:	87 e1       	ldi	r24, 0x17	; 23
    23a6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    23a8:	88 e1       	ldi	r24, 0x18	; 24
    23aa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    23ac:	89 e1       	ldi	r24, 0x19	; 25
    23ae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    23b0:	80 e2       	ldi	r24, 0x20	; 32
    23b2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    23b4:	81 e2       	ldi	r24, 0x21	; 33
    23b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    23b8:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    23ba:	83 e2       	ldi	r24, 0x23	; 35
    23bc:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23be:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23c0:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    23c2:	86 e2       	ldi	r24, 0x26	; 38
    23c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    23c6:	87 e2       	ldi	r24, 0x27	; 39
    23c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    23ca:	88 e2       	ldi	r24, 0x28	; 40
    23cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    23ce:	89 e2       	ldi	r24, 0x29	; 41
    23d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    23d2:	80 e3       	ldi	r24, 0x30	; 48
    23d4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    23d6:	81 e3       	ldi	r24, 0x31	; 49
    23d8:	82 93       	st	-Z, r24
    23da:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    23dc:	cf 01       	movw	r24, r30
    23de:	08 95       	ret

000023e0 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    23e0:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    23e4:	89 ef       	ldi	r24, 0xF9	; 249
    23e6:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    23ea:	8b e0       	ldi	r24, 0x0B	; 11
    23ec:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK0;
    23f0:	ee e6       	ldi	r30, 0x6E	; 110
    23f2:	f0 e0       	ldi	r31, 0x00	; 0
    23f4:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    23f6:	80 61       	ori	r24, 0x10	; 16
	TIMSK0 = ucLowByte;
    23f8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    23fa:	a0 91 56 02 	lds	r26, 0x0256
    23fe:	b0 91 57 02 	lds	r27, 0x0257
    2402:	cd 91       	ld	r28, X+
    2404:	cd bf       	out	0x3d, r28	; 61
    2406:	dd 91       	ld	r29, X+
    2408:	de bf       	out	0x3e, r29	; 62
    240a:	ff 91       	pop	r31
    240c:	ef 91       	pop	r30
    240e:	df 91       	pop	r29
    2410:	cf 91       	pop	r28
    2412:	bf 91       	pop	r27
    2414:	af 91       	pop	r26
    2416:	9f 91       	pop	r25
    2418:	8f 91       	pop	r24
    241a:	7f 91       	pop	r23
    241c:	6f 91       	pop	r22
    241e:	5f 91       	pop	r21
    2420:	4f 91       	pop	r20
    2422:	3f 91       	pop	r19
    2424:	2f 91       	pop	r18
    2426:	1f 91       	pop	r17
    2428:	0f 91       	pop	r16
    242a:	ff 90       	pop	r15
    242c:	ef 90       	pop	r14
    242e:	df 90       	pop	r13
    2430:	cf 90       	pop	r12
    2432:	bf 90       	pop	r11
    2434:	af 90       	pop	r10
    2436:	9f 90       	pop	r9
    2438:	8f 90       	pop	r8
    243a:	7f 90       	pop	r7
    243c:	6f 90       	pop	r6
    243e:	5f 90       	pop	r5
    2440:	4f 90       	pop	r4
    2442:	3f 90       	pop	r3
    2444:	2f 90       	pop	r2
    2446:	1f 90       	pop	r1
    2448:	0f 90       	pop	r0
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    244e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2450:	81 e0       	ldi	r24, 0x01	; 1
    2452:	08 95       	ret

00002454 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2454:	08 95       	ret

00002456 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2456:	0f 92       	push	r0
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	f8 94       	cli
    245c:	0f 92       	push	r0
    245e:	1f 92       	push	r1
    2460:	11 24       	eor	r1, r1
    2462:	2f 92       	push	r2
    2464:	3f 92       	push	r3
    2466:	4f 92       	push	r4
    2468:	5f 92       	push	r5
    246a:	6f 92       	push	r6
    246c:	7f 92       	push	r7
    246e:	8f 92       	push	r8
    2470:	9f 92       	push	r9
    2472:	af 92       	push	r10
    2474:	bf 92       	push	r11
    2476:	cf 92       	push	r12
    2478:	df 92       	push	r13
    247a:	ef 92       	push	r14
    247c:	ff 92       	push	r15
    247e:	0f 93       	push	r16
    2480:	1f 93       	push	r17
    2482:	2f 93       	push	r18
    2484:	3f 93       	push	r19
    2486:	4f 93       	push	r20
    2488:	5f 93       	push	r21
    248a:	6f 93       	push	r22
    248c:	7f 93       	push	r23
    248e:	8f 93       	push	r24
    2490:	9f 93       	push	r25
    2492:	af 93       	push	r26
    2494:	bf 93       	push	r27
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
    249a:	ef 93       	push	r30
    249c:	ff 93       	push	r31
    249e:	a0 91 56 02 	lds	r26, 0x0256
    24a2:	b0 91 57 02 	lds	r27, 0x0257
    24a6:	0d b6       	in	r0, 0x3d	; 61
    24a8:	0d 92       	st	X+, r0
    24aa:	0e b6       	in	r0, 0x3e	; 62
    24ac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    24ae:	0e 94 ef 05 	call	0xbde	; 0xbde <xTaskIncrementTick>
    24b2:	88 23       	and	r24, r24
    24b4:	11 f0       	breq	.+4      	; 0x24ba <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    24b6:	0e 94 05 04 	call	0x80a	; 0x80a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    24ba:	a0 91 56 02 	lds	r26, 0x0256
    24be:	b0 91 57 02 	lds	r27, 0x0257
    24c2:	cd 91       	ld	r28, X+
    24c4:	cd bf       	out	0x3d, r28	; 61
    24c6:	dd 91       	ld	r29, X+
    24c8:	de bf       	out	0x3e, r29	; 62
    24ca:	ff 91       	pop	r31
    24cc:	ef 91       	pop	r30
    24ce:	df 91       	pop	r29
    24d0:	cf 91       	pop	r28
    24d2:	bf 91       	pop	r27
    24d4:	af 91       	pop	r26
    24d6:	9f 91       	pop	r25
    24d8:	8f 91       	pop	r24
    24da:	7f 91       	pop	r23
    24dc:	6f 91       	pop	r22
    24de:	5f 91       	pop	r21
    24e0:	4f 91       	pop	r20
    24e2:	3f 91       	pop	r19
    24e4:	2f 91       	pop	r18
    24e6:	1f 91       	pop	r17
    24e8:	0f 91       	pop	r16
    24ea:	ff 90       	pop	r15
    24ec:	ef 90       	pop	r14
    24ee:	df 90       	pop	r13
    24f0:	cf 90       	pop	r12
    24f2:	bf 90       	pop	r11
    24f4:	af 90       	pop	r10
    24f6:	9f 90       	pop	r9
    24f8:	8f 90       	pop	r8
    24fa:	7f 90       	pop	r7
    24fc:	6f 90       	pop	r6
    24fe:	5f 90       	pop	r5
    2500:	4f 90       	pop	r4
    2502:	3f 90       	pop	r3
    2504:	2f 90       	pop	r2
    2506:	1f 90       	pop	r1
    2508:	0f 90       	pop	r0
    250a:	0f be       	out	0x3f, r0	; 63
    250c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    250e:	08 95       	ret

00002510 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2510:	0e 94 2b 12 	call	0x2456	; 0x2456 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2514:	18 95       	reti

00002516 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2516:	0f 92       	push	r0
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	f8 94       	cli
    251c:	0f 92       	push	r0
    251e:	1f 92       	push	r1
    2520:	11 24       	eor	r1, r1
    2522:	2f 92       	push	r2
    2524:	3f 92       	push	r3
    2526:	4f 92       	push	r4
    2528:	5f 92       	push	r5
    252a:	6f 92       	push	r6
    252c:	7f 92       	push	r7
    252e:	8f 92       	push	r8
    2530:	9f 92       	push	r9
    2532:	af 92       	push	r10
    2534:	bf 92       	push	r11
    2536:	cf 92       	push	r12
    2538:	df 92       	push	r13
    253a:	ef 92       	push	r14
    253c:	ff 92       	push	r15
    253e:	0f 93       	push	r16
    2540:	1f 93       	push	r17
    2542:	2f 93       	push	r18
    2544:	3f 93       	push	r19
    2546:	4f 93       	push	r20
    2548:	5f 93       	push	r21
    254a:	6f 93       	push	r22
    254c:	7f 93       	push	r23
    254e:	8f 93       	push	r24
    2550:	9f 93       	push	r25
    2552:	af 93       	push	r26
    2554:	bf 93       	push	r27
    2556:	cf 93       	push	r28
    2558:	df 93       	push	r29
    255a:	ef 93       	push	r30
    255c:	ff 93       	push	r31
    255e:	a0 91 56 02 	lds	r26, 0x0256
    2562:	b0 91 57 02 	lds	r27, 0x0257
    2566:	0d b6       	in	r0, 0x3d	; 61
    2568:	0d 92       	st	X+, r0
    256a:	0e b6       	in	r0, 0x3e	; 62
    256c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    256e:	0e 94 05 04 	call	0x80a	; 0x80a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2572:	a0 91 56 02 	lds	r26, 0x0256
    2576:	b0 91 57 02 	lds	r27, 0x0257
    257a:	cd 91       	ld	r28, X+
    257c:	cd bf       	out	0x3d, r28	; 61
    257e:	dd 91       	ld	r29, X+
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	ff 91       	pop	r31
    2584:	ef 91       	pop	r30
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	bf 91       	pop	r27
    258c:	af 91       	pop	r26
    258e:	9f 91       	pop	r25
    2590:	8f 91       	pop	r24
    2592:	7f 91       	pop	r23
    2594:	6f 91       	pop	r22
    2596:	5f 91       	pop	r21
    2598:	4f 91       	pop	r20
    259a:	3f 91       	pop	r19
    259c:	2f 91       	pop	r18
    259e:	1f 91       	pop	r17
    25a0:	0f 91       	pop	r16
    25a2:	ff 90       	pop	r15
    25a4:	ef 90       	pop	r14
    25a6:	df 90       	pop	r13
    25a8:	cf 90       	pop	r12
    25aa:	bf 90       	pop	r11
    25ac:	af 90       	pop	r10
    25ae:	9f 90       	pop	r9
    25b0:	8f 90       	pop	r8
    25b2:	7f 90       	pop	r7
    25b4:	6f 90       	pop	r6
    25b6:	5f 90       	pop	r5
    25b8:	4f 90       	pop	r4
    25ba:	3f 90       	pop	r3
    25bc:	2f 90       	pop	r2
    25be:	1f 90       	pop	r1
    25c0:	0f 90       	pop	r0
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    25c6:	08 95       	ret

000025c8 <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    25c8:	80 91 1a 02 	lds	r24, 0x021A
    25cc:	08 95       	ret

000025ce <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    25ce:	0f 93       	push	r16
    25d0:	1f 93       	push	r17
    25d2:	08 2f       	mov	r16, r24
    25d4:	89 30       	cpi	r24, 0x09	; 9
    25d6:	08 f0       	brcs	.+2      	; 0x25da <vStartFlashCoRoutines+0xc>
    25d8:	08 e0       	ldi	r16, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    25da:	81 e0       	ldi	r24, 0x01	; 1
    25dc:	61 e0       	ldi	r22, 0x01	; 1
    25de:	40 e0       	ldi	r20, 0x00	; 0
    25e0:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericCreate>
    25e4:	90 93 ce 08 	sts	0x08CE, r25
    25e8:	80 93 cd 08 	sts	0x08CD, r24

	if( xFlashQueue )
    25ec:	89 2b       	or	r24, r25
    25ee:	89 f0       	breq	.+34     	; 0x2612 <vStartFlashCoRoutines+0x44>
    25f0:	10 e0       	ldi	r17, 0x00	; 0
    25f2:	07 c0       	rjmp	.+14     	; 0x2602 <vStartFlashCoRoutines+0x34>
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    25f4:	83 e5       	ldi	r24, 0x53	; 83
    25f6:	93 e1       	ldi	r25, 0x13	; 19
    25f8:	60 e0       	ldi	r22, 0x00	; 0
    25fa:	41 2f       	mov	r20, r17
    25fc:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2600:	1f 5f       	subi	r17, 0xFF	; 255
    2602:	10 17       	cp	r17, r16
    2604:	b8 f3       	brcs	.-18     	; 0x25f4 <vStartFlashCoRoutines+0x26>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2606:	8c e0       	ldi	r24, 0x0C	; 12
    2608:	93 e1       	ldi	r25, 0x13	; 19
    260a:	61 e0       	ldi	r22, 0x01	; 1
    260c:	40 e0       	ldi	r20, 0x00	; 0
    260e:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <xCoRoutineCreate>
	}
}
    2612:	1f 91       	pop	r17
    2614:	0f 91       	pop	r16
    2616:	08 95       	ret

00002618 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2618:	0f 93       	push	r16
    261a:	1f 93       	push	r17
    261c:	df 93       	push	r29
    261e:	cf 93       	push	r28
    2620:	0f 92       	push	r0
    2622:	cd b7       	in	r28, 0x3d	; 61
    2624:	de b7       	in	r29, 0x3e	; 62
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2626:	8c 01       	movw	r16, r24
    2628:	fc 01       	movw	r30, r24
    262a:	80 8d       	ldd	r24, Z+24	; 0x18
    262c:	91 8d       	ldd	r25, Z+25	; 0x19
    262e:	f1 e0       	ldi	r31, 0x01	; 1
    2630:	82 3c       	cpi	r24, 0xC2	; 194
    2632:	9f 07       	cpc	r25, r31
    2634:	b1 f0       	breq	.+44     	; 0x2662 <prvFlashCoRoutine+0x4a>
    2636:	21 e0       	ldi	r18, 0x01	; 1
    2638:	83 3c       	cpi	r24, 0xC3	; 195
    263a:	92 07       	cpc	r25, r18
    263c:	51 f1       	breq	.+84     	; 0x2692 <prvFlashCoRoutine+0x7a>
    263e:	89 2b       	or	r24, r25
    2640:	61 f5       	brne	.+88     	; 0x269a <prvFlashCoRoutine+0x82>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
    2642:	80 91 cd 08 	lds	r24, 0x08CD
    2646:	90 91 ce 08 	lds	r25, 0x08CE
    264a:	be 01       	movw	r22, r28
    264c:	6f 5f       	subi	r22, 0xFF	; 255
    264e:	7f 4f       	sbci	r23, 0xFF	; 255
    2650:	4f ef       	ldi	r20, 0xFF	; 255
    2652:	5f ef       	ldi	r21, 0xFF	; 255
    2654:	0e 94 09 0c 	call	0x1812	; 0x1812 <xQueueCRReceive>
    2658:	8c 3f       	cpi	r24, 0xFC	; 252
    265a:	71 f4       	brne	.+28     	; 0x2678 <prvFlashCoRoutine+0x60>
    265c:	82 ec       	ldi	r24, 0xC2	; 194
    265e:	91 e0       	ldi	r25, 0x01	; 1
    2660:	0f c0       	rjmp	.+30     	; 0x2680 <prvFlashCoRoutine+0x68>
    2662:	80 91 cd 08 	lds	r24, 0x08CD
    2666:	90 91 ce 08 	lds	r25, 0x08CE
    266a:	be 01       	movw	r22, r28
    266c:	6f 5f       	subi	r22, 0xFF	; 255
    266e:	7f 4f       	sbci	r23, 0xFF	; 255
    2670:	40 e0       	ldi	r20, 0x00	; 0
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	0e 94 09 0c 	call	0x1812	; 0x1812 <xQueueCRReceive>
    2678:	8b 3f       	cpi	r24, 0xFB	; 251
    267a:	31 f4       	brne	.+12     	; 0x2688 <prvFlashCoRoutine+0x70>
    267c:	83 ec       	ldi	r24, 0xC3	; 195
    267e:	91 e0       	ldi	r25, 0x01	; 1
    2680:	f8 01       	movw	r30, r16
    2682:	91 8f       	std	Z+25, r25	; 0x19
    2684:	80 8f       	std	Z+24, r24	; 0x18
    2686:	09 c0       	rjmp	.+18     	; 0x269a <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2688:	81 30       	cpi	r24, 0x01	; 1
    268a:	19 f0       	breq	.+6      	; 0x2692 <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    268c:	10 92 1a 02 	sts	0x021A, r1
    2690:	d8 cf       	rjmp	.-80     	; 0x2642 <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    2692:	89 81       	ldd	r24, Y+1	; 0x01
    2694:	0e 94 24 01 	call	0x248	; 0x248 <vParTestToggleLED>
    2698:	d4 cf       	rjmp	.-88     	; 0x2642 <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    269a:	0f 90       	pop	r0
    269c:	cf 91       	pop	r28
    269e:	df 91       	pop	r29
    26a0:	1f 91       	pop	r17
    26a2:	0f 91       	pop	r16
    26a4:	08 95       	ret

000026a6 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    26a6:	0f 93       	push	r16
    26a8:	1f 93       	push	r17
    26aa:	df 93       	push	r29
    26ac:	cf 93       	push	r28
    26ae:	0f 92       	push	r0
    26b0:	cd b7       	in	r28, 0x3d	; 61
    26b2:	de b7       	in	r29, 0x3e	; 62
    26b4:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    26b6:	8c 01       	movw	r16, r24
    26b8:	fc 01       	movw	r30, r24
    26ba:	80 8d       	ldd	r24, Z+24	; 0x18
    26bc:	91 8d       	ldd	r25, Z+25	; 0x19
    26be:	f1 e0       	ldi	r31, 0x01	; 1
    26c0:	82 38       	cpi	r24, 0x82	; 130
    26c2:	9f 07       	cpc	r25, r31
    26c4:	f1 f0       	breq	.+60     	; 0x2702 <prvFixedDelayCoRoutine+0x5c>
    26c6:	21 e0       	ldi	r18, 0x01	; 1
    26c8:	83 38       	cpi	r24, 0x83	; 131
    26ca:	92 07       	cpc	r25, r18
    26cc:	18 f4       	brcc	.+6      	; 0x26d4 <prvFixedDelayCoRoutine+0x2e>
    26ce:	89 2b       	or	r24, r25
    26d0:	41 f0       	breq	.+16     	; 0x26e2 <prvFixedDelayCoRoutine+0x3c>
    26d2:	3e c0       	rjmp	.+124    	; 0x2750 <prvFixedDelayCoRoutine+0xaa>
    26d4:	e1 e0       	ldi	r30, 0x01	; 1
    26d6:	83 38       	cpi	r24, 0x83	; 131
    26d8:	9e 07       	cpc	r25, r30
    26da:	39 f1       	breq	.+78     	; 0x272a <prvFixedDelayCoRoutine+0x84>
    26dc:	86 59       	subi	r24, 0x96	; 150
    26de:	91 40       	sbci	r25, 0x01	; 1
    26e0:	b9 f5       	brne	.+110    	; 0x2750 <prvFixedDelayCoRoutine+0xaa>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    26e2:	80 91 cd 08 	lds	r24, 0x08CD
    26e6:	90 91 ce 08 	lds	r25, 0x08CE
    26ea:	be 01       	movw	r22, r28
    26ec:	6f 5f       	subi	r22, 0xFF	; 255
    26ee:	7f 4f       	sbci	r23, 0xFF	; 255
    26f0:	40 e0       	ldi	r20, 0x00	; 0
    26f2:	50 e0       	ldi	r21, 0x00	; 0
    26f4:	0e 94 4e 0c 	call	0x189c	; 0x189c <xQueueCRSend>
    26f8:	8c 3f       	cpi	r24, 0xFC	; 252
    26fa:	71 f4       	brne	.+28     	; 0x2718 <prvFixedDelayCoRoutine+0x72>
    26fc:	82 e8       	ldi	r24, 0x82	; 130
    26fe:	91 e0       	ldi	r25, 0x01	; 1
    2700:	24 c0       	rjmp	.+72     	; 0x274a <prvFixedDelayCoRoutine+0xa4>
    2702:	80 91 cd 08 	lds	r24, 0x08CD
    2706:	90 91 ce 08 	lds	r25, 0x08CE
    270a:	be 01       	movw	r22, r28
    270c:	6f 5f       	subi	r22, 0xFF	; 255
    270e:	7f 4f       	sbci	r23, 0xFF	; 255
    2710:	40 e0       	ldi	r20, 0x00	; 0
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	0e 94 4e 0c 	call	0x189c	; 0x189c <xQueueCRSend>
    2718:	8b 3f       	cpi	r24, 0xFB	; 251
    271a:	19 f4       	brne	.+6      	; 0x2722 <prvFixedDelayCoRoutine+0x7c>
    271c:	83 e8       	ldi	r24, 0x83	; 131
    271e:	91 e0       	ldi	r25, 0x01	; 1
    2720:	14 c0       	rjmp	.+40     	; 0x274a <prvFixedDelayCoRoutine+0xa4>

		if( xResult != pdPASS )
    2722:	81 30       	cpi	r24, 0x01	; 1
    2724:	11 f0       	breq	.+4      	; 0x272a <prvFixedDelayCoRoutine+0x84>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    2726:	10 92 1a 02 	sts	0x021A, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    272a:	e9 81       	ldd	r30, Y+1	; 0x01
    272c:	f0 e0       	ldi	r31, 0x00	; 0
    272e:	ee 0f       	add	r30, r30
    2730:	ff 1f       	adc	r31, r31
    2732:	e5 5e       	subi	r30, 0xE5	; 229
    2734:	fd 4f       	sbci	r31, 0xFD	; 253
    2736:	80 81       	ld	r24, Z
    2738:	91 81       	ldd	r25, Z+1	; 0x01
    273a:	00 97       	sbiw	r24, 0x00	; 0
    273c:	21 f0       	breq	.+8      	; 0x2746 <prvFixedDelayCoRoutine+0xa0>
    273e:	60 e0       	ldi	r22, 0x00	; 0
    2740:	70 e0       	ldi	r23, 0x00	; 0
    2742:	0e 94 af 10 	call	0x215e	; 0x215e <vCoRoutineAddToDelayedList>
    2746:	86 e9       	ldi	r24, 0x96	; 150
    2748:	91 e0       	ldi	r25, 0x01	; 1
    274a:	f8 01       	movw	r30, r16
    274c:	91 8f       	std	Z+25, r25	; 0x19
    274e:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2750:	0f 90       	pop	r0
    2752:	cf 91       	pop	r28
    2754:	df 91       	pop	r29
    2756:	1f 91       	pop	r17
    2758:	0f 91       	pop	r16
    275a:	08 95       	ret

0000275c <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    275c:	9f 92       	push	r9
    275e:	af 92       	push	r10
    2760:	bf 92       	push	r11
    2762:	cf 92       	push	r12
    2764:	df 92       	push	r13
    2766:	ef 92       	push	r14
    2768:	ff 92       	push	r15
    276a:	0f 93       	push	r16
    276c:	1f 93       	push	r17
    276e:	df 93       	push	r29
    2770:	cf 93       	push	r28
    2772:	00 d0       	rcall	.+0      	; 0x2774 <vCompeteingIntMathTask+0x18>
    2774:	0f 92       	push	r0
    2776:	cd b7       	in	r28, 0x3d	; 61
    2778:	de b7       	in	r29, 0x3e	; 62
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    277a:	8c 01       	movw	r16, r24
    277c:	ee 24       	eor	r14, r14
    277e:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2780:	9b e7       	ldi	r25, 0x7B	; 123
    2782:	a9 2e       	mov	r10, r25
    2784:	b1 2c       	mov	r11, r1
    2786:	c1 2c       	mov	r12, r1
    2788:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    278a:	99 24       	eor	r9, r9
    278c:	93 94       	inc	r9
    278e:	03 c0       	rjmp	.+6      	; 0x2796 <vCompeteingIntMathTask+0x3a>
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	e8 2e       	mov	r14, r24
    2794:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2796:	a9 82       	std	Y+1, r10	; 0x01
    2798:	ba 82       	std	Y+2, r11	; 0x02
    279a:	cb 82       	std	Y+3, r12	; 0x03
    279c:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	9a 81       	ldd	r25, Y+2	; 0x02
    27a2:	ab 81       	ldd	r26, Y+3	; 0x03
    27a4:	bc 81       	ldd	r27, Y+4	; 0x04
    27a6:	89 5b       	subi	r24, 0xB9	; 185
    27a8:	9b 46       	sbci	r25, 0x6B	; 107
    27aa:	ac 4f       	sbci	r26, 0xFC	; 252
    27ac:	bf 4f       	sbci	r27, 0xFF	; 255
    27ae:	89 83       	std	Y+1, r24	; 0x01
    27b0:	9a 83       	std	Y+2, r25	; 0x02
    27b2:	ab 83       	std	Y+3, r26	; 0x03
    27b4:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    27b6:	69 81       	ldd	r22, Y+1	; 0x01
    27b8:	7a 81       	ldd	r23, Y+2	; 0x02
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	9c 81       	ldd	r25, Y+4	; 0x04
    27be:	2d ef       	ldi	r18, 0xFD	; 253
    27c0:	3f ef       	ldi	r19, 0xFF	; 255
    27c2:	4f ef       	ldi	r20, 0xFF	; 255
    27c4:	5f ef       	ldi	r21, 0xFF	; 255
    27c6:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__mulsi3>
    27ca:	69 83       	std	Y+1, r22	; 0x01
    27cc:	7a 83       	std	Y+2, r23	; 0x02
    27ce:	8b 83       	std	Y+3, r24	; 0x03
    27d0:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    27d2:	69 81       	ldd	r22, Y+1	; 0x01
    27d4:	7a 81       	ldd	r23, Y+2	; 0x02
    27d6:	8b 81       	ldd	r24, Y+3	; 0x03
    27d8:	9c 81       	ldd	r25, Y+4	; 0x04
    27da:	27 e0       	ldi	r18, 0x07	; 7
    27dc:	30 e0       	ldi	r19, 0x00	; 0
    27de:	40 e0       	ldi	r20, 0x00	; 0
    27e0:	50 e0       	ldi	r21, 0x00	; 0
    27e2:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__divmodsi4>
    27e6:	c9 01       	movw	r24, r18
    27e8:	da 01       	movw	r26, r20
    27ea:	89 83       	std	Y+1, r24	; 0x01
    27ec:	9a 83       	std	Y+2, r25	; 0x02
    27ee:	ab 83       	std	Y+3, r26	; 0x03
    27f0:	bc 83       	std	Y+4, r27	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	ab 81       	ldd	r26, Y+3	; 0x03
    27f8:	bc 81       	ldd	r27, Y+4	; 0x04
    27fa:	8b 51       	subi	r24, 0x1B	; 27
    27fc:	97 47       	sbci	r25, 0x77	; 119
    27fe:	ae 4f       	sbci	r26, 0xFE	; 254
    2800:	bf 4f       	sbci	r27, 0xFF	; 255
    2802:	31 f6       	brne	.-116    	; 0x2790 <vCompeteingIntMathTask+0x34>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    2804:	e1 14       	cp	r14, r1
    2806:	f1 04       	cpc	r15, r1
    2808:	09 f0       	breq	.+2      	; 0x280c <vCompeteingIntMathTask+0xb0>
    280a:	c2 cf       	rjmp	.-124    	; 0x2790 <vCompeteingIntMathTask+0x34>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    280c:	0f b6       	in	r0, 0x3f	; 63
    280e:	f8 94       	cli
    2810:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    2812:	f8 01       	movw	r30, r16
    2814:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    2816:	0f 90       	pop	r0
    2818:	0f be       	out	0x3f, r0	; 63
    281a:	bd cf       	rjmp	.-134    	; 0x2796 <vCompeteingIntMathTask+0x3a>

0000281c <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    281c:	80 91 cf 08 	lds	r24, 0x08CF
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    2820:	10 92 cf 08 	sts	0x08CF, r1
    2824:	81 11       	cpse	r24, r1
    2826:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    2828:	08 95       	ret

0000282a <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    282a:	ef 92       	push	r14
    282c:	ff 92       	push	r15
    282e:	0f 93       	push	r16
    2830:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2832:	8e ea       	ldi	r24, 0xAE	; 174
    2834:	93 e1       	ldi	r25, 0x13	; 19
    2836:	6b e2       	ldi	r22, 0x2B	; 43
    2838:	72 e0       	ldi	r23, 0x02	; 2
    283a:	45 e5       	ldi	r20, 0x55	; 85
    283c:	50 e0       	ldi	r21, 0x00	; 0
    283e:	2f ec       	ldi	r18, 0xCF	; 207
    2840:	38 e0       	ldi	r19, 0x08	; 8
    2842:	ee 24       	eor	r14, r14
    2844:	ff 24       	eor	r15, r15
    2846:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
	}
}
    284a:	0f 91       	pop	r16
    284c:	ff 90       	pop	r15
    284e:	ef 90       	pop	r14
    2850:	08 95       	ret

00002852 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2852:	80 91 d0 08 	lds	r24, 0x08D0
    2856:	88 23       	and	r24, r24
    2858:	21 f0       	breq	.+8      	; 0x2862 <xArePollingQueuesStillRunning+0x10>
    285a:	80 91 d1 08 	lds	r24, 0x08D1
    285e:	81 11       	cpse	r24, r1
    2860:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2862:	10 92 d0 08 	sts	0x08D0, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    2866:	10 92 d1 08 	sts	0x08D1, r1

	return xReturn;
}
    286a:	08 95       	ret

0000286c <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    286c:	ef 92       	push	r14
    286e:	ff 92       	push	r15
    2870:	0f 93       	push	r16
    2872:	1f 93       	push	r17
    2874:	18 2f       	mov	r17, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2876:	8a e0       	ldi	r24, 0x0A	; 10
    2878:	62 e0       	ldi	r22, 0x02	; 2
    287a:	40 e0       	ldi	r20, 0x00	; 0
    287c:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <xQueueGenericCreate>
    2880:	90 93 d3 08 	sts	0x08D3, r25
    2884:	80 93 d2 08 	sts	0x08D2, r24

	if( xPolledQueue != NULL )
    2888:	89 2b       	or	r24, r25
    288a:	b9 f0       	breq	.+46     	; 0x28ba <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    288c:	8f e9       	ldi	r24, 0x9F	; 159
    288e:	94 e1       	ldi	r25, 0x14	; 20
    2890:	63 e3       	ldi	r22, 0x33	; 51
    2892:	72 e0       	ldi	r23, 0x02	; 2
    2894:	45 e5       	ldi	r20, 0x55	; 85
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	22 ed       	ldi	r18, 0xD2	; 210
    289a:	38 e0       	ldi	r19, 0x08	; 8
    289c:	01 2f       	mov	r16, r17
    289e:	ee 24       	eor	r14, r14
    28a0:	ff 24       	eor	r15, r15
    28a2:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    28a6:	82 e6       	ldi	r24, 0x62	; 98
    28a8:	94 e1       	ldi	r25, 0x14	; 20
    28aa:	6b e3       	ldi	r22, 0x3B	; 59
    28ac:	72 e0       	ldi	r23, 0x02	; 2
    28ae:	45 e5       	ldi	r20, 0x55	; 85
    28b0:	50 e0       	ldi	r21, 0x00	; 0
    28b2:	22 ed       	ldi	r18, 0xD2	; 210
    28b4:	38 e0       	ldi	r19, 0x08	; 8
    28b6:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
	}
}
    28ba:	1f 91       	pop	r17
    28bc:	0f 91       	pop	r16
    28be:	ff 90       	pop	r15
    28c0:	ef 90       	pop	r14
    28c2:	08 95       	ret

000028c4 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    28c4:	cf 92       	push	r12
    28c6:	df 92       	push	r13
    28c8:	ef 92       	push	r14
    28ca:	ff 92       	push	r15
    28cc:	0f 93       	push	r16
    28ce:	1f 93       	push	r17
    28d0:	df 93       	push	r29
    28d2:	cf 93       	push	r28
    28d4:	0f 92       	push	r0
    28d6:	0f 92       	push	r0
    28d8:	cd b7       	in	r28, 0x3d	; 61
    28da:	de b7       	in	r29, 0x3e	; 62
    28dc:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    28de:	1a 82       	std	Y+2, r1	; 0x02
    28e0:	19 82       	std	Y+1, r1	; 0x01
    28e2:	00 e0       	ldi	r16, 0x00	; 0
    28e4:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    28e6:	6e 01       	movw	r12, r28
    28e8:	08 94       	sec
    28ea:	c1 1c       	adc	r12, r1
    28ec:	d1 1c       	adc	r13, r1
    28ee:	1f c0       	rjmp	.+62     	; 0x292e <vPolledQueueProducer+0x6a>
    28f0:	f7 01       	movw	r30, r14
    28f2:	80 81       	ld	r24, Z
    28f4:	91 81       	ldd	r25, Z+1	; 0x01
    28f6:	b6 01       	movw	r22, r12
    28f8:	40 e0       	ldi	r20, 0x00	; 0
    28fa:	50 e0       	ldi	r21, 0x00	; 0
    28fc:	20 e0       	ldi	r18, 0x00	; 0
    28fe:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <xQueueGenericSend>
    2902:	81 30       	cpi	r24, 0x01	; 1
    2904:	11 f0       	breq	.+4      	; 0x290a <vPolledQueueProducer+0x46>
    2906:	01 e0       	ldi	r16, 0x01	; 1
    2908:	11 c0       	rjmp	.+34     	; 0x292c <vPolledQueueProducer+0x68>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    290a:	00 23       	and	r16, r16
    290c:	51 f4       	brne	.+20     	; 0x2922 <vPolledQueueProducer+0x5e>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    290e:	0f b6       	in	r0, 0x3f	; 63
    2910:	f8 94       	cli
    2912:	0f 92       	push	r0
						xPollingProducerCount++;
    2914:	80 91 d1 08 	lds	r24, 0x08D1
    2918:	8f 5f       	subi	r24, 0xFF	; 255
    291a:	80 93 d1 08 	sts	0x08D1, r24
					portEXIT_CRITICAL();
    291e:	0f 90       	pop	r0
    2920:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	9a 81       	ldd	r25, Y+2	; 0x02
    2926:	01 96       	adiw	r24, 0x01	; 1
    2928:	9a 83       	std	Y+2, r25	; 0x02
    292a:	89 83       	std	Y+1, r24	; 0x01
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    292c:	1f 5f       	subi	r17, 0xFF	; 255
    292e:	13 30       	cpi	r17, 0x03	; 3
    2930:	fc f2       	brlt	.-66     	; 0x28f0 <vPolledQueueProducer+0x2c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2932:	83 e0       	ldi	r24, 0x03	; 3
    2934:	90 e0       	ldi	r25, 0x00	; 0
    2936:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vTaskDelay>
    293a:	10 e0       	ldi	r17, 0x00	; 0
    293c:	d9 cf       	rjmp	.-78     	; 0x28f0 <vPolledQueueProducer+0x2c>

0000293e <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    293e:	9f 92       	push	r9
    2940:	af 92       	push	r10
    2942:	bf 92       	push	r11
    2944:	cf 92       	push	r12
    2946:	df 92       	push	r13
    2948:	ef 92       	push	r14
    294a:	ff 92       	push	r15
    294c:	0f 93       	push	r16
    294e:	1f 93       	push	r17
    2950:	df 93       	push	r29
    2952:	cf 93       	push	r28
    2954:	0f 92       	push	r0
    2956:	0f 92       	push	r0
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
    295c:	98 2e       	mov	r9, r24
    295e:	c9 2e       	mov	r12, r25
    2960:	dd 24       	eor	r13, r13
    2962:	ee 24       	eor	r14, r14
    2964:	ff 24       	eor	r15, r15
	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2966:	5e 01       	movw	r10, r28
    2968:	08 94       	sec
    296a:	a1 1c       	adc	r10, r1
    296c:	b1 1c       	adc	r11, r1
    296e:	23 c0       	rjmp	.+70     	; 0x29b6 <vPolledQueueConsumer+0x78>
    2970:	f8 01       	movw	r30, r16
    2972:	80 81       	ld	r24, Z
    2974:	91 81       	ldd	r25, Z+1	; 0x01
    2976:	b5 01       	movw	r22, r10
    2978:	40 e0       	ldi	r20, 0x00	; 0
    297a:	50 e0       	ldi	r21, 0x00	; 0
    297c:	20 e0       	ldi	r18, 0x00	; 0
    297e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <xQueueGenericReceive>
    2982:	81 30       	cpi	r24, 0x01	; 1
    2984:	c1 f4       	brne	.+48     	; 0x29b6 <vPolledQueueConsumer+0x78>
			{
				if( usData != usExpectedValue )
    2986:	29 81       	ldd	r18, Y+1	; 0x01
    2988:	3a 81       	ldd	r19, Y+2	; 0x02
    298a:	2e 15       	cp	r18, r14
    298c:	3f 05       	cpc	r19, r15
    298e:	19 f0       	breq	.+6      	; 0x2996 <vPolledQueueConsumer+0x58>
    2990:	dd 24       	eor	r13, r13
    2992:	d3 94       	inc	r13
    2994:	0c c0       	rjmp	.+24     	; 0x29ae <vPolledQueueConsumer+0x70>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2996:	dd 20       	and	r13, r13
    2998:	51 f4       	brne	.+20     	; 0x29ae <vPolledQueueConsumer+0x70>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    299a:	0f b6       	in	r0, 0x3f	; 63
    299c:	f8 94       	cli
    299e:	0f 92       	push	r0
							xPollingConsumerCount++;
    29a0:	80 91 d0 08 	lds	r24, 0x08D0
    29a4:	8f 5f       	subi	r24, 0xFF	; 255
    29a6:	80 93 d0 08 	sts	0x08D0, r24
						portEXIT_CRITICAL();
    29aa:	0f 90       	pop	r0
    29ac:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    29ae:	79 01       	movw	r14, r18
    29b0:	08 94       	sec
    29b2:	e1 1c       	adc	r14, r1
    29b4:	f1 1c       	adc	r15, r1
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    29b6:	09 2d       	mov	r16, r9
    29b8:	1c 2d       	mov	r17, r12
    29ba:	f8 01       	movw	r30, r16
    29bc:	80 81       	ld	r24, Z
    29be:	91 81       	ldd	r25, Z+1	; 0x01
    29c0:	0e 94 0c 0b 	call	0x1618	; 0x1618 <uxQueueMessagesWaiting>
    29c4:	88 23       	and	r24, r24
    29c6:	a1 f6       	brne	.-88     	; 0x2970 <vPolledQueueConsumer+0x32>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    29c8:	8f ee       	ldi	r24, 0xEF	; 239
    29ca:	9f ef       	ldi	r25, 0xFF	; 255
    29cc:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vTaskDelay>
    29d0:	f2 cf       	rjmp	.-28     	; 0x29b6 <vPolledQueueConsumer+0x78>

000029d2 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    29d2:	80 91 d4 08 	lds	r24, 0x08D4
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    29d6:	10 92 d4 08 	sts	0x08D4, r1
    29da:	81 11       	cpse	r24, r1
    29dc:	81 e0       	ldi	r24, 0x01	; 1

	return xReturn;
}
    29de:	08 95       	ret

000029e0 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    29e0:	ef 92       	push	r14
    29e2:	ff 92       	push	r15
    29e4:	0f 93       	push	r16
    29e6:	1f 93       	push	r17
    29e8:	18 2f       	mov	r17, r24
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    29ea:	20 93 d5 08 	sts	0x08D5, r18
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    29ee:	cb 01       	movw	r24, r22
    29f0:	ba 01       	movw	r22, r20
    29f2:	48 e1       	ldi	r20, 0x18	; 24
    29f4:	0e 94 2e 02 	call	0x45c	; 0x45c <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    29f8:	01 2f       	mov	r16, r17
    29fa:	01 50       	subi	r16, 0x01	; 1
    29fc:	8d e5       	ldi	r24, 0x5D	; 93
    29fe:	95 e1       	ldi	r25, 0x15	; 21
    2a00:	63 e4       	ldi	r22, 0x43	; 67
    2a02:	72 e0       	ldi	r23, 0x02	; 2
    2a04:	45 e5       	ldi	r20, 0x55	; 85
    2a06:	50 e0       	ldi	r21, 0x00	; 0
    2a08:	20 e0       	ldi	r18, 0x00	; 0
    2a0a:	30 e0       	ldi	r19, 0x00	; 0
    2a0c:	ee 24       	eor	r14, r14
    2a0e:	ff 24       	eor	r15, r15
    2a10:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    2a14:	8a e1       	ldi	r24, 0x1A	; 26
    2a16:	95 e1       	ldi	r25, 0x15	; 21
    2a18:	69 e4       	ldi	r22, 0x49	; 73
    2a1a:	72 e0       	ldi	r23, 0x02	; 2
    2a1c:	45 e5       	ldi	r20, 0x55	; 85
    2a1e:	50 e0       	ldi	r21, 0x00	; 0
    2a20:	20 e0       	ldi	r18, 0x00	; 0
    2a22:	30 e0       	ldi	r19, 0x00	; 0
    2a24:	01 2f       	mov	r16, r17
    2a26:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <xTaskCreate>
}
    2a2a:	1f 91       	pop	r17
    2a2c:	0f 91       	pop	r16
    2a2e:	ff 90       	pop	r15
    2a30:	ef 90       	pop	r14
    2a32:	08 95       	ret

00002a34 <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2a34:	ef 92       	push	r14
    2a36:	ff 92       	push	r15
    2a38:	0f 93       	push	r16
    2a3a:	1f 93       	push	r17
    2a3c:	df 93       	push	r29
    2a3e:	cf 93       	push	r28
    2a40:	0f 92       	push	r0
    2a42:	cd b7       	in	r28, 0x3d	; 61
    2a44:	de b7       	in	r29, 0x3e	; 62
    2a46:	00 e0       	ldi	r16, 0x00	; 0
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2a48:	7e 01       	movw	r14, r28
    2a4a:	08 94       	sec
    2a4c:	e1 1c       	adc	r14, r1
    2a4e:	f1 1c       	adc	r15, r1
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2a50:	11 e4       	ldi	r17, 0x41	; 65
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2a52:	80 e0       	ldi	r24, 0x00	; 0
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	b7 01       	movw	r22, r14
    2a58:	4f ef       	ldi	r20, 0xFF	; 255
    2a5a:	5f ef       	ldi	r21, 0xFF	; 255
    2a5c:	0e 94 24 02 	call	0x448	; 0x448 <xSerialGetChar>
    2a60:	88 23       	and	r24, r24
    2a62:	51 f0       	breq	.+20     	; 0x2a78 <vComRxTask+0x44>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    2a64:	89 81       	ldd	r24, Y+1	; 0x01
    2a66:	81 17       	cp	r24, r17
    2a68:	11 f0       	breq	.+4      	; 0x2a6e <vComRxTask+0x3a>
    2a6a:	11 e0       	ldi	r17, 0x01	; 1
    2a6c:	09 c0       	rjmp	.+18     	; 0x2a80 <vComRxTask+0x4c>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    2a6e:	80 91 d5 08 	lds	r24, 0x08D5
    2a72:	8f 5f       	subi	r24, 0xFF	; 255
    2a74:	0e 94 24 01 	call	0x248	; 0x248 <vParTestToggleLED>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2a78:	1f 5f       	subi	r17, 0xFF	; 255
    2a7a:	19 35       	cpi	r17, 0x59	; 89
    2a7c:	51 f7       	brne	.-44     	; 0x2a52 <vComRxTask+0x1e>
    2a7e:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2a80:	80 91 d5 08 	lds	r24, 0x08D5
    2a84:	8f 5f       	subi	r24, 0xFF	; 255
    2a86:	60 e0       	ldi	r22, 0x00	; 0
    2a88:	0e 94 47 01 	call	0x28e	; 0x28e <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2a8c:	11 30       	cpi	r17, 0x01	; 1
    2a8e:	69 f4       	brne	.+26     	; 0x2aaa <vComRxTask+0x76>
    2a90:	07 c0       	rjmp	.+14     	; 0x2aa0 <vComRxTask+0x6c>
		{
			while( cByteRxed != comLAST_BYTE )
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    2a92:	80 e0       	ldi	r24, 0x00	; 0
    2a94:	90 e0       	ldi	r25, 0x00	; 0
    2a96:	b7 01       	movw	r22, r14
    2a98:	4f ef       	ldi	r20, 0xFF	; 255
    2a9a:	5f ef       	ldi	r21, 0xFF	; 255
    2a9c:	0e 94 24 02 	call	0x448	; 0x448 <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
    2aa0:	89 81       	ldd	r24, Y+1	; 0x01
    2aa2:	88 35       	cpi	r24, 0x58	; 88
    2aa4:	b1 f7       	brne	.-20     	; 0x2a92 <vComRxTask+0x5e>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    2aa6:	0f 5f       	subi	r16, 0xFF	; 255
    2aa8:	d3 cf       	rjmp	.-90     	; 0x2a50 <vComRxTask+0x1c>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    2aaa:	02 30       	cpi	r16, 0x02	; 2
    2aac:	8c f6       	brge	.-94     	; 0x2a50 <vComRxTask+0x1c>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    2aae:	80 91 d4 08 	lds	r24, 0x08D4
    2ab2:	8f 5f       	subi	r24, 0xFF	; 255
    2ab4:	80 93 d4 08 	sts	0x08D4, r24
    2ab8:	cb cf       	rjmp	.-106    	; 0x2a50 <vComRxTask+0x1c>

00002aba <vComTxTask>:
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
    2aba:	1f 93       	push	r17
    2abc:	11 e4       	ldi	r17, 0x41	; 65
    2abe:	0e c0       	rjmp	.+28     	; 0x2adc <vComTxTask+0x22>
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    2ac0:	80 e0       	ldi	r24, 0x00	; 0
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	61 2f       	mov	r22, r17
    2ac6:	40 e0       	ldi	r20, 0x00	; 0
    2ac8:	50 e0       	ldi	r21, 0x00	; 0
    2aca:	0e 94 06 02 	call	0x40c	; 0x40c <xSerialPutChar>
    2ace:	81 30       	cpi	r24, 0x01	; 1
    2ad0:	21 f4       	brne	.+8      	; 0x2ada <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    2ad2:	80 91 d5 08 	lds	r24, 0x08D5
    2ad6:	0e 94 24 01 	call	0x248	; 0x248 <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2ada:	1f 5f       	subi	r17, 0xFF	; 255
    2adc:	19 35       	cpi	r17, 0x59	; 89
    2ade:	84 f3       	brlt	.-32     	; 0x2ac0 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    2ae0:	80 91 d5 08 	lds	r24, 0x08D5
    2ae4:	60 e0       	ldi	r22, 0x00	; 0
    2ae6:	0e 94 47 01 	call	0x28e	; 0x28e <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    2aea:	0e 94 e6 03 	call	0x7cc	; 0x7cc <xTaskGetTickCount>

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2aee:	03 96       	adiw	r24, 0x03	; 3
    2af0:	66 e9       	ldi	r22, 0x96	; 150
    2af2:	70 e0       	ldi	r23, 0x00	; 0
    2af4:	0e 94 a4 15 	call	0x2b48	; 0x2b48 <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    2af8:	82 33       	cpi	r24, 0x32	; 50
    2afa:	91 05       	cpc	r25, r1
    2afc:	10 f4       	brcc	.+4      	; 0x2b02 <vComTxTask+0x48>
    2afe:	82 e3       	ldi	r24, 0x32	; 50
    2b00:	90 e0       	ldi	r25, 0x00	; 0
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
    2b02:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vTaskDelay>
    2b06:	11 e4       	ldi	r17, 0x41	; 65
    2b08:	db cf       	rjmp	.-74     	; 0x2ac0 <vComTxTask+0x6>

00002b0a <__mulsi3>:
    2b0a:	62 9f       	mul	r22, r18
    2b0c:	d0 01       	movw	r26, r0
    2b0e:	73 9f       	mul	r23, r19
    2b10:	f0 01       	movw	r30, r0
    2b12:	82 9f       	mul	r24, r18
    2b14:	e0 0d       	add	r30, r0
    2b16:	f1 1d       	adc	r31, r1
    2b18:	64 9f       	mul	r22, r20
    2b1a:	e0 0d       	add	r30, r0
    2b1c:	f1 1d       	adc	r31, r1
    2b1e:	92 9f       	mul	r25, r18
    2b20:	f0 0d       	add	r31, r0
    2b22:	83 9f       	mul	r24, r19
    2b24:	f0 0d       	add	r31, r0
    2b26:	74 9f       	mul	r23, r20
    2b28:	f0 0d       	add	r31, r0
    2b2a:	65 9f       	mul	r22, r21
    2b2c:	f0 0d       	add	r31, r0
    2b2e:	99 27       	eor	r25, r25
    2b30:	72 9f       	mul	r23, r18
    2b32:	b0 0d       	add	r27, r0
    2b34:	e1 1d       	adc	r30, r1
    2b36:	f9 1f       	adc	r31, r25
    2b38:	63 9f       	mul	r22, r19
    2b3a:	b0 0d       	add	r27, r0
    2b3c:	e1 1d       	adc	r30, r1
    2b3e:	f9 1f       	adc	r31, r25
    2b40:	bd 01       	movw	r22, r26
    2b42:	cf 01       	movw	r24, r30
    2b44:	11 24       	eor	r1, r1
    2b46:	08 95       	ret

00002b48 <__udivmodhi4>:
    2b48:	aa 1b       	sub	r26, r26
    2b4a:	bb 1b       	sub	r27, r27
    2b4c:	51 e1       	ldi	r21, 0x11	; 17
    2b4e:	07 c0       	rjmp	.+14     	; 0x2b5e <__udivmodhi4_ep>

00002b50 <__udivmodhi4_loop>:
    2b50:	aa 1f       	adc	r26, r26
    2b52:	bb 1f       	adc	r27, r27
    2b54:	a6 17       	cp	r26, r22
    2b56:	b7 07       	cpc	r27, r23
    2b58:	10 f0       	brcs	.+4      	; 0x2b5e <__udivmodhi4_ep>
    2b5a:	a6 1b       	sub	r26, r22
    2b5c:	b7 0b       	sbc	r27, r23

00002b5e <__udivmodhi4_ep>:
    2b5e:	88 1f       	adc	r24, r24
    2b60:	99 1f       	adc	r25, r25
    2b62:	5a 95       	dec	r21
    2b64:	a9 f7       	brne	.-22     	; 0x2b50 <__udivmodhi4_loop>
    2b66:	80 95       	com	r24
    2b68:	90 95       	com	r25
    2b6a:	bc 01       	movw	r22, r24
    2b6c:	cd 01       	movw	r24, r26
    2b6e:	08 95       	ret

00002b70 <__udivmodsi4>:
    2b70:	a1 e2       	ldi	r26, 0x21	; 33
    2b72:	1a 2e       	mov	r1, r26
    2b74:	aa 1b       	sub	r26, r26
    2b76:	bb 1b       	sub	r27, r27
    2b78:	fd 01       	movw	r30, r26
    2b7a:	0d c0       	rjmp	.+26     	; 0x2b96 <__udivmodsi4_ep>

00002b7c <__udivmodsi4_loop>:
    2b7c:	aa 1f       	adc	r26, r26
    2b7e:	bb 1f       	adc	r27, r27
    2b80:	ee 1f       	adc	r30, r30
    2b82:	ff 1f       	adc	r31, r31
    2b84:	a2 17       	cp	r26, r18
    2b86:	b3 07       	cpc	r27, r19
    2b88:	e4 07       	cpc	r30, r20
    2b8a:	f5 07       	cpc	r31, r21
    2b8c:	20 f0       	brcs	.+8      	; 0x2b96 <__udivmodsi4_ep>
    2b8e:	a2 1b       	sub	r26, r18
    2b90:	b3 0b       	sbc	r27, r19
    2b92:	e4 0b       	sbc	r30, r20
    2b94:	f5 0b       	sbc	r31, r21

00002b96 <__udivmodsi4_ep>:
    2b96:	66 1f       	adc	r22, r22
    2b98:	77 1f       	adc	r23, r23
    2b9a:	88 1f       	adc	r24, r24
    2b9c:	99 1f       	adc	r25, r25
    2b9e:	1a 94       	dec	r1
    2ba0:	69 f7       	brne	.-38     	; 0x2b7c <__udivmodsi4_loop>
    2ba2:	60 95       	com	r22
    2ba4:	70 95       	com	r23
    2ba6:	80 95       	com	r24
    2ba8:	90 95       	com	r25
    2baa:	9b 01       	movw	r18, r22
    2bac:	ac 01       	movw	r20, r24
    2bae:	bd 01       	movw	r22, r26
    2bb0:	cf 01       	movw	r24, r30
    2bb2:	08 95       	ret

00002bb4 <__divmodsi4>:
    2bb4:	97 fb       	bst	r25, 7
    2bb6:	09 2e       	mov	r0, r25
    2bb8:	05 26       	eor	r0, r21
    2bba:	0e d0       	rcall	.+28     	; 0x2bd8 <__divmodsi4_neg1>
    2bbc:	57 fd       	sbrc	r21, 7
    2bbe:	04 d0       	rcall	.+8      	; 0x2bc8 <__divmodsi4_neg2>
    2bc0:	d7 df       	rcall	.-82     	; 0x2b70 <__udivmodsi4>
    2bc2:	0a d0       	rcall	.+20     	; 0x2bd8 <__divmodsi4_neg1>
    2bc4:	00 1c       	adc	r0, r0
    2bc6:	38 f4       	brcc	.+14     	; 0x2bd6 <__divmodsi4_exit>

00002bc8 <__divmodsi4_neg2>:
    2bc8:	50 95       	com	r21
    2bca:	40 95       	com	r20
    2bcc:	30 95       	com	r19
    2bce:	21 95       	neg	r18
    2bd0:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd2:	4f 4f       	sbci	r20, 0xFF	; 255
    2bd4:	5f 4f       	sbci	r21, 0xFF	; 255

00002bd6 <__divmodsi4_exit>:
    2bd6:	08 95       	ret

00002bd8 <__divmodsi4_neg1>:
    2bd8:	f6 f7       	brtc	.-4      	; 0x2bd6 <__divmodsi4_exit>
    2bda:	90 95       	com	r25
    2bdc:	80 95       	com	r24
    2bde:	70 95       	com	r23
    2be0:	61 95       	neg	r22
    2be2:	7f 4f       	sbci	r23, 0xFF	; 255
    2be4:	8f 4f       	sbci	r24, 0xFF	; 255
    2be6:	9f 4f       	sbci	r25, 0xFF	; 255
    2be8:	08 95       	ret

00002bea <memcpy>:
    2bea:	fb 01       	movw	r30, r22
    2bec:	dc 01       	movw	r26, r24
    2bee:	02 c0       	rjmp	.+4      	; 0x2bf4 <memcpy+0xa>
    2bf0:	01 90       	ld	r0, Z+
    2bf2:	0d 92       	st	X+, r0
    2bf4:	41 50       	subi	r20, 0x01	; 1
    2bf6:	50 40       	sbci	r21, 0x00	; 0
    2bf8:	d8 f7       	brcc	.-10     	; 0x2bf0 <memcpy+0x6>
    2bfa:	08 95       	ret

00002bfc <__eerd_block_m2560>:
    2bfc:	dc 01       	movw	r26, r24
    2bfe:	cb 01       	movw	r24, r22

00002c00 <__eerd_blraw_m2560>:
    2c00:	fc 01       	movw	r30, r24
    2c02:	f9 99       	sbic	0x1f, 1	; 31
    2c04:	fe cf       	rjmp	.-4      	; 0x2c02 <__eerd_blraw_m2560+0x2>
    2c06:	06 c0       	rjmp	.+12     	; 0x2c14 <__eerd_blraw_m2560+0x14>
    2c08:	f2 bd       	out	0x22, r31	; 34
    2c0a:	e1 bd       	out	0x21, r30	; 33
    2c0c:	f8 9a       	sbi	0x1f, 0	; 31
    2c0e:	31 96       	adiw	r30, 0x01	; 1
    2c10:	00 b4       	in	r0, 0x20	; 32
    2c12:	0d 92       	st	X+, r0
    2c14:	41 50       	subi	r20, 0x01	; 1
    2c16:	50 40       	sbci	r21, 0x00	; 0
    2c18:	b8 f7       	brcc	.-18     	; 0x2c08 <__eerd_blraw_m2560+0x8>
    2c1a:	08 95       	ret

00002c1c <__eewr_byte_m2560>:
    2c1c:	26 2f       	mov	r18, r22

00002c1e <__eewr_r18_m2560>:
    2c1e:	f9 99       	sbic	0x1f, 1	; 31
    2c20:	fe cf       	rjmp	.-4      	; 0x2c1e <__eewr_r18_m2560>
    2c22:	1f ba       	out	0x1f, r1	; 31
    2c24:	92 bd       	out	0x22, r25	; 34
    2c26:	81 bd       	out	0x21, r24	; 33
    2c28:	20 bd       	out	0x20, r18	; 32
    2c2a:	0f b6       	in	r0, 0x3f	; 63
    2c2c:	f8 94       	cli
    2c2e:	fa 9a       	sbi	0x1f, 2	; 31
    2c30:	f9 9a       	sbi	0x1f, 1	; 31
    2c32:	0f be       	out	0x3f, r0	; 63
    2c34:	01 96       	adiw	r24, 0x01	; 1
    2c36:	08 95       	ret

00002c38 <_exit>:
    2c38:	f8 94       	cli

00002c3a <__stop_program>:
    2c3a:	ff cf       	rjmp	.-2      	; 0x2c3a <__stop_program>


rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800200  0000259a  0000262e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000259a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000067c  00800218  00800218  00002646  2**0
                  ALLOC
  3 .debug_aranges 00000140  00000000  00000000  00002646  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000007fd  00000000  00000000  00002786  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003019  00000000  00000000  00002f83  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000c74  00000000  00000000  00005f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002fc1  00000000  00000000  00006c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000600  00000000  00000000  00009bd4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000142a  00000000  00000000  0000a1d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001e32  00000000  00000000  0000b5fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  0000d430  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 44 12 	jmp	0x2488	; 0x2488 <__vector_17>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 7b 01 	jmp	0x2f6	; 0x2f6 <__vector_36>
      94:	0c 94 34 01 	jmp	0x268	; 0x268 <__vector_37>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ea e9       	ldi	r30, 0x9A	; 154
      fc:	f5 e2       	ldi	r31, 0x25	; 37
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 31       	cpi	r26, 0x18	; 24
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	18 e0       	ldi	r17, 0x08	; 8
     110:	a8 e1       	ldi	r26, 0x18	; 24
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a4 39       	cpi	r26, 0x94	; 148
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 b3 00 	call	0x166	; 0x166 <main>
     122:	0c 94 cb 12 	jmp	0x2596	; 0x2596 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	//vCoRoutineSchedule();
	PORTE = 0x01;
     12a:	81 e0       	ldi	r24, 0x01	; 1
     12c:	8e b9       	out	0x0e, r24	; 14
}
     12e:	08 95       	ret

00000130 <ledTest>:
	return 0;
}
/*-----------------------------------------------------------*/

void ledTest( void *pvParameters )
{
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29

  while(1)
  {
    PORTE = 0x01;
     136:	11 e0       	ldi	r17, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     138:	c0 e9       	ldi	r28, 0x90	; 144
     13a:	d1 e0       	ldi	r29, 0x01	; 1
     13c:	1e b9       	out	0x0e, r17	; 14
     13e:	88 e8       	ldi	r24, 0x88	; 136
     140:	93 e1       	ldi	r25, 0x13	; 19
     142:	fe 01       	movw	r30, r28
     144:	31 97       	sbiw	r30, 0x01	; 1
     146:	f1 f7       	brne	.-4      	; 0x144 <ledTest+0x14>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     148:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     14a:	d9 f7       	brne	.-10     	; 0x142 <ledTest+0x12>
    _delay_ms(500);
    PORTE = 0x00;
     14c:	1e b8       	out	0x0e, r1	; 14
     14e:	88 e8       	ldi	r24, 0x88	; 136
     150:	93 e1       	ldi	r25, 0x13	; 19
     152:	fe 01       	movw	r30, r28
     154:	31 97       	sbiw	r30, 0x01	; 1
     156:	f1 f7       	brne	.-4      	; 0x154 <ledTest+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     158:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     15a:	d9 f7       	brne	.-10     	; 0x152 <ledTest+0x22>
    _delay_ms(500);
	vTaskDelay(100);
     15c:	84 e6       	ldi	r24, 0x64	; 100
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	0e 94 a2 08 	call	0x1144	; 0x1144 <vTaskDelay>
     164:	eb cf       	rjmp	.-42     	; 0x13c <ledTest+0xc>

00000166 <main>:

#include <util/delay.h>
void ledTest( void *pvParameters );

short main( void )
{  
     166:	ef 92       	push	r14
     168:	ff 92       	push	r15
     16a:	0f 93       	push	r16
	//vStartRegTestTasks();

	/* Create the tasks defined within this file. */
	//xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY-1, NULL );
  
  xTaskCreate( ledTest, "Testing", 2*configMINIMAL_STACK_SIZE, NULL, configMAX_PRIORITIES-1, NULL );
     16c:	88 e9       	ldi	r24, 0x98	; 152
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	72 e0       	ldi	r23, 0x02	; 2
     174:	4a ea       	ldi	r20, 0xAA	; 170
     176:	50 e0       	ldi	r21, 0x00	; 0
     178:	20 e0       	ldi	r18, 0x00	; 0
     17a:	30 e0       	ldi	r19, 0x00	; 0
     17c:	03 e0       	ldi	r16, 0x03	; 3
     17e:	ee 24       	eor	r14, r14
     180:	ff 24       	eor	r15, r15
     182:	0e 94 a6 09 	call	0x134c	; 0x134c <xTaskCreate>
  // DDRE = 0xFF;
  // while(1)
  // {
    // PORTE = 0x00;
  // }
	DDRE = 0xFF;
     186:	8f ef       	ldi	r24, 0xFF	; 255
     188:	8d b9       	out	0x0d, r24	; 13
	PORTE = 0x00;
     18a:	1e b8       	out	0x0e, r1	; 14
     18c:	88 e8       	ldi	r24, 0x88	; 136
     18e:	93 e1       	ldi	r25, 0x13	; 19
     190:	20 e9       	ldi	r18, 0x90	; 144
     192:	31 e0       	ldi	r19, 0x01	; 1
     194:	f9 01       	movw	r30, r18
     196:	31 97       	sbiw	r30, 0x01	; 1
     198:	f1 f7       	brne	.-4      	; 0x196 <main+0x30>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     19a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     19c:	d9 f7       	brne	.-10     	; 0x194 <main+0x2e>
	_delay_ms(500);
	vTaskStartScheduler();
     19e:	0e 94 9f 0a 	call	0x153e	; 0x153e <vTaskStartScheduler>

	return 0;
}
     1a2:	80 e0       	ldi	r24, 0x00	; 0
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	0f 91       	pop	r16
     1a8:	ff 90       	pop	r15
     1aa:	ef 90       	pop	r14
     1ac:	08 95       	ret

000001ae <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     1ae:	8f ef       	ldi	r24, 0xFF	; 255
     1b0:	80 93 08 02 	sts	0x0208, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     1b4:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     1b6:	80 91 08 02 	lds	r24, 0x0208
     1ba:	85 b9       	out	0x05, r24	; 5
}
     1bc:	08 95       	ret

000001be <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     1be:	1f 93       	push	r17
     1c0:	28 2f       	mov	r18, r24
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     1c2:	88 30       	cpi	r24, 0x08	; 8
     1c4:	e8 f4       	brcc	.+58     	; 0x200 <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     1c6:	81 e0       	ldi	r24, 0x01	; 1
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <vParTestToggleLED+0x12>
     1cc:	88 0f       	add	r24, r24
     1ce:	99 1f       	adc	r25, r25
     1d0:	2a 95       	dec	r18
     1d2:	e2 f7       	brpl	.-8      	; 0x1cc <vParTestToggleLED+0xe>
     1d4:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     1d6:	0e 94 9b 03 	call	0x736	; 0x736 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     1da:	80 91 08 02 	lds	r24, 0x0208
     1de:	81 23       	and	r24, r17
     1e0:	29 f0       	breq	.+10     	; 0x1ec <vParTestToggleLED+0x2e>
			{
				ucCurrentOutputValue &= ~ucBit;
     1e2:	80 91 08 02 	lds	r24, 0x0208
     1e6:	10 95       	com	r17
     1e8:	18 23       	and	r17, r24
     1ea:	03 c0       	rjmp	.+6      	; 0x1f2 <vParTestToggleLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1ec:	80 91 08 02 	lds	r24, 0x0208
     1f0:	18 2b       	or	r17, r24
     1f2:	10 93 08 02 	sts	0x0208, r17
			}

			PORTB = ucCurrentOutputValue;
     1f6:	80 91 08 02 	lds	r24, 0x0208
     1fa:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
     1fc:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
	}
}
     200:	1f 91       	pop	r17
     202:	08 95       	ret

00000204 <vParTestSetLED>:
	PORTB = ucCurrentOutputValue;
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     204:	0f 93       	push	r16
     206:	1f 93       	push	r17
     208:	28 2f       	mov	r18, r24
     20a:	06 2f       	mov	r16, r22
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     20c:	88 30       	cpi	r24, 0x08	; 8
     20e:	d8 f4       	brcc	.+54     	; 0x246 <vParTestSetLED+0x42>
	{
		ucBit <<= uxLED;	
     210:	81 e0       	ldi	r24, 0x01	; 1
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	02 c0       	rjmp	.+4      	; 0x21a <vParTestSetLED+0x16>
     216:	88 0f       	add	r24, r24
     218:	99 1f       	adc	r25, r25
     21a:	2a 95       	dec	r18
     21c:	e2 f7       	brpl	.-8      	; 0x216 <vParTestSetLED+0x12>
     21e:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     220:	0e 94 9b 03 	call	0x736	; 0x736 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
     224:	01 30       	cpi	r16, 0x01	; 1
     226:	29 f4       	brne	.+10     	; 0x232 <vParTestSetLED+0x2e>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     228:	80 91 08 02 	lds	r24, 0x0208
     22c:	10 95       	com	r17
     22e:	18 23       	and	r17, r24
     230:	03 c0       	rjmp	.+6      	; 0x238 <vParTestSetLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     232:	80 91 08 02 	lds	r24, 0x0208
     236:	18 2b       	or	r17, r24
     238:	10 93 08 02 	sts	0x0208, r17
			}

			PORTB = ucCurrentOutputValue;
     23c:	80 91 08 02 	lds	r24, 0x0208
     240:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
     242:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
	}
}
     246:	1f 91       	pop	r17
     248:	0f 91       	pop	r16
     24a:	08 95       	ret

0000024c <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     24c:	0f b6       	in	r0, 0x3f	; 63
     24e:	f8 94       	cli
     250:	0f 92       	push	r0
	{
		vInterruptOff();
     252:	e9 ec       	ldi	r30, 0xC9	; 201
     254:	f0 e0       	ldi	r31, 0x00	; 0
     256:	80 81       	ld	r24, Z
     258:	8f 7d       	andi	r24, 0xDF	; 223
     25a:	80 83       	st	Z, r24
		ucByte = UCSR1B;
     25c:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     25e:	8f 77       	andi	r24, 0x7F	; 127
		UCSR1B = ucByte;
     260:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
}
     266:	08 95       	ret

00000268 <__vector_37>:
	}
}
/*-----------------------------------------------------------*/

SIGNAL( USART1_UDRE_vect )  //Changed from old name in ATmega323 (SIG_UART_DATA) to new name in ATmega3560 (USART1_UDRE_vect)
{
     268:	1f 92       	push	r1
     26a:	0f 92       	push	r0
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	0f 92       	push	r0
     270:	0b b6       	in	r0, 0x3b	; 59
     272:	0f 92       	push	r0
     274:	11 24       	eor	r1, r1
     276:	2f 93       	push	r18
     278:	3f 93       	push	r19
     27a:	4f 93       	push	r20
     27c:	5f 93       	push	r21
     27e:	6f 93       	push	r22
     280:	7f 93       	push	r23
     282:	8f 93       	push	r24
     284:	9f 93       	push	r25
     286:	af 93       	push	r26
     288:	bf 93       	push	r27
     28a:	ef 93       	push	r30
     28c:	ff 93       	push	r31
     28e:	df 93       	push	r29
     290:	cf 93       	push	r28
     292:	0f 92       	push	r0
     294:	0f 92       	push	r0
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     29a:	80 91 1a 02 	lds	r24, 0x021A
     29e:	90 91 1b 02 	lds	r25, 0x021B
     2a2:	be 01       	movw	r22, r28
     2a4:	6f 5f       	subi	r22, 0xFF	; 255
     2a6:	7f 4f       	sbci	r23, 0xFF	; 255
     2a8:	ae 01       	movw	r20, r28
     2aa:	4e 5f       	subi	r20, 0xFE	; 254
     2ac:	5f 4f       	sbci	r21, 0xFF	; 255
     2ae:	0e 94 42 0c 	call	0x1884	; 0x1884 <xQueueReceiveFromISR>
     2b2:	81 30       	cpi	r24, 0x01	; 1
     2b4:	21 f4       	brne	.+8      	; 0x2be <__vector_37+0x56>
	{
		/* Send the next character queued for Tx. */
		UDR1 = cChar;
     2b6:	89 81       	ldd	r24, Y+1	; 0x01
     2b8:	80 93 ce 00 	sts	0x00CE, r24
     2bc:	05 c0       	rjmp	.+10     	; 0x2c8 <__vector_37+0x60>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     2be:	80 91 c9 00 	lds	r24, 0x00C9
     2c2:	8f 7d       	andi	r24, 0xDF	; 223
     2c4:	80 93 c9 00 	sts	0x00C9, r24
	}
}
     2c8:	0f 90       	pop	r0
     2ca:	0f 90       	pop	r0
     2cc:	cf 91       	pop	r28
     2ce:	df 91       	pop	r29
     2d0:	ff 91       	pop	r31
     2d2:	ef 91       	pop	r30
     2d4:	bf 91       	pop	r27
     2d6:	af 91       	pop	r26
     2d8:	9f 91       	pop	r25
     2da:	8f 91       	pop	r24
     2dc:	7f 91       	pop	r23
     2de:	6f 91       	pop	r22
     2e0:	5f 91       	pop	r21
     2e2:	4f 91       	pop	r20
     2e4:	3f 91       	pop	r19
     2e6:	2f 91       	pop	r18
     2e8:	0f 90       	pop	r0
     2ea:	0b be       	out	0x3b, r0	; 59
     2ec:	0f 90       	pop	r0
     2ee:	0f be       	out	0x3f, r0	; 63
     2f0:	0f 90       	pop	r0
     2f2:	1f 90       	pop	r1
     2f4:	18 95       	reti

000002f6 <__vector_36>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART1_RX_vect )  //Changed from old name in ATmega323 (SIG_UART_RECV) to new name in ATmega3560 (USART1_RX_vect)
{
     2f6:	1f 92       	push	r1
     2f8:	0f 92       	push	r0
     2fa:	0f b6       	in	r0, 0x3f	; 63
     2fc:	0f 92       	push	r0
     2fe:	0b b6       	in	r0, 0x3b	; 59
     300:	0f 92       	push	r0
     302:	11 24       	eor	r1, r1
     304:	2f 93       	push	r18
     306:	3f 93       	push	r19
     308:	4f 93       	push	r20
     30a:	5f 93       	push	r21
     30c:	6f 93       	push	r22
     30e:	7f 93       	push	r23
     310:	8f 93       	push	r24
     312:	9f 93       	push	r25
     314:	af 93       	push	r26
     316:	bf 93       	push	r27
     318:	ef 93       	push	r30
     31a:	ff 93       	push	r31
     31c:	df 93       	push	r29
     31e:	cf 93       	push	r28
     320:	0f 92       	push	r0
     322:	0f 92       	push	r0
     324:	cd b7       	in	r28, 0x3d	; 61
     326:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     328:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR1;
     32a:	80 91 ce 00 	lds	r24, 0x00CE
     32e:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     330:	80 91 18 02 	lds	r24, 0x0218
     334:	90 91 19 02 	lds	r25, 0x0219
     338:	be 01       	movw	r22, r28
     33a:	6f 5f       	subi	r22, 0xFF	; 255
     33c:	7f 4f       	sbci	r23, 0xFF	; 255
     33e:	ae 01       	movw	r20, r28
     340:	4e 5f       	subi	r20, 0xFE	; 254
     342:	5f 4f       	sbci	r21, 0xFF	; 255
     344:	20 e0       	ldi	r18, 0x00	; 0
     346:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     34a:	8a 81       	ldd	r24, Y+2	; 0x02
     34c:	88 23       	and	r24, r24
     34e:	11 f0       	breq	.+4      	; 0x354 <__vector_36+0x5e>
	{
		taskYIELD();
     350:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
	}
}
     354:	0f 90       	pop	r0
     356:	0f 90       	pop	r0
     358:	cf 91       	pop	r28
     35a:	df 91       	pop	r29
     35c:	ff 91       	pop	r31
     35e:	ef 91       	pop	r30
     360:	bf 91       	pop	r27
     362:	af 91       	pop	r26
     364:	9f 91       	pop	r25
     366:	8f 91       	pop	r24
     368:	7f 91       	pop	r23
     36a:	6f 91       	pop	r22
     36c:	5f 91       	pop	r21
     36e:	4f 91       	pop	r20
     370:	3f 91       	pop	r19
     372:	2f 91       	pop	r18
     374:	0f 90       	pop	r0
     376:	0b be       	out	0x3b, r0	; 59
     378:	0f 90       	pop	r0
     37a:	0f be       	out	0x3f, r0	; 63
     37c:	0f 90       	pop	r0
     37e:	1f 90       	pop	r1
     380:	18 95       	reti

00000382 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     382:	df 93       	push	r29
     384:	cf 93       	push	r28
     386:	0f 92       	push	r0
     388:	cd b7       	in	r28, 0x3d	; 61
     38a:	de b7       	in	r29, 0x3e	; 62
     38c:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     38e:	80 91 1a 02 	lds	r24, 0x021A
     392:	90 91 1b 02 	lds	r25, 0x021B
     396:	be 01       	movw	r22, r28
     398:	6f 5f       	subi	r22, 0xFF	; 255
     39a:	7f 4f       	sbci	r23, 0xFF	; 255
     39c:	20 e0       	ldi	r18, 0x00	; 0
     39e:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xQueueGenericSend>
     3a2:	81 30       	cpi	r24, 0x01	; 1
     3a4:	11 f0       	breq	.+4      	; 0x3aa <xSerialPutChar+0x28>
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	06 c0       	rjmp	.+12     	; 0x3b6 <xSerialPutChar+0x34>
	{
		return pdFAIL;
	}

	vInterruptOn();
     3aa:	80 91 c9 00 	lds	r24, 0x00C9
     3ae:	80 62       	ori	r24, 0x20	; 32
     3b0:	80 93 c9 00 	sts	0x00C9, r24
     3b4:	81 e0       	ldi	r24, 0x01	; 1

	return pdPASS;
}
     3b6:	0f 90       	pop	r0
     3b8:	cf 91       	pop	r28
     3ba:	df 91       	pop	r29
     3bc:	08 95       	ret

000003be <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     3be:	80 91 18 02 	lds	r24, 0x0218
     3c2:	90 91 19 02 	lds	r25, 0x0219
     3c6:	20 e0       	ldi	r18, 0x00	; 0
     3c8:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xQueueGenericReceive>
     3cc:	81 11       	cpse	r24, r1
     3ce:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
     3d0:	08 95       	ret

000003d2 <xSerialPortInitMinimal>:
	UCSR1B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     3d2:	df 92       	push	r13
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
     3da:	1f 93       	push	r17
     3dc:	7b 01       	movw	r14, r22
     3de:	8c 01       	movw	r16, r24
     3e0:	d4 2e       	mov	r13, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     3e2:	0f b6       	in	r0, 0x3f	; 63
     3e4:	f8 94       	cli
     3e6:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     3e8:	84 2f       	mov	r24, r20
     3ea:	61 e0       	ldi	r22, 0x01	; 1
     3ec:	40 e0       	ldi	r20, 0x00	; 0
     3ee:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <xQueueGenericCreate>
     3f2:	90 93 19 02 	sts	0x0219, r25
     3f6:	80 93 18 02 	sts	0x0218, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     3fa:	8d 2d       	mov	r24, r13
     3fc:	61 e0       	ldi	r22, 0x01	; 1
     3fe:	40 e0       	ldi	r20, 0x00	; 0
     400:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <xQueueGenericCreate>
     404:	90 93 1b 02 	sts	0x021B, r25
     408:	80 93 1a 02 	sts	0x021A, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     40c:	94 e0       	ldi	r25, 0x04	; 4
     40e:	ee 0c       	add	r14, r14
     410:	ff 1c       	adc	r15, r15
     412:	00 1f       	adc	r16, r16
     414:	11 1f       	adc	r17, r17
     416:	9a 95       	dec	r25
     418:	d1 f7       	brne	.-12     	; 0x40e <xSerialPortInitMinimal+0x3c>
     41a:	60 e0       	ldi	r22, 0x00	; 0
     41c:	74 e2       	ldi	r23, 0x24	; 36
     41e:	84 ef       	ldi	r24, 0xF4	; 244
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	a8 01       	movw	r20, r16
     424:	97 01       	movw	r18, r14
     426:	0e 94 a0 12 	call	0x2540	; 0x2540 <__udivmodsi4>
     42a:	21 50       	subi	r18, 0x01	; 1
     42c:	30 40       	sbci	r19, 0x00	; 0
     42e:	40 40       	sbci	r20, 0x00	; 0
     430:	50 40       	sbci	r21, 0x00	; 0

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR1L = ucByte;
     432:	20 93 cc 00 	sts	0x00CC, r18

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     436:	23 2f       	mov	r18, r19
     438:	34 2f       	mov	r19, r20
     43a:	45 2f       	mov	r20, r21
     43c:	55 27       	eor	r21, r21
		UBRR1H = ucByte;
     43e:	20 93 cd 00 	sts	0x00CD, r18

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR1B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     442:	88 e9       	ldi	r24, 0x98	; 152
     444:	80 93 c9 00 	sts	0x00C9, r24

		/* Set the data bits to 8. */
		UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     448:	86 e8       	ldi	r24, 0x86	; 134
     44a:	80 93 ca 00 	sts	0x00CA, r24
	}
	portEXIT_CRITICAL();
     44e:	0f 90       	pop	r0
     450:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	1f 91       	pop	r17
     458:	0f 91       	pop	r16
     45a:	ff 90       	pop	r15
     45c:	ef 90       	pop	r14
     45e:	df 90       	pop	r13
     460:	08 95       	ret

00000462 <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	80 91 1c 02 	lds	r24, 0x021C
     468:	88 23       	and	r24, r24
     46a:	09 f4       	brne	.+2      	; 0x46e <xAreRegTestTasksStillRunning+0xc>
     46c:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     46e:	89 2f       	mov	r24, r25
     470:	08 95       	ret

00000472 <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     472:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     474:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     476:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     478:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     47a:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     47c:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     47e:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     480:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     482:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     484:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     486:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     488:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     48a:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     48c:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     48e:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     490:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     492:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     494:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     496:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     498:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     49a:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     49c:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     49e:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     4a0:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     4a2:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     4a4:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     4a6:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     4a8:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     4aa:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     4ac:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     4ae:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     4b0:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     4b2:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     4b4:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     4b6:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     4b8:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     4ba:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     4bc:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     4be:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     4c0:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     4c2:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     4c4:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     4c6:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     4c8:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     4ca:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     4cc:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     4ce:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     4d0:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	6"			);
     4d4:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     4d6:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     4d8:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	7"			);
     4dc:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     4de:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     4e0:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	8"			);
     4e4:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     4e6:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     4e8:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	9"			);
     4ec:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     4ee:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     4f0:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	10"			);
     4f4:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     4f6:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     4f8:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	11"			);
     4fc:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     4fe:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     500:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	12"			);
     504:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     506:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     508:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	13"			);
     50c:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     50e:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     510:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	14"			);
     514:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     516:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     518:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	15"			);
     51c:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     51e:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     520:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	16"			);
     524:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     526:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     528:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	17"			);
     52c:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     52e:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     530:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	18"			);
     534:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     536:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     538:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	19"			);
     53c:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     53e:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     540:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	20"			);
     544:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     546:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     548:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	21"			);
     54c:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     54e:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     550:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	22"			);
     554:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     556:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     558:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	23"			);
     55c:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     55e:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     560:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	24"			);
     564:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     566:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     568:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	25"			);
     56c:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     56e:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     570:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	26"			);
     574:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     576:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     578:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	27"			);
     57c:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     57e:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     580:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	28"			);
     584:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     586:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     588:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	29"			);
     58c:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     58e:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     590:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	30"			);
     594:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     596:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     598:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	31"			);
     59c:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     59e:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     5a0:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	32"			);
     5a4:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     5a6:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     5a8:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	33"			);
     5ac:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     5ae:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     5b0:	00 92 1c 02 	sts	0x021C, r0
     5b4:	5e cf       	rjmp	.-324    	; 0x472 <prvRegisterCheck1>

000005b6 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     5b6:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     5b8:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     5ba:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     5bc:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     5be:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     5c0:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     5c2:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     5c4:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     5c6:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     5c8:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     5ca:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     5cc:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     5ce:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     5d0:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     5d2:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     5d4:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     5d6:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     5d8:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     5da:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     5dc:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     5de:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     5e0:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     5e2:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     5e4:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     5e6:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     5e8:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     5ea:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     5ec:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     5ee:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     5f0:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     5f2:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     5f4:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     5f6:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     5f8:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     5fa:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     5fc:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     5fe:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     600:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     602:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     604:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     606:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     608:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     60a:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     60c:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     60e:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     610:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     612:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     614:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	2"			);
     618:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     61a:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     61c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	3"			);
     620:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     622:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     624:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	4"			);
     628:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     62a:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     62c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	5"			);
     630:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     632:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     634:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	6"			);
     638:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     63a:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     63c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	7"			);
     640:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     642:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     644:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	8"			);
     648:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     64a:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     64c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	9"			);
     650:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     652:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     654:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	10"			);
     658:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     65a:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     65c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	11"			);
     660:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     662:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     664:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	12"			);
     668:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     66a:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     66c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	13"			);
     670:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     672:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     674:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	14"			);
     678:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     67a:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     67c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	15"			);
     680:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     682:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     684:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	16"			);
     688:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     68a:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     68c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	17"			);
     690:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     692:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     694:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	18"			);
     698:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     69a:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     69c:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	19"			);
     6a0:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     6a2:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     6a4:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	20"			);
     6a8:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     6aa:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     6ac:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	21"			);
     6b0:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     6b2:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     6b4:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	22"			);
     6b8:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     6ba:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     6bc:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	23"			);
     6c0:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     6c2:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     6c4:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	24"			);
     6c8:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     6ca:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     6cc:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	25"			);
     6d0:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     6d2:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     6d4:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	26"			);
     6d8:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     6da:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     6dc:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	27"			);
     6e0:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     6e2:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     6e4:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	28"			);
     6e8:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     6ea:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     6ec:	00 92 1c 02 	sts	0x021C, r0
		asm(	"LDI	r31,	29"			);
     6f0:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     6f2:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     6f4:	00 92 1c 02 	sts	0x021C, r0
     6f8:	5e cf       	rjmp	.-324    	; 0x5b6 <prvRegisterCheck2>

000006fa <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     6fa:	ef 92       	push	r14
     6fc:	ff 92       	push	r15
     6fe:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     700:	89 e3       	ldi	r24, 0x39	; 57
     702:	92 e0       	ldi	r25, 0x02	; 2
     704:	69 e0       	ldi	r22, 0x09	; 9
     706:	72 e0       	ldi	r23, 0x02	; 2
     708:	45 e5       	ldi	r20, 0x55	; 85
     70a:	50 e0       	ldi	r21, 0x00	; 0
     70c:	20 e0       	ldi	r18, 0x00	; 0
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	00 e0       	ldi	r16, 0x00	; 0
     712:	ee 24       	eor	r14, r14
     714:	ff 24       	eor	r15, r15
     716:	0e 94 a6 09 	call	0x134c	; 0x134c <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     71a:	8b ed       	ldi	r24, 0xDB	; 219
     71c:	92 e0       	ldi	r25, 0x02	; 2
     71e:	6e e0       	ldi	r22, 0x0E	; 14
     720:	72 e0       	ldi	r23, 0x02	; 2
     722:	45 e5       	ldi	r20, 0x55	; 85
     724:	50 e0       	ldi	r21, 0x00	; 0
     726:	20 e0       	ldi	r18, 0x00	; 0
     728:	30 e0       	ldi	r19, 0x00	; 0
     72a:	0e 94 a6 09 	call	0x134c	; 0x134c <xTaskCreate>
}
     72e:	0f 91       	pop	r16
     730:	ff 90       	pop	r15
     732:	ef 90       	pop	r14
     734:	08 95       	ret

00000736 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     736:	80 91 1f 02 	lds	r24, 0x021F
     73a:	8f 5f       	subi	r24, 0xFF	; 255
     73c:	80 93 1f 02 	sts	0x021F, r24
}
     740:	08 95       	ret

00000742 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     742:	0f b6       	in	r0, 0x3f	; 63
     744:	f8 94       	cli
     746:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     748:	20 91 22 02 	lds	r18, 0x0222
     74c:	30 91 23 02 	lds	r19, 0x0223
	}
	portTICK_TYPE_EXIT_CRITICAL();
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     754:	c9 01       	movw	r24, r18
     756:	08 95       	ret

00000758 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     758:	20 91 22 02 	lds	r18, 0x0222
     75c:	30 91 23 02 	lds	r19, 0x0223
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     760:	c9 01       	movw	r24, r18
     762:	08 95       	ret

00000764 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     764:	80 91 28 02 	lds	r24, 0x0228
}
     768:	08 95       	ret

0000076a <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     76a:	00 97       	sbiw	r24, 0x00	; 0
     76c:	21 f4       	brne	.+8      	; 0x776 <pcTaskGetName+0xc>
     76e:	80 91 1d 02 	lds	r24, 0x021D
     772:	90 91 1e 02 	lds	r25, 0x021E
     776:	9c 01       	movw	r18, r24
     778:	27 5e       	subi	r18, 0xE7	; 231
     77a:	3f 4f       	sbci	r19, 0xFF	; 255
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     77c:	c9 01       	movw	r24, r18
     77e:	08 95       	ret

00000780 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     780:	80 91 1f 02 	lds	r24, 0x021F
     784:	88 23       	and	r24, r24
     786:	21 f0       	breq	.+8      	; 0x790 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	80 93 21 02 	sts	0x0221, r24
     78e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     790:	10 92 21 02 	sts	0x0221, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     794:	20 91 20 02 	lds	r18, 0x0220
     798:	99 e0       	ldi	r25, 0x09	; 9
     79a:	01 c0       	rjmp	.+2      	; 0x79e <vTaskSwitchContext+0x1e>
     79c:	21 50       	subi	r18, 0x01	; 1
     79e:	29 9f       	mul	r18, r25
     7a0:	d0 01       	movw	r26, r0
     7a2:	11 24       	eor	r1, r1
     7a4:	a2 5d       	subi	r26, 0xD2	; 210
     7a6:	bd 4f       	sbci	r27, 0xFD	; 253
     7a8:	8c 91       	ld	r24, X
     7aa:	88 23       	and	r24, r24
     7ac:	b9 f3       	breq	.-18     	; 0x79c <vTaskSwitchContext+0x1c>
     7ae:	11 96       	adiw	r26, 0x01	; 1
     7b0:	ed 91       	ld	r30, X+
     7b2:	fc 91       	ld	r31, X
     7b4:	12 97       	sbiw	r26, 0x02	; 2
     7b6:	02 80       	ldd	r0, Z+2	; 0x02
     7b8:	f3 81       	ldd	r31, Z+3	; 0x03
     7ba:	e0 2d       	mov	r30, r0
     7bc:	12 96       	adiw	r26, 0x02	; 2
     7be:	fc 93       	st	X, r31
     7c0:	ee 93       	st	-X, r30
     7c2:	11 97       	sbiw	r26, 0x01	; 1
     7c4:	cd 01       	movw	r24, r26
     7c6:	03 96       	adiw	r24, 0x03	; 3
     7c8:	e8 17       	cp	r30, r24
     7ca:	f9 07       	cpc	r31, r25
     7cc:	31 f4       	brne	.+12     	; 0x7da <vTaskSwitchContext+0x5a>
     7ce:	82 81       	ldd	r24, Z+2	; 0x02
     7d0:	93 81       	ldd	r25, Z+3	; 0x03
     7d2:	12 96       	adiw	r26, 0x02	; 2
     7d4:	9c 93       	st	X, r25
     7d6:	8e 93       	st	-X, r24
     7d8:	11 97       	sbiw	r26, 0x01	; 1
     7da:	11 96       	adiw	r26, 0x01	; 1
     7dc:	ed 91       	ld	r30, X+
     7de:	fc 91       	ld	r31, X
     7e0:	12 97       	sbiw	r26, 0x02	; 2
     7e2:	86 81       	ldd	r24, Z+6	; 0x06
     7e4:	97 81       	ldd	r25, Z+7	; 0x07
     7e6:	90 93 1e 02 	sts	0x021E, r25
     7ea:	80 93 1d 02 	sts	0x021D, r24
     7ee:	20 93 20 02 	sts	0x0220, r18
     7f2:	08 95       	ret

000007f4 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     7f4:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     7f6:	80 91 26 02 	lds	r24, 0x0226
     7fa:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     7fc:	80 91 22 02 	lds	r24, 0x0222
     800:	90 91 23 02 	lds	r25, 0x0223
     804:	92 83       	std	Z+2, r25	; 0x02
     806:	81 83       	std	Z+1, r24	; 0x01
}
     808:	08 95       	ret

0000080a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     80a:	fc 01       	movw	r30, r24
     80c:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     814:	40 91 22 02 	lds	r20, 0x0222
     818:	50 91 23 02 	lds	r21, 0x0223
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     81c:	90 91 26 02 	lds	r25, 0x0226
     820:	80 81       	ld	r24, Z
     822:	98 17       	cp	r25, r24
     824:	29 f0       	breq	.+10     	; 0x830 <xTaskCheckForTimeOut+0x26>
     826:	81 81       	ldd	r24, Z+1	; 0x01
     828:	92 81       	ldd	r25, Z+2	; 0x02
     82a:	48 17       	cp	r20, r24
     82c:	59 07       	cpc	r21, r25
     82e:	e0 f4       	brcc	.+56     	; 0x868 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     830:	21 81       	ldd	r18, Z+1	; 0x01
     832:	32 81       	ldd	r19, Z+2	; 0x02
     834:	6d 91       	ld	r22, X+
     836:	7c 91       	ld	r23, X
     838:	11 97       	sbiw	r26, 0x01	; 1
     83a:	ca 01       	movw	r24, r20
     83c:	82 1b       	sub	r24, r18
     83e:	93 0b       	sbc	r25, r19
     840:	86 17       	cp	r24, r22
     842:	97 07       	cpc	r25, r23
     844:	88 f4       	brcc	.+34     	; 0x868 <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
     846:	24 1b       	sub	r18, r20
     848:	35 0b       	sbc	r19, r21
     84a:	26 0f       	add	r18, r22
     84c:	37 1f       	adc	r19, r23
     84e:	2d 93       	st	X+, r18
     850:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     852:	80 91 26 02 	lds	r24, 0x0226
     856:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     858:	80 91 22 02 	lds	r24, 0x0222
     85c:	90 91 23 02 	lds	r25, 0x0223
     860:	92 83       	std	Z+2, r25	; 0x02
     862:	81 83       	std	Z+1, r24	; 0x01
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	01 c0       	rjmp	.+2      	; 0x86a <xTaskCheckForTimeOut+0x60>
     868:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     86a:	0f 90       	pop	r0
     86c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     86e:	08 95       	ret

00000870 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     870:	81 e0       	ldi	r24, 0x01	; 1
     872:	80 93 21 02 	sts	0x0221, r24
}
     876:	08 95       	ret

00000878 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     878:	e0 91 1d 02 	lds	r30, 0x021D
     87c:	f0 91 1e 02 	lds	r31, 0x021E
     880:	84 85       	ldd	r24, Z+12	; 0x0c
     882:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     884:	a0 91 1d 02 	lds	r26, 0x021D
     888:	b0 91 1e 02 	lds	r27, 0x021E
     88c:	e0 91 1d 02 	lds	r30, 0x021D
     890:	f0 91 1e 02 	lds	r31, 0x021E
     894:	46 89       	ldd	r20, Z+22	; 0x16
     896:	24 e0       	ldi	r18, 0x04	; 4
     898:	30 e0       	ldi	r19, 0x00	; 0
     89a:	24 1b       	sub	r18, r20
     89c:	31 09       	sbc	r19, r1
     89e:	1d 96       	adiw	r26, 0x0d	; 13
     8a0:	3c 93       	st	X, r19
     8a2:	2e 93       	st	-X, r18
     8a4:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
}
     8a6:	08 95       	ret

000008a8 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	29 f4       	brne	.+10     	; 0x8b6 <xTaskNotifyStateClear+0xe>
     8ac:	e0 91 1d 02 	lds	r30, 0x021D
     8b0:	f0 91 1e 02 	lds	r31, 0x021E
     8b4:	01 c0       	rjmp	.+2      	; 0x8b8 <xTaskNotifyStateClear+0x10>
     8b6:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
     8be:	85 a1       	ldd	r24, Z+37	; 0x25
     8c0:	82 30       	cpi	r24, 0x02	; 2
     8c2:	11 f0       	breq	.+4      	; 0x8c8 <xTaskNotifyStateClear+0x20>
     8c4:	80 e0       	ldi	r24, 0x00	; 0
     8c6:	02 c0       	rjmp	.+4      	; 0x8cc <xTaskNotifyStateClear+0x24>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     8c8:	15 a2       	std	Z+37, r1	; 0x25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		taskEXIT_CRITICAL();
     8cc:	0f 90       	pop	r0
     8ce:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     8d0:	08 95       	ret

000008d2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
     8d2:	ef 92       	push	r14
     8d4:	ff 92       	push	r15
     8d6:	0f 93       	push	r16
     8d8:	1f 93       	push	r17
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	7b 01       	movw	r14, r22
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     8e0:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
     8e2:	2d a1       	ldd	r18, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     8e4:	82 e0       	ldi	r24, 0x02	; 2
     8e6:	8d a3       	std	Y+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
     8e8:	89 a1       	ldd	r24, Y+33	; 0x21
     8ea:	9a a1       	ldd	r25, Y+34	; 0x22
     8ec:	ab a1       	ldd	r26, Y+35	; 0x23
     8ee:	bc a1       	ldd	r27, Y+36	; 0x24
     8f0:	01 96       	adiw	r24, 0x01	; 1
     8f2:	a1 1d       	adc	r26, r1
     8f4:	b1 1d       	adc	r27, r1
     8f6:	89 a3       	std	Y+33, r24	; 0x21
     8f8:	9a a3       	std	Y+34, r25	; 0x22
     8fa:	ab a3       	std	Y+35, r26	; 0x23
     8fc:	bc a3       	std	Y+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     8fe:	21 30       	cpi	r18, 0x01	; 1
     900:	91 f5       	brne	.+100    	; 0x966 <vTaskNotifyGiveFromISR+0x94>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     902:	80 91 1f 02 	lds	r24, 0x021F
     906:	88 23       	and	r24, r24
     908:	a9 f4       	brne	.+42     	; 0x934 <vTaskNotifyGiveFromISR+0x62>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     90a:	8e 01       	movw	r16, r28
     90c:	0e 5f       	subi	r16, 0xFE	; 254
     90e:	1f 4f       	sbci	r17, 0xFF	; 255
     910:	c8 01       	movw	r24, r16
     912:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     916:	9e 89       	ldd	r25, Y+22	; 0x16
     918:	80 91 20 02 	lds	r24, 0x0220
     91c:	89 17       	cp	r24, r25
     91e:	10 f4       	brcc	.+4      	; 0x924 <vTaskNotifyGiveFromISR+0x52>
     920:	90 93 20 02 	sts	0x0220, r25
     924:	89 e0       	ldi	r24, 0x09	; 9
     926:	98 9f       	mul	r25, r24
     928:	c0 01       	movw	r24, r0
     92a:	11 24       	eor	r1, r1
     92c:	82 5d       	subi	r24, 0xD2	; 210
     92e:	9d 4f       	sbci	r25, 0xFD	; 253
     930:	b8 01       	movw	r22, r16
     932:	05 c0       	rjmp	.+10     	; 0x93e <vTaskNotifyGiveFromISR+0x6c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     934:	be 01       	movw	r22, r28
     936:	64 5f       	subi	r22, 0xF4	; 244
     938:	7f 4f       	sbci	r23, 0xFF	; 255
     93a:	88 e6       	ldi	r24, 0x68	; 104
     93c:	92 e0       	ldi	r25, 0x02	; 2
     93e:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     942:	e0 91 1d 02 	lds	r30, 0x021D
     946:	f0 91 1e 02 	lds	r31, 0x021E
     94a:	9e 89       	ldd	r25, Y+22	; 0x16
     94c:	86 89       	ldd	r24, Z+22	; 0x16
     94e:	89 17       	cp	r24, r25
     950:	50 f4       	brcc	.+20     	; 0x966 <vTaskNotifyGiveFromISR+0x94>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     952:	e1 14       	cp	r14, r1
     954:	f1 04       	cpc	r15, r1
     956:	21 f0       	breq	.+8      	; 0x960 <vTaskNotifyGiveFromISR+0x8e>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     958:	81 e0       	ldi	r24, 0x01	; 1
     95a:	f7 01       	movw	r30, r14
     95c:	80 83       	st	Z, r24
     95e:	03 c0       	rjmp	.+6      	; 0x966 <vTaskNotifyGiveFromISR+0x94>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	80 93 21 02 	sts	0x0221, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	1f 91       	pop	r17
     96c:	0f 91       	pop	r16
     96e:	ff 90       	pop	r15
     970:	ef 90       	pop	r14
     972:	08 95       	ret

00000974 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     974:	ef 92       	push	r14
     976:	ff 92       	push	r15
     978:	0f 93       	push	r16
     97a:	1f 93       	push	r17
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	f8 01       	movw	r30, r16
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     982:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     984:	01 15       	cp	r16, r1
     986:	11 05       	cpc	r17, r1
     988:	41 f0       	breq	.+16     	; 0x99a <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     98a:	89 a1       	ldd	r24, Y+33	; 0x21
     98c:	9a a1       	ldd	r25, Y+34	; 0x22
     98e:	ab a1       	ldd	r26, Y+35	; 0x23
     990:	bc a1       	ldd	r27, Y+36	; 0x24
     992:	80 83       	st	Z, r24
     994:	91 83       	std	Z+1, r25	; 0x01
     996:	a2 83       	std	Z+2, r26	; 0x02
     998:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     99a:	3d a1       	ldd	r19, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     99c:	82 e0       	ldi	r24, 0x02	; 2
     99e:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     9a0:	22 30       	cpi	r18, 0x02	; 2
     9a2:	99 f0       	breq	.+38     	; 0x9ca <xTaskGenericNotifyFromISR+0x56>
     9a4:	23 30       	cpi	r18, 0x03	; 3
     9a6:	18 f4       	brcc	.+6      	; 0x9ae <xTaskGenericNotifyFromISR+0x3a>
     9a8:	21 30       	cpi	r18, 0x01	; 1
     9aa:	19 f5       	brne	.+70     	; 0x9f2 <xTaskGenericNotifyFromISR+0x7e>
     9ac:	05 c0       	rjmp	.+10     	; 0x9b8 <xTaskGenericNotifyFromISR+0x44>
     9ae:	23 30       	cpi	r18, 0x03	; 3
     9b0:	e1 f0       	breq	.+56     	; 0x9ea <xTaskGenericNotifyFromISR+0x76>
     9b2:	24 30       	cpi	r18, 0x04	; 4
     9b4:	f1 f4       	brne	.+60     	; 0x9f2 <xTaskGenericNotifyFromISR+0x7e>
     9b6:	15 c0       	rjmp	.+42     	; 0x9e2 <xTaskGenericNotifyFromISR+0x6e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     9b8:	89 a1       	ldd	r24, Y+33	; 0x21
     9ba:	9a a1       	ldd	r25, Y+34	; 0x22
     9bc:	ab a1       	ldd	r26, Y+35	; 0x23
     9be:	bc a1       	ldd	r27, Y+36	; 0x24
     9c0:	84 2b       	or	r24, r20
     9c2:	95 2b       	or	r25, r21
     9c4:	a6 2b       	or	r26, r22
     9c6:	b7 2b       	or	r27, r23
     9c8:	07 c0       	rjmp	.+14     	; 0x9d8 <xTaskGenericNotifyFromISR+0x64>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     9ca:	89 a1       	ldd	r24, Y+33	; 0x21
     9cc:	9a a1       	ldd	r25, Y+34	; 0x22
     9ce:	ab a1       	ldd	r26, Y+35	; 0x23
     9d0:	bc a1       	ldd	r27, Y+36	; 0x24
     9d2:	01 96       	adiw	r24, 0x01	; 1
     9d4:	a1 1d       	adc	r26, r1
     9d6:	b1 1d       	adc	r27, r1
     9d8:	89 a3       	std	Y+33, r24	; 0x21
     9da:	9a a3       	std	Y+34, r25	; 0x22
     9dc:	ab a3       	std	Y+35, r26	; 0x23
     9de:	bc a3       	std	Y+36, r27	; 0x24
     9e0:	08 c0       	rjmp	.+16     	; 0x9f2 <xTaskGenericNotifyFromISR+0x7e>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     9e2:	32 30       	cpi	r19, 0x02	; 2
     9e4:	11 f4       	brne	.+4      	; 0x9ea <xTaskGenericNotifyFromISR+0x76>
     9e6:	80 e0       	ldi	r24, 0x00	; 0
     9e8:	3a c0       	rjmp	.+116    	; 0xa5e <xTaskGenericNotifyFromISR+0xea>
					{
						pxTCB->ulNotifiedValue = ulValue;
     9ea:	49 a3       	std	Y+33, r20	; 0x21
     9ec:	5a a3       	std	Y+34, r21	; 0x22
     9ee:	6b a3       	std	Y+35, r22	; 0x23
     9f0:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     9f2:	31 30       	cpi	r19, 0x01	; 1
     9f4:	99 f5       	brne	.+102    	; 0xa5c <xTaskGenericNotifyFromISR+0xe8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     9f6:	80 91 1f 02 	lds	r24, 0x021F
     9fa:	88 23       	and	r24, r24
     9fc:	a9 f4       	brne	.+42     	; 0xa28 <xTaskGenericNotifyFromISR+0xb4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     9fe:	8e 01       	movw	r16, r28
     a00:	0e 5f       	subi	r16, 0xFE	; 254
     a02:	1f 4f       	sbci	r17, 0xFF	; 255
     a04:	c8 01       	movw	r24, r16
     a06:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a0a:	9e 89       	ldd	r25, Y+22	; 0x16
     a0c:	80 91 20 02 	lds	r24, 0x0220
     a10:	89 17       	cp	r24, r25
     a12:	10 f4       	brcc	.+4      	; 0xa18 <xTaskGenericNotifyFromISR+0xa4>
     a14:	90 93 20 02 	sts	0x0220, r25
     a18:	89 e0       	ldi	r24, 0x09	; 9
     a1a:	98 9f       	mul	r25, r24
     a1c:	c0 01       	movw	r24, r0
     a1e:	11 24       	eor	r1, r1
     a20:	82 5d       	subi	r24, 0xD2	; 210
     a22:	9d 4f       	sbci	r25, 0xFD	; 253
     a24:	b8 01       	movw	r22, r16
     a26:	05 c0       	rjmp	.+10     	; 0xa32 <xTaskGenericNotifyFromISR+0xbe>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     a28:	be 01       	movw	r22, r28
     a2a:	64 5f       	subi	r22, 0xF4	; 244
     a2c:	7f 4f       	sbci	r23, 0xFF	; 255
     a2e:	88 e6       	ldi	r24, 0x68	; 104
     a30:	92 e0       	ldi	r25, 0x02	; 2
     a32:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     a36:	e0 91 1d 02 	lds	r30, 0x021D
     a3a:	f0 91 1e 02 	lds	r31, 0x021E
     a3e:	9e 89       	ldd	r25, Y+22	; 0x16
     a40:	86 89       	ldd	r24, Z+22	; 0x16
     a42:	89 17       	cp	r24, r25
     a44:	58 f4       	brcc	.+22     	; 0xa5c <xTaskGenericNotifyFromISR+0xe8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     a46:	e1 14       	cp	r14, r1
     a48:	f1 04       	cpc	r15, r1
     a4a:	21 f0       	breq	.+8      	; 0xa54 <xTaskGenericNotifyFromISR+0xe0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     a4c:	81 e0       	ldi	r24, 0x01	; 1
     a4e:	f7 01       	movw	r30, r14
     a50:	80 83       	st	Z, r24
     a52:	05 c0       	rjmp	.+10     	; 0xa5e <xTaskGenericNotifyFromISR+0xea>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	80 93 21 02 	sts	0x0221, r24
     a5a:	01 c0       	rjmp	.+2      	; 0xa5e <xTaskGenericNotifyFromISR+0xea>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	1f 91       	pop	r17
     a64:	0f 91       	pop	r16
     a66:	ff 90       	pop	r15
     a68:	ef 90       	pop	r14
     a6a:	08 95       	ret

00000a6c <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     a6c:	0f 93       	push	r16
     a6e:	1f 93       	push	r17
     a70:	cf 93       	push	r28
     a72:	df 93       	push	r29
     a74:	fc 01       	movw	r30, r24
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     a76:	70 68       	ori	r23, 0x80	; 128
     a78:	71 83       	std	Z+1, r23	; 0x01
     a7a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
     a7c:	c6 81       	ldd	r28, Z+6	; 0x06
     a7e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     a80:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     a84:	8e 01       	movw	r16, r28
     a86:	0e 5f       	subi	r16, 0xFE	; 254
     a88:	1f 4f       	sbci	r17, 0xFF	; 255
     a8a:	c8 01       	movw	r24, r16
     a8c:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     a90:	9e 89       	ldd	r25, Y+22	; 0x16
     a92:	80 91 20 02 	lds	r24, 0x0220
     a96:	89 17       	cp	r24, r25
     a98:	10 f4       	brcc	.+4      	; 0xa9e <xTaskRemoveFromUnorderedEventList+0x32>
     a9a:	90 93 20 02 	sts	0x0220, r25
     a9e:	89 e0       	ldi	r24, 0x09	; 9
     aa0:	98 9f       	mul	r25, r24
     aa2:	c0 01       	movw	r24, r0
     aa4:	11 24       	eor	r1, r1
     aa6:	82 5d       	subi	r24, 0xD2	; 210
     aa8:	9d 4f       	sbci	r25, 0xFD	; 253
     aaa:	b8 01       	movw	r22, r16
     aac:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     ab0:	e0 91 1d 02 	lds	r30, 0x021D
     ab4:	f0 91 1e 02 	lds	r31, 0x021E
     ab8:	9e 89       	ldd	r25, Y+22	; 0x16
     aba:	86 89       	ldd	r24, Z+22	; 0x16
     abc:	89 17       	cp	r24, r25
     abe:	10 f0       	brcs	.+4      	; 0xac4 <xTaskRemoveFromUnorderedEventList+0x58>
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	03 c0       	rjmp	.+6      	; 0xaca <xTaskRemoveFromUnorderedEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	80 93 21 02 	sts	0x0221, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	08 95       	ret

00000ad4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     adc:	dc 01       	movw	r26, r24
     ade:	15 96       	adiw	r26, 0x05	; 5
     ae0:	ed 91       	ld	r30, X+
     ae2:	fc 91       	ld	r31, X
     ae4:	16 97       	sbiw	r26, 0x06	; 6
     ae6:	c6 81       	ldd	r28, Z+6	; 0x06
     ae8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     aea:	8e 01       	movw	r16, r28
     aec:	04 5f       	subi	r16, 0xF4	; 244
     aee:	1f 4f       	sbci	r17, 0xFF	; 255
     af0:	c8 01       	movw	r24, r16
     af2:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     af6:	80 91 1f 02 	lds	r24, 0x021F
     afa:	88 23       	and	r24, r24
     afc:	a1 f4       	brne	.+40     	; 0xb26 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     afe:	8e 01       	movw	r16, r28
     b00:	0e 5f       	subi	r16, 0xFE	; 254
     b02:	1f 4f       	sbci	r17, 0xFF	; 255
     b04:	c8 01       	movw	r24, r16
     b06:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     b0a:	9e 89       	ldd	r25, Y+22	; 0x16
     b0c:	80 91 20 02 	lds	r24, 0x0220
     b10:	89 17       	cp	r24, r25
     b12:	10 f4       	brcc	.+4      	; 0xb18 <xTaskRemoveFromEventList+0x44>
     b14:	90 93 20 02 	sts	0x0220, r25
     b18:	89 e0       	ldi	r24, 0x09	; 9
     b1a:	98 9f       	mul	r25, r24
     b1c:	c0 01       	movw	r24, r0
     b1e:	11 24       	eor	r1, r1
     b20:	82 5d       	subi	r24, 0xD2	; 210
     b22:	9d 4f       	sbci	r25, 0xFD	; 253
     b24:	02 c0       	rjmp	.+4      	; 0xb2a <xTaskRemoveFromEventList+0x56>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     b26:	88 e6       	ldi	r24, 0x68	; 104
     b28:	92 e0       	ldi	r25, 0x02	; 2
     b2a:	b8 01       	movw	r22, r16
     b2c:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     b30:	e0 91 1d 02 	lds	r30, 0x021D
     b34:	f0 91 1e 02 	lds	r31, 0x021E
     b38:	9e 89       	ldd	r25, Y+22	; 0x16
     b3a:	86 89       	ldd	r24, Z+22	; 0x16
     b3c:	89 17       	cp	r24, r25
     b3e:	10 f0       	brcs	.+4      	; 0xb44 <xTaskRemoveFromEventList+0x70>
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	03 c0       	rjmp	.+6      	; 0xb4a <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     b44:	81 e0       	ldi	r24, 0x01	; 1
     b46:	80 93 21 02 	sts	0x0221, r24
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
     b4e:	1f 91       	pop	r17
     b50:	0f 91       	pop	r16
     b52:	08 95       	ret

00000b54 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     b54:	cf 92       	push	r12
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b64:	80 91 1f 02 	lds	r24, 0x021F
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <xTaskIncrementTick+0x1a>
     b6c:	a6 c0       	rjmp	.+332    	; 0xcba <xTaskIncrementTick+0x166>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     b6e:	00 91 22 02 	lds	r16, 0x0222
     b72:	10 91 23 02 	lds	r17, 0x0223
     b76:	0f 5f       	subi	r16, 0xFF	; 255
     b78:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     b7a:	10 93 23 02 	sts	0x0223, r17
     b7e:	00 93 22 02 	sts	0x0222, r16

		if( xConstTickCount == ( TickType_t ) 0U )
     b82:	01 15       	cp	r16, r1
     b84:	11 05       	cpc	r17, r1
     b86:	79 f5       	brne	.+94     	; 0xbe6 <xTaskIncrementTick+0x92>
		{
			taskSWITCH_DELAYED_LISTS();
     b88:	20 91 64 02 	lds	r18, 0x0264
     b8c:	30 91 65 02 	lds	r19, 0x0265
     b90:	80 91 66 02 	lds	r24, 0x0266
     b94:	90 91 67 02 	lds	r25, 0x0267
     b98:	90 93 65 02 	sts	0x0265, r25
     b9c:	80 93 64 02 	sts	0x0264, r24
     ba0:	30 93 67 02 	sts	0x0267, r19
     ba4:	20 93 66 02 	sts	0x0266, r18
     ba8:	80 91 26 02 	lds	r24, 0x0226
     bac:	8f 5f       	subi	r24, 0xFF	; 255
     bae:	80 93 26 02 	sts	0x0226, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     bb2:	e0 91 64 02 	lds	r30, 0x0264
     bb6:	f0 91 65 02 	lds	r31, 0x0265
     bba:	80 81       	ld	r24, Z
     bbc:	88 23       	and	r24, r24
     bbe:	19 f4       	brne	.+6      	; 0xbc6 <xTaskIncrementTick+0x72>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     bc0:	8f ef       	ldi	r24, 0xFF	; 255
     bc2:	9f ef       	ldi	r25, 0xFF	; 255
     bc4:	0c c0       	rjmp	.+24     	; 0xbde <xTaskIncrementTick+0x8a>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     bc6:	e0 91 64 02 	lds	r30, 0x0264
     bca:	f0 91 65 02 	lds	r31, 0x0265
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     bce:	05 80       	ldd	r0, Z+5	; 0x05
     bd0:	f6 81       	ldd	r31, Z+6	; 0x06
     bd2:	e0 2d       	mov	r30, r0
     bd4:	06 80       	ldd	r0, Z+6	; 0x06
     bd6:	f7 81       	ldd	r31, Z+7	; 0x07
     bd8:	e0 2d       	mov	r30, r0
     bda:	82 81       	ldd	r24, Z+2	; 0x02
     bdc:	93 81       	ldd	r25, Z+3	; 0x03
     bde:	90 93 25 02 	sts	0x0225, r25
     be2:	80 93 24 02 	sts	0x0224, r24

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     be6:	80 91 24 02 	lds	r24, 0x0224
     bea:	90 91 25 02 	lds	r25, 0x0225
     bee:	08 17       	cp	r16, r24
     bf0:	19 07       	cpc	r17, r25
     bf2:	08 f4       	brcc	.+2      	; 0xbf6 <xTaskIncrementTick+0xa2>
     bf4:	4b c0       	rjmp	.+150    	; 0xc8c <xTaskIncrementTick+0x138>
     bf6:	dd 24       	eor	r13, r13
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     bf8:	49 e0       	ldi	r20, 0x09	; 9
     bfa:	c4 2e       	mov	r12, r20
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     bfc:	e0 91 64 02 	lds	r30, 0x0264
     c00:	f0 91 65 02 	lds	r31, 0x0265
     c04:	80 81       	ld	r24, Z
     c06:	88 23       	and	r24, r24
     c08:	19 f4       	brne	.+6      	; 0xc10 <xTaskIncrementTick+0xbc>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     c0a:	8f ef       	ldi	r24, 0xFF	; 255
     c0c:	9f ef       	ldi	r25, 0xFF	; 255
     c0e:	0e c0       	rjmp	.+28     	; 0xc2c <xTaskIncrementTick+0xd8>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     c10:	e0 91 64 02 	lds	r30, 0x0264
     c14:	f0 91 65 02 	lds	r31, 0x0265
     c18:	05 80       	ldd	r0, Z+5	; 0x05
     c1a:	f6 81       	ldd	r31, Z+6	; 0x06
     c1c:	e0 2d       	mov	r30, r0
     c1e:	c6 81       	ldd	r28, Z+6	; 0x06
     c20:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     c26:	08 17       	cp	r16, r24
     c28:	19 07       	cpc	r17, r25
     c2a:	28 f4       	brcc	.+10     	; 0xc36 <xTaskIncrementTick+0xe2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     c2c:	90 93 25 02 	sts	0x0225, r25
     c30:	80 93 24 02 	sts	0x0224, r24
     c34:	2c c0       	rjmp	.+88     	; 0xc8e <xTaskIncrementTick+0x13a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c36:	32 e0       	ldi	r19, 0x02	; 2
     c38:	e3 2e       	mov	r14, r19
     c3a:	f1 2c       	mov	r15, r1
     c3c:	ec 0e       	add	r14, r28
     c3e:	fd 1e       	adc	r15, r29
     c40:	c7 01       	movw	r24, r14
     c42:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     c46:	8c 89       	ldd	r24, Y+20	; 0x14
     c48:	9d 89       	ldd	r25, Y+21	; 0x15
     c4a:	89 2b       	or	r24, r25
     c4c:	21 f0       	breq	.+8      	; 0xc56 <xTaskIncrementTick+0x102>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c4e:	ce 01       	movw	r24, r28
     c50:	0c 96       	adiw	r24, 0x0c	; 12
     c52:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     c56:	9e 89       	ldd	r25, Y+22	; 0x16
     c58:	80 91 20 02 	lds	r24, 0x0220
     c5c:	89 17       	cp	r24, r25
     c5e:	10 f4       	brcc	.+4      	; 0xc64 <xTaskIncrementTick+0x110>
     c60:	90 93 20 02 	sts	0x0220, r25
     c64:	9c 9d       	mul	r25, r12
     c66:	c0 01       	movw	r24, r0
     c68:	11 24       	eor	r1, r1
     c6a:	82 5d       	subi	r24, 0xD2	; 210
     c6c:	9d 4f       	sbci	r25, 0xFD	; 253
     c6e:	b7 01       	movw	r22, r14
     c70:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c74:	e0 91 1d 02 	lds	r30, 0x021D
     c78:	f0 91 1e 02 	lds	r31, 0x021E
     c7c:	9e 89       	ldd	r25, Y+22	; 0x16
     c7e:	86 89       	ldd	r24, Z+22	; 0x16
     c80:	98 17       	cp	r25, r24
     c82:	08 f4       	brcc	.+2      	; 0xc86 <xTaskIncrementTick+0x132>
     c84:	bb cf       	rjmp	.-138    	; 0xbfc <xTaskIncrementTick+0xa8>
     c86:	dd 24       	eor	r13, r13
     c88:	d3 94       	inc	r13
     c8a:	b8 cf       	rjmp	.-144    	; 0xbfc <xTaskIncrementTick+0xa8>
     c8c:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     c8e:	e0 91 1d 02 	lds	r30, 0x021D
     c92:	f0 91 1e 02 	lds	r31, 0x021E
     c96:	86 89       	ldd	r24, Z+22	; 0x16
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	fc 01       	movw	r30, r24
     c9c:	23 e0       	ldi	r18, 0x03	; 3
     c9e:	ee 0f       	add	r30, r30
     ca0:	ff 1f       	adc	r31, r31
     ca2:	2a 95       	dec	r18
     ca4:	e1 f7       	brne	.-8      	; 0xc9e <xTaskIncrementTick+0x14a>
     ca6:	e8 0f       	add	r30, r24
     ca8:	f9 1f       	adc	r31, r25
     caa:	e2 5d       	subi	r30, 0xD2	; 210
     cac:	fd 4f       	sbci	r31, 0xFD	; 253
     cae:	80 81       	ld	r24, Z
     cb0:	82 30       	cpi	r24, 0x02	; 2
     cb2:	48 f0       	brcs	.+18     	; 0xcc6 <xTaskIncrementTick+0x172>
     cb4:	dd 24       	eor	r13, r13
     cb6:	d3 94       	inc	r13
     cb8:	06 c0       	rjmp	.+12     	; 0xcc6 <xTaskIncrementTick+0x172>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     cba:	80 91 27 02 	lds	r24, 0x0227
     cbe:	8f 5f       	subi	r24, 0xFF	; 255
     cc0:	80 93 27 02 	sts	0x0227, r24
     cc4:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     cc6:	80 91 21 02 	lds	r24, 0x0221
     cca:	88 23       	and	r24, r24
     ccc:	11 f0       	breq	.+4      	; 0xcd2 <xTaskIncrementTick+0x17e>
     cce:	dd 24       	eor	r13, r13
     cd0:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     cd2:	8d 2d       	mov	r24, r13
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	ff 90       	pop	r15
     cde:	ef 90       	pop	r14
     ce0:	df 90       	pop	r13
     ce2:	cf 90       	pop	r12
     ce4:	08 95       	ret

00000ce6 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     ce6:	0f 93       	push	r16
     ce8:	1f 93       	push	r17
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
     cee:	f8 01       	movw	r30, r16
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
     cf0:	ec 01       	movw	r28, r24

		taskENTER_CRITICAL();
     cf2:	0f b6       	in	r0, 0x3f	; 63
     cf4:	f8 94       	cli
     cf6:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     cf8:	01 15       	cp	r16, r1
     cfa:	11 05       	cpc	r17, r1
     cfc:	41 f0       	breq	.+16     	; 0xd0e <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     cfe:	89 a1       	ldd	r24, Y+33	; 0x21
     d00:	9a a1       	ldd	r25, Y+34	; 0x22
     d02:	ab a1       	ldd	r26, Y+35	; 0x23
     d04:	bc a1       	ldd	r27, Y+36	; 0x24
     d06:	80 83       	st	Z, r24
     d08:	91 83       	std	Z+1, r25	; 0x01
     d0a:	a2 83       	std	Z+2, r26	; 0x02
     d0c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     d0e:	3d a1       	ldd	r19, Y+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     d10:	82 e0       	ldi	r24, 0x02	; 2
     d12:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     d14:	22 30       	cpi	r18, 0x02	; 2
     d16:	99 f0       	breq	.+38     	; 0xd3e <xTaskGenericNotify+0x58>
     d18:	23 30       	cpi	r18, 0x03	; 3
     d1a:	18 f4       	brcc	.+6      	; 0xd22 <xTaskGenericNotify+0x3c>
     d1c:	21 30       	cpi	r18, 0x01	; 1
     d1e:	19 f5       	brne	.+70     	; 0xd66 <xTaskGenericNotify+0x80>
     d20:	05 c0       	rjmp	.+10     	; 0xd2c <xTaskGenericNotify+0x46>
     d22:	23 30       	cpi	r18, 0x03	; 3
     d24:	e1 f0       	breq	.+56     	; 0xd5e <xTaskGenericNotify+0x78>
     d26:	24 30       	cpi	r18, 0x04	; 4
     d28:	f1 f4       	brne	.+60     	; 0xd66 <xTaskGenericNotify+0x80>
     d2a:	15 c0       	rjmp	.+42     	; 0xd56 <xTaskGenericNotify+0x70>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     d2c:	89 a1       	ldd	r24, Y+33	; 0x21
     d2e:	9a a1       	ldd	r25, Y+34	; 0x22
     d30:	ab a1       	ldd	r26, Y+35	; 0x23
     d32:	bc a1       	ldd	r27, Y+36	; 0x24
     d34:	84 2b       	or	r24, r20
     d36:	95 2b       	or	r25, r21
     d38:	a6 2b       	or	r26, r22
     d3a:	b7 2b       	or	r27, r23
     d3c:	07 c0       	rjmp	.+14     	; 0xd4c <xTaskGenericNotify+0x66>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     d3e:	89 a1       	ldd	r24, Y+33	; 0x21
     d40:	9a a1       	ldd	r25, Y+34	; 0x22
     d42:	ab a1       	ldd	r26, Y+35	; 0x23
     d44:	bc a1       	ldd	r27, Y+36	; 0x24
     d46:	01 96       	adiw	r24, 0x01	; 1
     d48:	a1 1d       	adc	r26, r1
     d4a:	b1 1d       	adc	r27, r1
     d4c:	89 a3       	std	Y+33, r24	; 0x21
     d4e:	9a a3       	std	Y+34, r25	; 0x22
     d50:	ab a3       	std	Y+35, r26	; 0x23
     d52:	bc a3       	std	Y+36, r27	; 0x24
     d54:	08 c0       	rjmp	.+16     	; 0xd66 <xTaskGenericNotify+0x80>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     d56:	32 30       	cpi	r19, 0x02	; 2
     d58:	11 f4       	brne	.+4      	; 0xd5e <xTaskGenericNotify+0x78>
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	27 c0       	rjmp	.+78     	; 0xdac <xTaskGenericNotify+0xc6>
					{
						pxTCB->ulNotifiedValue = ulValue;
     d5e:	49 a3       	std	Y+33, r20	; 0x21
     d60:	5a a3       	std	Y+34, r21	; 0x22
     d62:	6b a3       	std	Y+35, r22	; 0x23
     d64:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     d66:	31 30       	cpi	r19, 0x01	; 1
     d68:	01 f5       	brne	.+64     	; 0xdaa <xTaskGenericNotify+0xc4>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     d6a:	8e 01       	movw	r16, r28
     d6c:	0e 5f       	subi	r16, 0xFE	; 254
     d6e:	1f 4f       	sbci	r17, 0xFF	; 255
     d70:	c8 01       	movw	r24, r16
     d72:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     d76:	9e 89       	ldd	r25, Y+22	; 0x16
     d78:	80 91 20 02 	lds	r24, 0x0220
     d7c:	89 17       	cp	r24, r25
     d7e:	10 f4       	brcc	.+4      	; 0xd84 <xTaskGenericNotify+0x9e>
     d80:	90 93 20 02 	sts	0x0220, r25
     d84:	89 e0       	ldi	r24, 0x09	; 9
     d86:	98 9f       	mul	r25, r24
     d88:	c0 01       	movw	r24, r0
     d8a:	11 24       	eor	r1, r1
     d8c:	82 5d       	subi	r24, 0xD2	; 210
     d8e:	9d 4f       	sbci	r25, 0xFD	; 253
     d90:	b8 01       	movw	r22, r16
     d92:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     d96:	e0 91 1d 02 	lds	r30, 0x021D
     d9a:	f0 91 1e 02 	lds	r31, 0x021E
     d9e:	9e 89       	ldd	r25, Y+22	; 0x16
     da0:	86 89       	ldd	r24, Z+22	; 0x16
     da2:	89 17       	cp	r24, r25
     da4:	10 f4       	brcc	.+4      	; 0xdaa <xTaskGenericNotify+0xc4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     da6:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
     daa:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     dac:	0f 90       	pop	r0
     dae:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	08 95       	ret

00000dba <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     dba:	ef 92       	push	r14
     dbc:	ff 92       	push	r15
     dbe:	0f 93       	push	r16
     dc0:	1f 93       	push	r17
     dc2:	cf 93       	push	r28
     dc4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     dcc:	80 91 1f 02 	lds	r24, 0x021F
     dd0:	81 50       	subi	r24, 0x01	; 1
     dd2:	80 93 1f 02 	sts	0x021F, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     dd6:	80 91 1f 02 	lds	r24, 0x021F
     dda:	88 23       	and	r24, r24
     ddc:	09 f0       	breq	.+2      	; 0xde0 <xTaskResumeAll+0x26>
     dde:	6c c0       	rjmp	.+216    	; 0xeb8 <xTaskResumeAll+0xfe>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     de0:	80 91 28 02 	lds	r24, 0x0228
     de4:	88 23       	and	r24, r24
     de6:	09 f4       	brne	.+2      	; 0xdea <xTaskResumeAll+0x30>
     de8:	67 c0       	rjmp	.+206    	; 0xeb8 <xTaskResumeAll+0xfe>
     dea:	c0 e0       	ldi	r28, 0x00	; 0
     dec:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     dee:	59 e0       	ldi	r21, 0x09	; 9
     df0:	e5 2e       	mov	r14, r21

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     df2:	ff 24       	eor	r15, r15
     df4:	f3 94       	inc	r15
     df6:	29 c0       	rjmp	.+82     	; 0xe4a <xTaskResumeAll+0x90>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     df8:	e0 91 6d 02 	lds	r30, 0x026D
     dfc:	f0 91 6e 02 	lds	r31, 0x026E
     e00:	c6 81       	ldd	r28, Z+6	; 0x06
     e02:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     e04:	ce 01       	movw	r24, r28
     e06:	0c 96       	adiw	r24, 0x0c	; 12
     e08:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     e0c:	8e 01       	movw	r16, r28
     e0e:	0e 5f       	subi	r16, 0xFE	; 254
     e10:	1f 4f       	sbci	r17, 0xFF	; 255
     e12:	c8 01       	movw	r24, r16
     e14:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     e18:	9e 89       	ldd	r25, Y+22	; 0x16
     e1a:	80 91 20 02 	lds	r24, 0x0220
     e1e:	89 17       	cp	r24, r25
     e20:	10 f4       	brcc	.+4      	; 0xe26 <xTaskResumeAll+0x6c>
     e22:	90 93 20 02 	sts	0x0220, r25
     e26:	9e 9d       	mul	r25, r14
     e28:	c0 01       	movw	r24, r0
     e2a:	11 24       	eor	r1, r1
     e2c:	82 5d       	subi	r24, 0xD2	; 210
     e2e:	9d 4f       	sbci	r25, 0xFD	; 253
     e30:	b8 01       	movw	r22, r16
     e32:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e36:	e0 91 1d 02 	lds	r30, 0x021D
     e3a:	f0 91 1e 02 	lds	r31, 0x021E
     e3e:	9e 89       	ldd	r25, Y+22	; 0x16
     e40:	86 89       	ldd	r24, Z+22	; 0x16
     e42:	98 17       	cp	r25, r24
     e44:	10 f0       	brcs	.+4      	; 0xe4a <xTaskResumeAll+0x90>
					{
						xYieldPending = pdTRUE;
     e46:	f0 92 21 02 	sts	0x0221, r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e4a:	80 91 68 02 	lds	r24, 0x0268
     e4e:	88 23       	and	r24, r24
     e50:	99 f6       	brne	.-90     	; 0xdf8 <xTaskResumeAll+0x3e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     e52:	cd 2b       	or	r28, r29
     e54:	d1 f0       	breq	.+52     	; 0xe8a <xTaskResumeAll+0xd0>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     e56:	e0 91 64 02 	lds	r30, 0x0264
     e5a:	f0 91 65 02 	lds	r31, 0x0265
     e5e:	80 81       	ld	r24, Z
     e60:	88 23       	and	r24, r24
     e62:	19 f4       	brne	.+6      	; 0xe6a <xTaskResumeAll+0xb0>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     e64:	8f ef       	ldi	r24, 0xFF	; 255
     e66:	9f ef       	ldi	r25, 0xFF	; 255
     e68:	0c c0       	rjmp	.+24     	; 0xe82 <xTaskResumeAll+0xc8>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     e6a:	e0 91 64 02 	lds	r30, 0x0264
     e6e:	f0 91 65 02 	lds	r31, 0x0265
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     e72:	05 80       	ldd	r0, Z+5	; 0x05
     e74:	f6 81       	ldd	r31, Z+6	; 0x06
     e76:	e0 2d       	mov	r30, r0
     e78:	06 80       	ldd	r0, Z+6	; 0x06
     e7a:	f7 81       	ldd	r31, Z+7	; 0x07
     e7c:	e0 2d       	mov	r30, r0
     e7e:	82 81       	ldd	r24, Z+2	; 0x02
     e80:	93 81       	ldd	r25, Z+3	; 0x03
     e82:	90 93 25 02 	sts	0x0225, r25
     e86:	80 93 24 02 	sts	0x0224, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     e8a:	10 91 27 02 	lds	r17, 0x0227

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     e8e:	11 23       	and	r17, r17
     e90:	59 f0       	breq	.+22     	; 0xea8 <xTaskResumeAll+0xee>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     e92:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     e94:	0e 94 aa 05 	call	0xb54	; 0xb54 <xTaskIncrementTick>
     e98:	88 23       	and	r24, r24
     e9a:	11 f0       	breq	.+4      	; 0xea0 <xTaskResumeAll+0xe6>
							{
								xYieldPending = pdTRUE;
     e9c:	00 93 21 02 	sts	0x0221, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     ea0:	11 50       	subi	r17, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     ea2:	c1 f7       	brne	.-16     	; 0xe94 <xTaskResumeAll+0xda>

						uxPendedTicks = 0;
     ea4:	10 92 27 02 	sts	0x0227, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     ea8:	80 91 21 02 	lds	r24, 0x0221
     eac:	88 23       	and	r24, r24
     eae:	21 f0       	breq	.+8      	; 0xeb8 <xTaskResumeAll+0xfe>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     eb0:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	01 c0       	rjmp	.+2      	; 0xeba <xTaskResumeAll+0x100>
     eb8:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	1f 91       	pop	r17
     ec4:	0f 91       	pop	r16
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	08 95       	ret

00000ecc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     ecc:	0f 93       	push	r16
     ece:	1f 93       	push	r17
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
     ed4:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     ed6:	00 91 22 02 	lds	r16, 0x0222
     eda:	10 91 23 02 	lds	r17, 0x0223
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     ede:	80 91 1d 02 	lds	r24, 0x021D
     ee2:	90 91 1e 02 	lds	r25, 0x021E
     ee6:	02 96       	adiw	r24, 0x02	; 2
     ee8:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     eec:	c0 0f       	add	r28, r16
     eee:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     ef0:	e0 91 1d 02 	lds	r30, 0x021D
     ef4:	f0 91 1e 02 	lds	r31, 0x021E
     ef8:	d3 83       	std	Z+3, r29	; 0x03
     efa:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
     efc:	c0 17       	cp	r28, r16
     efe:	d1 07       	cpc	r29, r17
     f00:	68 f4       	brcc	.+26     	; 0xf1c <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     f02:	80 91 66 02 	lds	r24, 0x0266
     f06:	90 91 67 02 	lds	r25, 0x0267
     f0a:	60 91 1d 02 	lds	r22, 0x021D
     f0e:	70 91 1e 02 	lds	r23, 0x021E
     f12:	6e 5f       	subi	r22, 0xFE	; 254
     f14:	7f 4f       	sbci	r23, 0xFF	; 255
     f16:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vListInsert>
     f1a:	17 c0       	rjmp	.+46     	; 0xf4a <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     f1c:	80 91 64 02 	lds	r24, 0x0264
     f20:	90 91 65 02 	lds	r25, 0x0265
     f24:	60 91 1d 02 	lds	r22, 0x021D
     f28:	70 91 1e 02 	lds	r23, 0x021E
     f2c:	6e 5f       	subi	r22, 0xFE	; 254
     f2e:	7f 4f       	sbci	r23, 0xFF	; 255
     f30:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     f34:	80 91 24 02 	lds	r24, 0x0224
     f38:	90 91 25 02 	lds	r25, 0x0225
     f3c:	c8 17       	cp	r28, r24
     f3e:	d9 07       	cpc	r29, r25
     f40:	20 f4       	brcc	.+8      	; 0xf4a <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
     f42:	d0 93 25 02 	sts	0x0225, r29
     f46:	c0 93 24 02 	sts	0x0224, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     f4a:	df 91       	pop	r29
     f4c:	cf 91       	pop	r28
     f4e:	1f 91       	pop	r17
     f50:	0f 91       	pop	r16
     f52:	08 95       	ret

00000f54 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     f54:	6f 92       	push	r6
     f56:	7f 92       	push	r7
     f58:	8f 92       	push	r8
     f5a:	9f 92       	push	r9
     f5c:	af 92       	push	r10
     f5e:	bf 92       	push	r11
     f60:	cf 92       	push	r12
     f62:	df 92       	push	r13
     f64:	ef 92       	push	r14
     f66:	ff 92       	push	r15
     f68:	0f 93       	push	r16
     f6a:	1f 93       	push	r17
     f6c:	cf 93       	push	r28
     f6e:	df 93       	push	r29
     f70:	5b 01       	movw	r10, r22
     f72:	6c 01       	movw	r12, r24
     f74:	39 01       	movw	r6, r18
     f76:	4a 01       	movw	r8, r20
     f78:	e8 01       	movw	r28, r16
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f80:	e0 91 1d 02 	lds	r30, 0x021D
     f84:	f0 91 1e 02 	lds	r31, 0x021E
     f88:	85 a1       	ldd	r24, Z+37	; 0x25
     f8a:	82 30       	cpi	r24, 0x02	; 2
     f8c:	19 f1       	breq	.+70     	; 0xfd4 <xTaskNotifyWait+0x80>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     f8e:	e0 91 1d 02 	lds	r30, 0x021D
     f92:	f0 91 1e 02 	lds	r31, 0x021E
     f96:	81 a1       	ldd	r24, Z+33	; 0x21
     f98:	92 a1       	ldd	r25, Z+34	; 0x22
     f9a:	a3 a1       	ldd	r26, Z+35	; 0x23
     f9c:	b4 a1       	ldd	r27, Z+36	; 0x24
     f9e:	a0 94       	com	r10
     fa0:	b0 94       	com	r11
     fa2:	c0 94       	com	r12
     fa4:	d0 94       	com	r13
     fa6:	8a 21       	and	r24, r10
     fa8:	9b 21       	and	r25, r11
     faa:	ac 21       	and	r26, r12
     fac:	bd 21       	and	r27, r13
     fae:	81 a3       	std	Z+33, r24	; 0x21
     fb0:	92 a3       	std	Z+34, r25	; 0x22
     fb2:	a3 a3       	std	Z+35, r26	; 0x23
     fb4:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     fb6:	e0 91 1d 02 	lds	r30, 0x021D
     fba:	f0 91 1e 02 	lds	r31, 0x021E
     fbe:	81 e0       	ldi	r24, 0x01	; 1
     fc0:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     fc2:	e1 14       	cp	r14, r1
     fc4:	f1 04       	cpc	r15, r1
     fc6:	31 f0       	breq	.+12     	; 0xfd4 <xTaskNotifyWait+0x80>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     fc8:	c7 01       	movw	r24, r14
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     fd0:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     fd4:	0f 90       	pop	r0
     fd6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     fd8:	0f b6       	in	r0, 0x3f	; 63
     fda:	f8 94       	cli
     fdc:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     fde:	20 97       	sbiw	r28, 0x00	; 0
     fe0:	61 f0       	breq	.+24     	; 0xffa <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     fe2:	e0 91 1d 02 	lds	r30, 0x021D
     fe6:	f0 91 1e 02 	lds	r31, 0x021E
     fea:	81 a1       	ldd	r24, Z+33	; 0x21
     fec:	92 a1       	ldd	r25, Z+34	; 0x22
     fee:	a3 a1       	ldd	r26, Z+35	; 0x23
     ff0:	b4 a1       	ldd	r27, Z+36	; 0x24
     ff2:	88 83       	st	Y, r24
     ff4:	99 83       	std	Y+1, r25	; 0x01
     ff6:	aa 83       	std	Y+2, r26	; 0x02
     ff8:	bb 83       	std	Y+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     ffa:	e0 91 1d 02 	lds	r30, 0x021D
     ffe:	f0 91 1e 02 	lds	r31, 0x021E
    1002:	85 a1       	ldd	r24, Z+37	; 0x25
    1004:	81 30       	cpi	r24, 0x01	; 1
    1006:	11 f4       	brne	.+4      	; 0x100c <xTaskNotifyWait+0xb8>
    1008:	80 e0       	ldi	r24, 0x00	; 0
    100a:	15 c0       	rjmp	.+42     	; 0x1036 <xTaskNotifyWait+0xe2>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    100c:	e0 91 1d 02 	lds	r30, 0x021D
    1010:	f0 91 1e 02 	lds	r31, 0x021E
    1014:	81 a1       	ldd	r24, Z+33	; 0x21
    1016:	92 a1       	ldd	r25, Z+34	; 0x22
    1018:	a3 a1       	ldd	r26, Z+35	; 0x23
    101a:	b4 a1       	ldd	r27, Z+36	; 0x24
    101c:	60 94       	com	r6
    101e:	70 94       	com	r7
    1020:	80 94       	com	r8
    1022:	90 94       	com	r9
    1024:	86 21       	and	r24, r6
    1026:	97 21       	and	r25, r7
    1028:	a8 21       	and	r26, r8
    102a:	b9 21       	and	r27, r9
    102c:	81 a3       	std	Z+33, r24	; 0x21
    102e:	92 a3       	std	Z+34, r25	; 0x22
    1030:	a3 a3       	std	Z+35, r26	; 0x23
    1032:	b4 a3       	std	Z+36, r27	; 0x24
    1034:	81 e0       	ldi	r24, 0x01	; 1
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1036:	e0 91 1d 02 	lds	r30, 0x021D
    103a:	f0 91 1e 02 	lds	r31, 0x021E
    103e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	1f 91       	pop	r17
    104a:	0f 91       	pop	r16
    104c:	ff 90       	pop	r15
    104e:	ef 90       	pop	r14
    1050:	df 90       	pop	r13
    1052:	cf 90       	pop	r12
    1054:	bf 90       	pop	r11
    1056:	af 90       	pop	r10
    1058:	9f 90       	pop	r9
    105a:	8f 90       	pop	r8
    105c:	7f 90       	pop	r7
    105e:	6f 90       	pop	r6
    1060:	08 95       	ret

00001062 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1062:	1f 93       	push	r17
    1064:	18 2f       	mov	r17, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1066:	0f b6       	in	r0, 0x3f	; 63
    1068:	f8 94       	cli
    106a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    106c:	e0 91 1d 02 	lds	r30, 0x021D
    1070:	f0 91 1e 02 	lds	r31, 0x021E
    1074:	81 a1       	ldd	r24, Z+33	; 0x21
    1076:	92 a1       	ldd	r25, Z+34	; 0x22
    1078:	a3 a1       	ldd	r26, Z+35	; 0x23
    107a:	b4 a1       	ldd	r27, Z+36	; 0x24
    107c:	00 97       	sbiw	r24, 0x00	; 0
    107e:	a1 05       	cpc	r26, r1
    1080:	b1 05       	cpc	r27, r1
    1082:	79 f4       	brne	.+30     	; 0x10a2 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1084:	e0 91 1d 02 	lds	r30, 0x021D
    1088:	f0 91 1e 02 	lds	r31, 0x021E
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1090:	61 15       	cp	r22, r1
    1092:	71 05       	cpc	r23, r1
    1094:	31 f0       	breq	.+12     	; 0x10a2 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1096:	cb 01       	movw	r24, r22
    1098:	61 e0       	ldi	r22, 0x01	; 1
    109a:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    109e:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    10a2:	0f 90       	pop	r0
    10a4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    10a6:	0f b6       	in	r0, 0x3f	; 63
    10a8:	f8 94       	cli
    10aa:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    10ac:	e0 91 1d 02 	lds	r30, 0x021D
    10b0:	f0 91 1e 02 	lds	r31, 0x021E
    10b4:	21 a1       	ldd	r18, Z+33	; 0x21
    10b6:	32 a1       	ldd	r19, Z+34	; 0x22
    10b8:	43 a1       	ldd	r20, Z+35	; 0x23
    10ba:	54 a1       	ldd	r21, Z+36	; 0x24

			if( ulReturn != 0UL )
    10bc:	21 15       	cp	r18, r1
    10be:	31 05       	cpc	r19, r1
    10c0:	41 05       	cpc	r20, r1
    10c2:	51 05       	cpc	r21, r1
    10c4:	d9 f0       	breq	.+54     	; 0x10fc <ulTaskNotifyTake+0x9a>
			{
				if( xClearCountOnExit != pdFALSE )
    10c6:	11 23       	and	r17, r17
    10c8:	49 f0       	breq	.+18     	; 0x10dc <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    10ca:	e0 91 1d 02 	lds	r30, 0x021D
    10ce:	f0 91 1e 02 	lds	r31, 0x021E
    10d2:	11 a2       	std	Z+33, r1	; 0x21
    10d4:	12 a2       	std	Z+34, r1	; 0x22
    10d6:	13 a2       	std	Z+35, r1	; 0x23
    10d8:	14 a2       	std	Z+36, r1	; 0x24
    10da:	10 c0       	rjmp	.+32     	; 0x10fc <ulTaskNotifyTake+0x9a>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    10dc:	e0 91 1d 02 	lds	r30, 0x021D
    10e0:	f0 91 1e 02 	lds	r31, 0x021E
    10e4:	21 50       	subi	r18, 0x01	; 1
    10e6:	30 40       	sbci	r19, 0x00	; 0
    10e8:	40 40       	sbci	r20, 0x00	; 0
    10ea:	50 40       	sbci	r21, 0x00	; 0
    10ec:	21 a3       	std	Z+33, r18	; 0x21
    10ee:	32 a3       	std	Z+34, r19	; 0x22
    10f0:	43 a3       	std	Z+35, r20	; 0x23
    10f2:	54 a3       	std	Z+36, r21	; 0x24
    10f4:	2f 5f       	subi	r18, 0xFF	; 255
    10f6:	3f 4f       	sbci	r19, 0xFF	; 255
    10f8:	4f 4f       	sbci	r20, 0xFF	; 255
    10fa:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    10fc:	e0 91 1d 02 	lds	r30, 0x021D
    1100:	f0 91 1e 02 	lds	r31, 0x021E
    1104:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1106:	0f 90       	pop	r0
    1108:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    110a:	b9 01       	movw	r22, r18
    110c:	ca 01       	movw	r24, r20
    110e:	1f 91       	pop	r17
    1110:	08 95       	ret

00001112 <vTaskPlaceOnUnorderedEventList>:
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1112:	0f 93       	push	r16
    1114:	1f 93       	push	r17
    1116:	8a 01       	movw	r16, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1118:	e0 91 1d 02 	lds	r30, 0x021D
    111c:	f0 91 1e 02 	lds	r31, 0x021E
    1120:	70 68       	ori	r23, 0x80	; 128
    1122:	75 87       	std	Z+13, r23	; 0x0d
    1124:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1126:	60 91 1d 02 	lds	r22, 0x021D
    112a:	70 91 1e 02 	lds	r23, 0x021E
    112e:	64 5f       	subi	r22, 0xF4	; 244
    1130:	7f 4f       	sbci	r23, 0xFF	; 255
    1132:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1136:	c8 01       	movw	r24, r16
    1138:	61 e0       	ldi	r22, 0x01	; 1
    113a:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>
}
    113e:	1f 91       	pop	r17
    1140:	0f 91       	pop	r16
    1142:	08 95       	ret

00001144 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1144:	9c 01       	movw	r18, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1146:	00 97       	sbiw	r24, 0x00	; 0
    1148:	69 f0       	breq	.+26     	; 0x1164 <vTaskDelay+0x20>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    114a:	80 91 1f 02 	lds	r24, 0x021F
    114e:	8f 5f       	subi	r24, 0xFF	; 255
    1150:	80 93 1f 02 	sts	0x021F, r24
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1154:	c9 01       	movw	r24, r18
    1156:	60 e0       	ldi	r22, 0x00	; 0
    1158:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    115c:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1160:	88 23       	and	r24, r24
    1162:	11 f4       	brne	.+4      	; 0x1168 <vTaskDelay+0x24>
		{
			portYIELD_WITHIN_API();
    1164:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    1168:	08 95       	ret

0000116a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    116a:	fc 01       	movw	r30, r24
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    116c:	80 91 1f 02 	lds	r24, 0x021F
    1170:	8f 5f       	subi	r24, 0xFF	; 255
    1172:	80 93 1f 02 	sts	0x021F, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1176:	40 91 22 02 	lds	r20, 0x0222
    117a:	50 91 23 02 	lds	r21, 0x0223

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    117e:	20 81       	ld	r18, Z
    1180:	31 81       	ldd	r19, Z+1	; 0x01
    1182:	62 0f       	add	r22, r18
    1184:	73 1f       	adc	r23, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    1186:	42 17       	cp	r20, r18
    1188:	53 07       	cpc	r21, r19
    118a:	28 f4       	brcc	.+10     	; 0x1196 <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    118c:	62 17       	cp	r22, r18
    118e:	73 07       	cpc	r23, r19
    1190:	28 f0       	brcs	.+10     	; 0x119c <vTaskDelayUntil+0x32>
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	08 c0       	rjmp	.+16     	; 0x11a6 <vTaskDelayUntil+0x3c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1196:	62 17       	cp	r22, r18
    1198:	73 07       	cpc	r23, r19
    119a:	20 f0       	brcs	.+8      	; 0x11a4 <vTaskDelayUntil+0x3a>
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	46 17       	cp	r20, r22
    11a0:	57 07       	cpc	r21, r23
    11a2:	08 f4       	brcc	.+2      	; 0x11a6 <vTaskDelayUntil+0x3c>
    11a4:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    11a6:	71 83       	std	Z+1, r23	; 0x01
    11a8:	60 83       	st	Z, r22

			if( xShouldDelay != pdFALSE )
    11aa:	88 23       	and	r24, r24
    11ac:	31 f0       	breq	.+12     	; 0x11ba <vTaskDelayUntil+0x50>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    11ae:	cb 01       	movw	r24, r22
    11b0:	84 1b       	sub	r24, r20
    11b2:	95 0b       	sbc	r25, r21
    11b4:	60 e0       	ldi	r22, 0x00	; 0
    11b6:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    11ba:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    11be:	88 23       	and	r24, r24
    11c0:	11 f4       	brne	.+4      	; 0x11c6 <vTaskDelayUntil+0x5c>
		{
			portYIELD_WITHIN_API();
    11c2:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    11c6:	08 95       	ret

000011c8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	8b 01       	movw	r16, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    11ce:	60 91 1d 02 	lds	r22, 0x021D
    11d2:	70 91 1e 02 	lds	r23, 0x021E
    11d6:	64 5f       	subi	r22, 0xF4	; 244
    11d8:	7f 4f       	sbci	r23, 0xFF	; 255
    11da:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    11de:	c8 01       	movw	r24, r16
    11e0:	61 e0       	ldi	r22, 0x01	; 1
    11e2:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddCurrentTaskToDelayedList>
}
    11e6:	1f 91       	pop	r17
    11e8:	0f 91       	pop	r16
    11ea:	08 95       	ret

000011ec <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    11ec:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    11ee:	10 92 29 02 	sts	0x0229, r1
	vPortEndScheduler();
    11f2:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vPortEndScheduler>
}
    11f6:	08 95       	ret

000011f8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    11f8:	0f 93       	push	r16
    11fa:	1f 93       	push	r17
    11fc:	2c c0       	rjmp	.+88     	; 0x1256 <prvIdleTask+0x5e>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    11fe:	80 91 1f 02 	lds	r24, 0x021F
    1202:	8f 5f       	subi	r24, 0xFF	; 255
    1204:	80 93 1f 02 	sts	0x021F, r24
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1208:	10 91 71 02 	lds	r17, 0x0271
			}
			( void ) xTaskResumeAll();
    120c:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1210:	11 23       	and	r17, r17
    1212:	09 f1       	breq	.+66     	; 0x1256 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1214:	0f b6       	in	r0, 0x3f	; 63
    1216:	f8 94       	cli
    1218:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    121a:	e0 91 76 02 	lds	r30, 0x0276
    121e:	f0 91 77 02 	lds	r31, 0x0277
    1222:	06 81       	ldd	r16, Z+6	; 0x06
    1224:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1226:	c8 01       	movw	r24, r16
    1228:	02 96       	adiw	r24, 0x02	; 2
    122a:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
					--uxCurrentNumberOfTasks;
    122e:	80 91 28 02 	lds	r24, 0x0228
    1232:	81 50       	subi	r24, 0x01	; 1
    1234:	80 93 28 02 	sts	0x0228, r24
					--uxDeletedTasksWaitingCleanUp;
    1238:	80 91 2c 02 	lds	r24, 0x022C
    123c:	81 50       	subi	r24, 0x01	; 1
    123e:	80 93 2c 02 	sts	0x022C, r24
				}
				taskEXIT_CRITICAL();
    1242:	0f 90       	pop	r0
    1244:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1246:	f8 01       	movw	r30, r16
    1248:	87 89       	ldd	r24, Z+23	; 0x17
    124a:	90 8d       	ldd	r25, Z+24	; 0x18
    124c:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>
			vPortFree( pxTCB );
    1250:	c8 01       	movw	r24, r16
    1252:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1256:	80 91 2c 02 	lds	r24, 0x022C
    125a:	88 23       	and	r24, r24
    125c:	81 f6       	brne	.-96     	; 0x11fe <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    125e:	80 91 2e 02 	lds	r24, 0x022E
    1262:	82 30       	cpi	r24, 0x02	; 2
    1264:	10 f0       	brcs	.+4      	; 0x126a <prvIdleTask+0x72>
			{
				taskYIELD();
    1266:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    126a:	0e 94 95 00 	call	0x12a	; 0x12a <vApplicationIdleHook>
    126e:	f3 cf       	rjmp	.-26     	; 0x1256 <prvIdleTask+0x5e>

00001270 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1270:	0f 93       	push	r16
    1272:	1f 93       	push	r17
    1274:	cf 93       	push	r28
    1276:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1278:	0f b6       	in	r0, 0x3f	; 63
    127a:	f8 94       	cli
    127c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    127e:	00 97       	sbiw	r24, 0x00	; 0
    1280:	29 f4       	brne	.+10     	; 0x128c <vTaskDelete+0x1c>
    1282:	c0 91 1d 02 	lds	r28, 0x021D
    1286:	d0 91 1e 02 	lds	r29, 0x021E
    128a:	01 c0       	rjmp	.+2      	; 0x128e <vTaskDelete+0x1e>
    128c:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    128e:	8e 01       	movw	r16, r28
    1290:	0e 5f       	subi	r16, 0xFE	; 254
    1292:	1f 4f       	sbci	r17, 0xFF	; 255
    1294:	c8 01       	movw	r24, r16
    1296:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    129a:	8c 89       	ldd	r24, Y+20	; 0x14
    129c:	9d 89       	ldd	r25, Y+21	; 0x15
    129e:	89 2b       	or	r24, r25
    12a0:	21 f0       	breq	.+8      	; 0x12aa <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    12a2:	ce 01       	movw	r24, r28
    12a4:	0c 96       	adiw	r24, 0x0c	; 12
    12a6:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    12aa:	80 91 2d 02 	lds	r24, 0x022D
    12ae:	8f 5f       	subi	r24, 0xFF	; 255
    12b0:	80 93 2d 02 	sts	0x022D, r24

			if( pxTCB == pxCurrentTCB )
    12b4:	80 91 1d 02 	lds	r24, 0x021D
    12b8:	90 91 1e 02 	lds	r25, 0x021E
    12bc:	c8 17       	cp	r28, r24
    12be:	d9 07       	cpc	r29, r25
    12c0:	59 f4       	brne	.+22     	; 0x12d8 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    12c2:	81 e7       	ldi	r24, 0x71	; 113
    12c4:	92 e0       	ldi	r25, 0x02	; 2
    12c6:	b8 01       	movw	r22, r16
    12c8:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    12cc:	80 91 2c 02 	lds	r24, 0x022C
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	80 93 2c 02 	sts	0x022C, r24
    12d6:	26 c0       	rjmp	.+76     	; 0x1324 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    12d8:	80 91 28 02 	lds	r24, 0x0228
    12dc:	81 50       	subi	r24, 0x01	; 1
    12de:	80 93 28 02 	sts	0x0228, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    12e2:	8f 89       	ldd	r24, Y+23	; 0x17
    12e4:	98 8d       	ldd	r25, Y+24	; 0x18
    12e6:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>
			vPortFree( pxTCB );
    12ea:	ce 01       	movw	r24, r28
    12ec:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    12f0:	e0 91 64 02 	lds	r30, 0x0264
    12f4:	f0 91 65 02 	lds	r31, 0x0265
    12f8:	80 81       	ld	r24, Z
    12fa:	88 23       	and	r24, r24
    12fc:	19 f4       	brne	.+6      	; 0x1304 <vTaskDelete+0x94>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    12fe:	8f ef       	ldi	r24, 0xFF	; 255
    1300:	9f ef       	ldi	r25, 0xFF	; 255
    1302:	0c c0       	rjmp	.+24     	; 0x131c <vTaskDelete+0xac>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1304:	e0 91 64 02 	lds	r30, 0x0264
    1308:	f0 91 65 02 	lds	r31, 0x0265
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    130c:	05 80       	ldd	r0, Z+5	; 0x05
    130e:	f6 81       	ldd	r31, Z+6	; 0x06
    1310:	e0 2d       	mov	r30, r0
    1312:	06 80       	ldd	r0, Z+6	; 0x06
    1314:	f7 81       	ldd	r31, Z+7	; 0x07
    1316:	e0 2d       	mov	r30, r0
    1318:	82 81       	ldd	r24, Z+2	; 0x02
    131a:	93 81       	ldd	r25, Z+3	; 0x03
    131c:	90 93 25 02 	sts	0x0225, r25
    1320:	80 93 24 02 	sts	0x0224, r24
				prvResetNextTaskUnblockTime();
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1328:	80 91 29 02 	lds	r24, 0x0229
    132c:	88 23       	and	r24, r24
    132e:	49 f0       	breq	.+18     	; 0x1342 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    1330:	80 91 1d 02 	lds	r24, 0x021D
    1334:	90 91 1e 02 	lds	r25, 0x021E
    1338:	c8 17       	cp	r28, r24
    133a:	d9 07       	cpc	r29, r25
    133c:	11 f4       	brne	.+4      	; 0x1342 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    133e:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1342:	df 91       	pop	r29
    1344:	cf 91       	pop	r28
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	08 95       	ret

0000134c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    134c:	4f 92       	push	r4
    134e:	5f 92       	push	r5
    1350:	6f 92       	push	r6
    1352:	7f 92       	push	r7
    1354:	8f 92       	push	r8
    1356:	9f 92       	push	r9
    1358:	af 92       	push	r10
    135a:	bf 92       	push	r11
    135c:	cf 92       	push	r12
    135e:	df 92       	push	r13
    1360:	ef 92       	push	r14
    1362:	ff 92       	push	r15
    1364:	0f 93       	push	r16
    1366:	1f 93       	push	r17
    1368:	cf 93       	push	r28
    136a:	df 93       	push	r29
    136c:	2c 01       	movw	r4, r24
    136e:	16 2f       	mov	r17, r22
    1370:	97 2e       	mov	r9, r23
    1372:	6a 01       	movw	r12, r20
    1374:	39 01       	movw	r6, r18
    1376:	57 01       	movw	r10, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1378:	ca 01       	movw	r24, r20
    137a:	0e 94 31 11 	call	0x2262	; 0x2262 <pvPortMalloc>
    137e:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1380:	00 97       	sbiw	r24, 0x00	; 0
    1382:	99 f0       	breq	.+38     	; 0x13aa <xTaskCreate+0x5e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1384:	86 e2       	ldi	r24, 0x26	; 38
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	0e 94 31 11 	call	0x2262	; 0x2262 <pvPortMalloc>
    138c:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    138e:	00 97       	sbiw	r24, 0x00	; 0
    1390:	49 f0       	breq	.+18     	; 0x13a4 <xTaskCreate+0x58>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1392:	f8 8e       	std	Y+24, r15	; 0x18
    1394:	ef 8a       	std	Y+23, r14	; 0x17
    1396:	81 2f       	mov	r24, r17
    1398:	99 2d       	mov	r25, r9
    139a:	9c 01       	movw	r18, r24
    139c:	f9 01       	movw	r30, r18
    139e:	de 01       	movw	r26, r28
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	05 c0       	rjmp	.+10     	; 0x13ae <xTaskCreate+0x62>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    13a4:	c7 01       	movw	r24, r14
    13a6:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>
    13aa:	8f ef       	ldi	r24, 0xFF	; 255
    13ac:	b7 c0       	rjmp	.+366    	; 0x151c <xTaskCreate+0x1d0>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    13ae:	80 81       	ld	r24, Z
    13b0:	59 96       	adiw	r26, 0x19	; 25
    13b2:	8c 93       	st	X, r24
    13b4:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    13b6:	80 81       	ld	r24, Z
    13b8:	88 23       	and	r24, r24
    13ba:	29 f0       	breq	.+10     	; 0x13c6 <xTaskCreate+0x7a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    13bc:	9f 5f       	subi	r25, 0xFF	; 255
    13be:	31 96       	adiw	r30, 0x01	; 1
    13c0:	11 96       	adiw	r26, 0x01	; 1
    13c2:	98 30       	cpi	r25, 0x08	; 8
    13c4:	a1 f7       	brne	.-24     	; 0x13ae <xTaskCreate+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    13c6:	18 a2       	std	Y+32, r1	; 0x20
    13c8:	04 30       	cpi	r16, 0x04	; 4
    13ca:	08 f0       	brcs	.+2      	; 0x13ce <xTaskCreate+0x82>
    13cc:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    13ce:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    13d0:	72 e0       	ldi	r23, 0x02	; 2
    13d2:	87 2e       	mov	r8, r23
    13d4:	91 2c       	mov	r9, r1
    13d6:	8c 0e       	add	r8, r28
    13d8:	9d 1e       	adc	r9, r29
    13da:	c4 01       	movw	r24, r8
    13dc:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    13e0:	ce 01       	movw	r24, r28
    13e2:	0c 96       	adiw	r24, 0x0c	; 12
    13e4:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    13e8:	d9 87       	std	Y+9, r29	; 0x09
    13ea:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13ec:	84 e0       	ldi	r24, 0x04	; 4
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	80 1b       	sub	r24, r16
    13f2:	91 09       	sbc	r25, r1
    13f4:	9d 87       	std	Y+13, r25	; 0x0d
    13f6:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    13f8:	db 8b       	std	Y+19, r29	; 0x13
    13fa:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    13fc:	19 a2       	std	Y+33, r1	; 0x21
    13fe:	1a a2       	std	Y+34, r1	; 0x22
    1400:	1b a2       	std	Y+35, r1	; 0x23
    1402:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1404:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1406:	08 94       	sec
    1408:	c1 08       	sbc	r12, r1
    140a:	d1 08       	sbc	r13, r1
    140c:	c7 01       	movw	r24, r14
    140e:	8c 0d       	add	r24, r12
    1410:	9d 1d       	adc	r25, r13
    1412:	b2 01       	movw	r22, r4
    1414:	a3 01       	movw	r20, r6
    1416:	0e 94 63 11 	call	0x22c6	; 0x22c6 <pxPortInitialiseStack>
    141a:	99 83       	std	Y+1, r25	; 0x01
    141c:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    141e:	a1 14       	cp	r10, r1
    1420:	b1 04       	cpc	r11, r1
    1422:	19 f0       	breq	.+6      	; 0x142a <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1424:	f5 01       	movw	r30, r10
    1426:	d1 83       	std	Z+1, r29	; 0x01
    1428:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    142a:	0f b6       	in	r0, 0x3f	; 63
    142c:	f8 94       	cli
    142e:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1430:	80 91 28 02 	lds	r24, 0x0228
    1434:	8f 5f       	subi	r24, 0xFF	; 255
    1436:	80 93 28 02 	sts	0x0228, r24
		if( pxCurrentTCB == NULL )
    143a:	80 91 1d 02 	lds	r24, 0x021D
    143e:	90 91 1e 02 	lds	r25, 0x021E
    1442:	89 2b       	or	r24, r25
    1444:	a9 f5       	brne	.+106    	; 0x14b0 <xTaskCreate+0x164>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1446:	d0 93 1e 02 	sts	0x021E, r29
    144a:	c0 93 1d 02 	sts	0x021D, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    144e:	80 91 28 02 	lds	r24, 0x0228
    1452:	81 30       	cpi	r24, 0x01	; 1
    1454:	e9 f5       	brne	.+122    	; 0x14d0 <xTaskCreate+0x184>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1456:	8e e2       	ldi	r24, 0x2E	; 46
    1458:	92 e0       	ldi	r25, 0x02	; 2
    145a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
    145e:	87 e3       	ldi	r24, 0x37	; 55
    1460:	92 e0       	ldi	r25, 0x02	; 2
    1462:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
    1466:	80 e4       	ldi	r24, 0x40	; 64
    1468:	92 e0       	ldi	r25, 0x02	; 2
    146a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
    146e:	89 e4       	ldi	r24, 0x49	; 73
    1470:	92 e0       	ldi	r25, 0x02	; 2
    1472:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1476:	62 e5       	ldi	r22, 0x52	; 82
    1478:	e6 2e       	mov	r14, r22
    147a:	62 e0       	ldi	r22, 0x02	; 2
    147c:	f6 2e       	mov	r15, r22
    147e:	c7 01       	movw	r24, r14
    1480:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1484:	0b e5       	ldi	r16, 0x5B	; 91
    1486:	12 e0       	ldi	r17, 0x02	; 2
    1488:	c8 01       	movw	r24, r16
    148a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    148e:	88 e6       	ldi	r24, 0x68	; 104
    1490:	92 e0       	ldi	r25, 0x02	; 2
    1492:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1496:	81 e7       	ldi	r24, 0x71	; 113
    1498:	92 e0       	ldi	r25, 0x02	; 2
    149a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    149e:	f0 92 65 02 	sts	0x0265, r15
    14a2:	e0 92 64 02 	sts	0x0264, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    14a6:	10 93 67 02 	sts	0x0267, r17
    14aa:	00 93 66 02 	sts	0x0266, r16
    14ae:	10 c0       	rjmp	.+32     	; 0x14d0 <xTaskCreate+0x184>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    14b0:	80 91 29 02 	lds	r24, 0x0229
    14b4:	88 23       	and	r24, r24
    14b6:	61 f4       	brne	.+24     	; 0x14d0 <xTaskCreate+0x184>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    14b8:	e0 91 1d 02 	lds	r30, 0x021D
    14bc:	f0 91 1e 02 	lds	r31, 0x021E
    14c0:	96 89       	ldd	r25, Z+22	; 0x16
    14c2:	8e 89       	ldd	r24, Y+22	; 0x16
    14c4:	89 17       	cp	r24, r25
    14c6:	20 f0       	brcs	.+8      	; 0x14d0 <xTaskCreate+0x184>
				{
					pxCurrentTCB = pxNewTCB;
    14c8:	d0 93 1e 02 	sts	0x021E, r29
    14cc:	c0 93 1d 02 	sts	0x021D, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    14d0:	80 91 2d 02 	lds	r24, 0x022D
    14d4:	8f 5f       	subi	r24, 0xFF	; 255
    14d6:	80 93 2d 02 	sts	0x022D, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    14da:	9e 89       	ldd	r25, Y+22	; 0x16
    14dc:	80 91 20 02 	lds	r24, 0x0220
    14e0:	89 17       	cp	r24, r25
    14e2:	10 f4       	brcc	.+4      	; 0x14e8 <xTaskCreate+0x19c>
    14e4:	90 93 20 02 	sts	0x0220, r25
    14e8:	89 e0       	ldi	r24, 0x09	; 9
    14ea:	98 9f       	mul	r25, r24
    14ec:	c0 01       	movw	r24, r0
    14ee:	11 24       	eor	r1, r1
    14f0:	82 5d       	subi	r24, 0xD2	; 210
    14f2:	9d 4f       	sbci	r25, 0xFD	; 253
    14f4:	b4 01       	movw	r22, r8
    14f6:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    14fe:	80 91 29 02 	lds	r24, 0x0229
    1502:	88 23       	and	r24, r24
    1504:	51 f0       	breq	.+20     	; 0x151a <xTaskCreate+0x1ce>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1506:	e0 91 1d 02 	lds	r30, 0x021D
    150a:	f0 91 1e 02 	lds	r31, 0x021E
    150e:	96 89       	ldd	r25, Z+22	; 0x16
    1510:	8e 89       	ldd	r24, Y+22	; 0x16
    1512:	98 17       	cp	r25, r24
    1514:	10 f4       	brcc	.+4      	; 0x151a <xTaskCreate+0x1ce>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1516:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    151a:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    151c:	df 91       	pop	r29
    151e:	cf 91       	pop	r28
    1520:	1f 91       	pop	r17
    1522:	0f 91       	pop	r16
    1524:	ff 90       	pop	r15
    1526:	ef 90       	pop	r14
    1528:	df 90       	pop	r13
    152a:	cf 90       	pop	r12
    152c:	bf 90       	pop	r11
    152e:	af 90       	pop	r10
    1530:	9f 90       	pop	r9
    1532:	8f 90       	pop	r8
    1534:	7f 90       	pop	r7
    1536:	6f 90       	pop	r6
    1538:	5f 90       	pop	r5
    153a:	4f 90       	pop	r4
    153c:	08 95       	ret

0000153e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    153e:	ef 92       	push	r14
    1540:	ff 92       	push	r15
    1542:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1544:	8c ef       	ldi	r24, 0xFC	; 252
    1546:	98 e0       	ldi	r25, 0x08	; 8
    1548:	63 e1       	ldi	r22, 0x13	; 19
    154a:	72 e0       	ldi	r23, 0x02	; 2
    154c:	45 e5       	ldi	r20, 0x55	; 85
    154e:	50 e0       	ldi	r21, 0x00	; 0
    1550:	20 e0       	ldi	r18, 0x00	; 0
    1552:	30 e0       	ldi	r19, 0x00	; 0
    1554:	00 e0       	ldi	r16, 0x00	; 0
    1556:	ea e2       	ldi	r30, 0x2A	; 42
    1558:	ee 2e       	mov	r14, r30
    155a:	e2 e0       	ldi	r30, 0x02	; 2
    155c:	fe 2e       	mov	r15, r30
    155e:	0e 94 a6 09 	call	0x134c	; 0x134c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1562:	81 30       	cpi	r24, 0x01	; 1
    1564:	81 f4       	brne	.+32     	; 0x1586 <vTaskStartScheduler+0x48>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1566:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1568:	8f ef       	ldi	r24, 0xFF	; 255
    156a:	9f ef       	ldi	r25, 0xFF	; 255
    156c:	90 93 25 02 	sts	0x0225, r25
    1570:	80 93 24 02 	sts	0x0224, r24
		xSchedulerRunning = pdTRUE;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	80 93 29 02 	sts	0x0229, r24
		xTickCount = ( TickType_t ) 0U;
    157a:	10 92 23 02 	sts	0x0223, r1
    157e:	10 92 22 02 	sts	0x0222, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
    
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1582:	0e 94 ac 11 	call	0x2358	; 0x2358 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1586:	0f 91       	pop	r16
    1588:	ff 90       	pop	r15
    158a:	ef 90       	pop	r14
    158c:	08 95       	ret

0000158e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    158e:	0f b6       	in	r0, 0x3f	; 63
    1590:	f8 94       	cli
    1592:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1594:	fc 01       	movw	r30, r24
    1596:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1598:	0f 90       	pop	r0
    159a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    159c:	08 95       	ret

0000159e <uxQueueSpacesAvailable>:
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    159e:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15a0:	0f b6       	in	r0, 0x3f	; 63
    15a2:	f8 94       	cli
    15a4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    15a6:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	83 8d       	ldd	r24, Z+27	; 0x1b

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    15ae:	89 1b       	sub	r24, r25
    15b0:	08 95       	ret

000015b2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    15b2:	fc 01       	movw	r30, r24
    15b4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    15b6:	08 95       	ret

000015b8 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    15b8:	fc 01       	movw	r30, r24
    15ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	88 23       	and	r24, r24
    15c0:	09 f4       	brne	.+2      	; 0x15c4 <xQueueIsQueueEmptyFromISR+0xc>
    15c2:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    15c4:	89 2f       	mov	r24, r25
    15c6:	08 95       	ret

000015c8 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    15c8:	fc 01       	movw	r30, r24
    15ca:	92 8d       	ldd	r25, Z+26	; 0x1a
    15cc:	20 e0       	ldi	r18, 0x00	; 0
    15ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    15d0:	98 17       	cp	r25, r24
    15d2:	09 f4       	brne	.+2      	; 0x15d6 <xQueueIsQueueFullFromISR+0xe>
    15d4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    15d6:	82 2f       	mov	r24, r18
    15d8:	08 95       	ret

000015da <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    15da:	0f 93       	push	r16
    15dc:	1f 93       	push	r17
    15de:	cf 93       	push	r28
    15e0:	df 93       	push	r29
    15e2:	ec 01       	movw	r28, r24
    15e4:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15e6:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    15e8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    15ea:	44 23       	and	r20, r20
    15ec:	c1 f1       	breq	.+112    	; 0x165e <prvCopyDataToQueue+0x84>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    15ee:	00 23       	and	r16, r16
    15f0:	b1 f4       	brne	.+44     	; 0x161e <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    15f2:	8c 81       	ldd	r24, Y+4	; 0x04
    15f4:	9d 81       	ldd	r25, Y+5	; 0x05
    15f6:	50 e0       	ldi	r21, 0x00	; 0
    15f8:	0e 94 c2 12 	call	0x2584	; 0x2584 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15fc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1600:	3d 81       	ldd	r19, Y+5	; 0x05
    1602:	28 0f       	add	r18, r24
    1604:	31 1d       	adc	r19, r1
    1606:	3d 83       	std	Y+5, r19	; 0x05
    1608:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    160a:	8a 81       	ldd	r24, Y+2	; 0x02
    160c:	9b 81       	ldd	r25, Y+3	; 0x03
    160e:	28 17       	cp	r18, r24
    1610:	39 07       	cpc	r19, r25
    1612:	28 f1       	brcs	.+74     	; 0x165e <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1614:	88 81       	ld	r24, Y
    1616:	99 81       	ldd	r25, Y+1	; 0x01
    1618:	9d 83       	std	Y+5, r25	; 0x05
    161a:	8c 83       	std	Y+4, r24	; 0x04
    161c:	20 c0       	rjmp	.+64     	; 0x165e <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    161e:	8e 81       	ldd	r24, Y+6	; 0x06
    1620:	9f 81       	ldd	r25, Y+7	; 0x07
    1622:	50 e0       	ldi	r21, 0x00	; 0
    1624:	0e 94 c2 12 	call	0x2584	; 0x2584 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1628:	8c 8d       	ldd	r24, Y+28	; 0x1c
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	44 27       	eor	r20, r20
    162e:	55 27       	eor	r21, r21
    1630:	48 1b       	sub	r20, r24
    1632:	59 0b       	sbc	r21, r25
    1634:	8e 81       	ldd	r24, Y+6	; 0x06
    1636:	9f 81       	ldd	r25, Y+7	; 0x07
    1638:	84 0f       	add	r24, r20
    163a:	95 1f       	adc	r25, r21
    163c:	9f 83       	std	Y+7, r25	; 0x07
    163e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1640:	28 81       	ld	r18, Y
    1642:	39 81       	ldd	r19, Y+1	; 0x01
    1644:	82 17       	cp	r24, r18
    1646:	93 07       	cpc	r25, r19
    1648:	30 f4       	brcc	.+12     	; 0x1656 <prvCopyDataToQueue+0x7c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    164a:	8a 81       	ldd	r24, Y+2	; 0x02
    164c:	9b 81       	ldd	r25, Y+3	; 0x03
    164e:	84 0f       	add	r24, r20
    1650:	95 1f       	adc	r25, r21
    1652:	9f 83       	std	Y+7, r25	; 0x07
    1654:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1656:	02 30       	cpi	r16, 0x02	; 2
    1658:	11 f4       	brne	.+4      	; 0x165e <prvCopyDataToQueue+0x84>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    165a:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    165c:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    165e:	1f 5f       	subi	r17, 0xFF	; 255
    1660:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1662:	80 e0       	ldi	r24, 0x00	; 0
    1664:	df 91       	pop	r29
    1666:	cf 91       	pop	r28
    1668:	1f 91       	pop	r17
    166a:	0f 91       	pop	r16
    166c:	08 95       	ret

0000166e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    166e:	fc 01       	movw	r30, r24
    1670:	56 2f       	mov	r21, r22
    1672:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1674:	24 8d       	ldd	r18, Z+28	; 0x1c
    1676:	22 23       	and	r18, r18
    1678:	b9 f0       	breq	.+46     	; 0x16a8 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    167a:	86 81       	ldd	r24, Z+6	; 0x06
    167c:	97 81       	ldd	r25, Z+7	; 0x07
    167e:	82 0f       	add	r24, r18
    1680:	91 1d       	adc	r25, r1
    1682:	97 83       	std	Z+7, r25	; 0x07
    1684:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1686:	22 81       	ldd	r18, Z+2	; 0x02
    1688:	33 81       	ldd	r19, Z+3	; 0x03
    168a:	82 17       	cp	r24, r18
    168c:	93 07       	cpc	r25, r19
    168e:	20 f0       	brcs	.+8      	; 0x1698 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1690:	80 81       	ld	r24, Z
    1692:	91 81       	ldd	r25, Z+1	; 0x01
    1694:	97 83       	std	Z+7, r25	; 0x07
    1696:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1698:	44 8d       	ldd	r20, Z+28	; 0x1c
    169a:	66 81       	ldd	r22, Z+6	; 0x06
    169c:	77 81       	ldd	r23, Z+7	; 0x07
    169e:	85 2f       	mov	r24, r21
    16a0:	9a 2f       	mov	r25, r26
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	0e 94 c2 12 	call	0x2584	; 0x2584 <memcpy>
    16a8:	08 95       	ret

000016aa <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    16aa:	0f 93       	push	r16
    16ac:	1f 93       	push	r17
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    16b2:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    16b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16b6:	88 23       	and	r24, r24
    16b8:	41 f0       	breq	.+16     	; 0x16ca <xQueuePeekFromISR+0x20>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    16ba:	0e 81       	ldd	r16, Y+6	; 0x06
    16bc:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    16be:	ce 01       	movw	r24, r28
    16c0:	0e 94 37 0b 	call	0x166e	; 0x166e <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    16c4:	1f 83       	std	Y+7, r17	; 0x07
    16c6:	0e 83       	std	Y+6, r16	; 0x06
    16c8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	1f 91       	pop	r17
    16d0:	0f 91       	pop	r16
    16d2:	08 95       	ret

000016d4 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    16d4:	0f 93       	push	r16
    16d6:	1f 93       	push	r17
    16d8:	cf 93       	push	r28
    16da:	df 93       	push	r29
    16dc:	fb 01       	movw	r30, r22
    16de:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    16e0:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    16e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16e4:	88 23       	and	r24, r24
    16e6:	61 f1       	breq	.+88     	; 0x1740 <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    16e8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16ea:	2e 81       	ldd	r18, Y+6	; 0x06
    16ec:	3f 81       	ldd	r19, Y+7	; 0x07
    16ee:	28 0f       	add	r18, r24
    16f0:	31 1d       	adc	r19, r1
    16f2:	3f 83       	std	Y+7, r19	; 0x07
    16f4:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    16f6:	8a 81       	ldd	r24, Y+2	; 0x02
    16f8:	9b 81       	ldd	r25, Y+3	; 0x03
    16fa:	28 17       	cp	r18, r24
    16fc:	39 07       	cpc	r19, r25
    16fe:	20 f0       	brcs	.+8      	; 0x1708 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1700:	88 81       	ld	r24, Y
    1702:	99 81       	ldd	r25, Y+1	; 0x01
    1704:	9f 83       	std	Y+7, r25	; 0x07
    1706:	8e 83       	std	Y+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1708:	8a 8d       	ldd	r24, Y+26	; 0x1a
    170a:	81 50       	subi	r24, 0x01	; 1
    170c:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    170e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1710:	6e 81       	ldd	r22, Y+6	; 0x06
    1712:	7f 81       	ldd	r23, Y+7	; 0x07
    1714:	cf 01       	movw	r24, r30
    1716:	50 e0       	ldi	r21, 0x00	; 0
    1718:	0e 94 c2 12 	call	0x2584	; 0x2584 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    171c:	f8 01       	movw	r30, r16
    171e:	80 81       	ld	r24, Z
    1720:	88 23       	and	r24, r24
    1722:	69 f4       	brne	.+26     	; 0x173e <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1724:	88 85       	ldd	r24, Y+8	; 0x08
    1726:	88 23       	and	r24, r24
    1728:	51 f0       	breq	.+20     	; 0x173e <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    172a:	ce 01       	movw	r24, r28
    172c:	08 96       	adiw	r24, 0x08	; 8
    172e:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <xCoRoutineRemoveFromEventList>
    1732:	88 23       	and	r24, r24
    1734:	21 f0       	breq	.+8      	; 0x173e <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	f8 01       	movw	r30, r16
    173a:	80 83       	st	Z, r24
    173c:	01 c0       	rjmp	.+2      	; 0x1740 <xQueueCRReceiveFromISR+0x6c>
    173e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	08 95       	ret

0000174a <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    174a:	1f 93       	push	r17
    174c:	cf 93       	push	r28
    174e:	df 93       	push	r29
    1750:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1752:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1754:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1756:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1758:	98 17       	cp	r25, r24
    175a:	88 f4       	brcc	.+34     	; 0x177e <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    175c:	ce 01       	movw	r24, r28
    175e:	40 e0       	ldi	r20, 0x00	; 0
    1760:	0e 94 ed 0a 	call	0x15da	; 0x15da <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1764:	11 23       	and	r17, r17
    1766:	59 f4       	brne	.+22     	; 0x177e <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1768:	89 89       	ldd	r24, Y+17	; 0x11
    176a:	88 23       	and	r24, r24
    176c:	41 f0       	breq	.+16     	; 0x177e <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    176e:	ce 01       	movw	r24, r28
    1770:	41 96       	adiw	r24, 0x11	; 17
    1772:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <xCoRoutineRemoveFromEventList>
    1776:	48 2f       	mov	r20, r24
    1778:	81 11       	cpse	r24, r1
    177a:	41 e0       	ldi	r20, 0x01	; 1
    177c:	14 2f       	mov	r17, r20
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    177e:	81 2f       	mov	r24, r17
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	1f 91       	pop	r17
    1786:	08 95       	ret

00001788 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1788:	cf 93       	push	r28
    178a:	df 93       	push	r29
    178c:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    178e:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1790:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1792:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1794:	88 23       	and	r24, r24
    1796:	71 f4       	brne	.+28     	; 0x17b4 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1798:	41 15       	cp	r20, r1
    179a:	51 05       	cpc	r21, r1
    179c:	41 f0       	breq	.+16     	; 0x17ae <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    179e:	61 96       	adiw	r28, 0x11	; 17
    17a0:	ca 01       	movw	r24, r20
    17a2:	be 01       	movw	r22, r28
    17a4:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    17a8:	78 94       	sei
    17aa:	8c ef       	ldi	r24, 0xFC	; 252
    17ac:	2f c0       	rjmp	.+94     	; 0x180c <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    17ae:	78 94       	sei
    17b0:	80 e0       	ldi	r24, 0x00	; 0
    17b2:	2c c0       	rjmp	.+88     	; 0x180c <xQueueCRReceive+0x84>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    17b4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    17b6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    17b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17ba:	88 23       	and	r24, r24
    17bc:	31 f1       	breq	.+76     	; 0x180a <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    17be:	8c 8d       	ldd	r24, Y+28	; 0x1c
    17c0:	2e 81       	ldd	r18, Y+6	; 0x06
    17c2:	3f 81       	ldd	r19, Y+7	; 0x07
    17c4:	28 0f       	add	r18, r24
    17c6:	31 1d       	adc	r19, r1
    17c8:	3f 83       	std	Y+7, r19	; 0x07
    17ca:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    17cc:	8a 81       	ldd	r24, Y+2	; 0x02
    17ce:	9b 81       	ldd	r25, Y+3	; 0x03
    17d0:	28 17       	cp	r18, r24
    17d2:	39 07       	cpc	r19, r25
    17d4:	20 f0       	brcs	.+8      	; 0x17de <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    17d6:	88 81       	ld	r24, Y
    17d8:	99 81       	ldd	r25, Y+1	; 0x01
    17da:	9f 83       	std	Y+7, r25	; 0x07
    17dc:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    17de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17e0:	81 50       	subi	r24, 0x01	; 1
    17e2:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    17e4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    17e6:	6e 81       	ldd	r22, Y+6	; 0x06
    17e8:	7f 81       	ldd	r23, Y+7	; 0x07
    17ea:	cf 01       	movw	r24, r30
    17ec:	50 e0       	ldi	r21, 0x00	; 0
    17ee:	0e 94 c2 12 	call	0x2584	; 0x2584 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17f2:	88 85       	ldd	r24, Y+8	; 0x08
    17f4:	88 23       	and	r24, r24
    17f6:	41 f0       	breq	.+16     	; 0x1808 <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17f8:	ce 01       	movw	r24, r28
    17fa:	08 96       	adiw	r24, 0x08	; 8
    17fc:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <xCoRoutineRemoveFromEventList>
    1800:	88 23       	and	r24, r24
    1802:	11 f0       	breq	.+4      	; 0x1808 <xQueueCRReceive+0x80>
    1804:	8b ef       	ldi	r24, 0xFB	; 251
    1806:	01 c0       	rjmp	.+2      	; 0x180a <xQueueCRReceive+0x82>
    1808:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    180a:	78 94       	sei

		return xReturn;
	}
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	08 95       	ret

00001812 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1816:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1818:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1820:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1822:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1824:	0f 90       	pop	r0
    1826:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1828:	89 17       	cp	r24, r25
    182a:	71 f4       	brne	.+28     	; 0x1848 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    182c:	41 15       	cp	r20, r1
    182e:	51 05       	cpc	r21, r1
    1830:	41 f0       	breq	.+16     	; 0x1842 <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1832:	28 96       	adiw	r28, 0x08	; 8
    1834:	ca 01       	movw	r24, r20
    1836:	be 01       	movw	r22, r28
    1838:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    183c:	78 94       	sei
    183e:	8c ef       	ldi	r24, 0xFC	; 252
    1840:	1b c0       	rjmp	.+54     	; 0x1878 <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1842:	78 94       	sei
    1844:	80 e0       	ldi	r24, 0x00	; 0
    1846:	18 c0       	rjmp	.+48     	; 0x1878 <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    1848:	78 94       	sei

		portDISABLE_INTERRUPTS();
    184a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    184c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    184e:	89 17       	cp	r24, r25
    1850:	10 f0       	brcs	.+4      	; 0x1856 <xQueueCRSend+0x44>
    1852:	80 e0       	ldi	r24, 0x00	; 0
    1854:	10 c0       	rjmp	.+32     	; 0x1876 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1856:	ce 01       	movw	r24, r28
    1858:	40 e0       	ldi	r20, 0x00	; 0
    185a:	0e 94 ed 0a 	call	0x15da	; 0x15da <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    185e:	89 89       	ldd	r24, Y+17	; 0x11
    1860:	88 23       	and	r24, r24
    1862:	41 f0       	breq	.+16     	; 0x1874 <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1864:	ce 01       	movw	r24, r28
    1866:	41 96       	adiw	r24, 0x11	; 17
    1868:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <xCoRoutineRemoveFromEventList>
    186c:	88 23       	and	r24, r24
    186e:	11 f0       	breq	.+4      	; 0x1874 <xQueueCRSend+0x62>
    1870:	8b ef       	ldi	r24, 0xFB	; 251
    1872:	01 c0       	rjmp	.+2      	; 0x1876 <xQueueCRSend+0x64>
    1874:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1876:	78 94       	sei

		return xReturn;
	}
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	08 95       	ret

0000187e <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    187e:	0e 94 21 11 	call	0x2242	; 0x2242 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1882:	08 95       	ret

00001884 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1884:	ef 92       	push	r14
    1886:	ff 92       	push	r15
    1888:	0f 93       	push	r16
    188a:	1f 93       	push	r17
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1892:	ec 01       	movw	r28, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1894:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1896:	11 23       	and	r17, r17
    1898:	11 f4       	brne	.+4      	; 0x189e <xQueueReceiveFromISR+0x1a>
    189a:	80 e0       	ldi	r24, 0x00	; 0
    189c:	1a c0       	rjmp	.+52     	; 0x18d2 <xQueueReceiveFromISR+0x4e>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    189e:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18a0:	0e 94 37 0b 	call	0x166e	; 0x166e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    18a4:	11 50       	subi	r17, 0x01	; 1
    18a6:	1a 8f       	std	Y+26, r17	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    18a8:	0f 3f       	cpi	r16, 0xFF	; 255
    18aa:	81 f4       	brne	.+32     	; 0x18cc <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18ac:	88 85       	ldd	r24, Y+8	; 0x08
    18ae:	88 23       	and	r24, r24
    18b0:	79 f0       	breq	.+30     	; 0x18d0 <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18b2:	ce 01       	movw	r24, r28
    18b4:	08 96       	adiw	r24, 0x08	; 8
    18b6:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    18ba:	88 23       	and	r24, r24
    18bc:	49 f0       	breq	.+18     	; 0x18d0 <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    18be:	e1 14       	cp	r14, r1
    18c0:	f1 04       	cpc	r15, r1
    18c2:	31 f0       	breq	.+12     	; 0x18d0 <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	f7 01       	movw	r30, r14
    18c8:	80 83       	st	Z, r24
    18ca:	03 c0       	rjmp	.+6      	; 0x18d2 <xQueueReceiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    18cc:	0f 5f       	subi	r16, 0xFF	; 255
    18ce:	0d 8f       	std	Y+29, r16	; 0x1d
    18d0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	ff 90       	pop	r15
    18dc:	ef 90       	pop	r14
    18de:	08 95       	ret

000018e0 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
    18e4:	eb 01       	movw	r28, r22
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18e6:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18e8:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    18ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    18ec:	98 17       	cp	r25, r24
    18ee:	10 f0       	brcs	.+4      	; 0x18f4 <xQueueGiveFromISR+0x14>
    18f0:	80 e0       	ldi	r24, 0x00	; 0
    18f2:	16 c0       	rjmp	.+44     	; 0x1920 <xQueueGiveFromISR+0x40>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    18f4:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    18f6:	9f 5f       	subi	r25, 0xFF	; 255
    18f8:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    18fa:	8f 3f       	cpi	r24, 0xFF	; 255
    18fc:	71 f4       	brne	.+28     	; 0x191a <xQueueGiveFromISR+0x3a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18fe:	81 89       	ldd	r24, Z+17	; 0x11
    1900:	88 23       	and	r24, r24
    1902:	69 f0       	breq	.+26     	; 0x191e <xQueueGiveFromISR+0x3e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1904:	cf 01       	movw	r24, r30
    1906:	41 96       	adiw	r24, 0x11	; 17
    1908:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    190c:	88 23       	and	r24, r24
    190e:	39 f0       	breq	.+14     	; 0x191e <xQueueGiveFromISR+0x3e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1910:	20 97       	sbiw	r28, 0x00	; 0
    1912:	29 f0       	breq	.+10     	; 0x191e <xQueueGiveFromISR+0x3e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1914:	81 e0       	ldi	r24, 0x01	; 1
    1916:	88 83       	st	Y, r24
    1918:	03 c0       	rjmp	.+6      	; 0x1920 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    191a:	8f 5f       	subi	r24, 0xFF	; 255
    191c:	86 8f       	std	Z+30, r24	; 0x1e
    191e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1920:	df 91       	pop	r29
    1922:	cf 91       	pop	r28
    1924:	08 95       	ret

00001926 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1926:	ef 92       	push	r14
    1928:	ff 92       	push	r15
    192a:	1f 93       	push	r17
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1932:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1934:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1936:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1938:	98 17       	cp	r25, r24
    193a:	20 f0       	brcs	.+8      	; 0x1944 <xQueueGenericSendFromISR+0x1e>
    193c:	22 30       	cpi	r18, 0x02	; 2
    193e:	11 f0       	breq	.+4      	; 0x1944 <xQueueGenericSendFromISR+0x1e>
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	1a c0       	rjmp	.+52     	; 0x1978 <xQueueGenericSendFromISR+0x52>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1944:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1946:	ce 01       	movw	r24, r28
    1948:	42 2f       	mov	r20, r18
    194a:	0e 94 ed 0a 	call	0x15da	; 0x15da <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    194e:	1f 3f       	cpi	r17, 0xFF	; 255
    1950:	81 f4       	brne	.+32     	; 0x1972 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1952:	89 89       	ldd	r24, Y+17	; 0x11
    1954:	88 23       	and	r24, r24
    1956:	79 f0       	breq	.+30     	; 0x1976 <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1958:	ce 01       	movw	r24, r28
    195a:	41 96       	adiw	r24, 0x11	; 17
    195c:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    1960:	88 23       	and	r24, r24
    1962:	49 f0       	breq	.+18     	; 0x1976 <xQueueGenericSendFromISR+0x50>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1964:	e1 14       	cp	r14, r1
    1966:	f1 04       	cpc	r15, r1
    1968:	31 f0       	breq	.+12     	; 0x1976 <xQueueGenericSendFromISR+0x50>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    196a:	81 e0       	ldi	r24, 0x01	; 1
    196c:	f7 01       	movw	r30, r14
    196e:	80 83       	st	Z, r24
    1970:	03 c0       	rjmp	.+6      	; 0x1978 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1972:	1f 5f       	subi	r17, 0xFF	; 255
    1974:	1e 8f       	std	Y+30, r17	; 0x1e
    1976:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1978:	df 91       	pop	r29
    197a:	cf 91       	pop	r28
    197c:	1f 91       	pop	r17
    197e:	ff 90       	pop	r15
    1980:	ef 90       	pop	r14
    1982:	08 95       	ret

00001984 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1984:	ef 92       	push	r14
    1986:	ff 92       	push	r15
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1990:	0f b6       	in	r0, 0x3f	; 63
    1992:	f8 94       	cli
    1994:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1996:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1998:	91 e1       	ldi	r25, 0x11	; 17
    199a:	e9 2e       	mov	r14, r25
    199c:	f1 2c       	mov	r15, r1
    199e:	ec 0e       	add	r14, r28
    19a0:	fd 1e       	adc	r15, r29
    19a2:	0b c0       	rjmp	.+22     	; 0x19ba <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19a4:	89 89       	ldd	r24, Y+17	; 0x11
    19a6:	88 23       	and	r24, r24
    19a8:	51 f0       	breq	.+20     	; 0x19be <prvUnlockQueue+0x3a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19aa:	c7 01       	movw	r24, r14
    19ac:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    19b0:	88 23       	and	r24, r24
    19b2:	11 f0       	breq	.+4      	; 0x19b8 <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    19b4:	0e 94 38 04 	call	0x870	; 0x870 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    19b8:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    19ba:	11 16       	cp	r1, r17
    19bc:	9c f3       	brlt	.-26     	; 0x19a4 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    19be:	8f ef       	ldi	r24, 0xFF	; 255
    19c0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    19c2:	0f 90       	pop	r0
    19c4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    19cc:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19ce:	88 e0       	ldi	r24, 0x08	; 8
    19d0:	e8 2e       	mov	r14, r24
    19d2:	f1 2c       	mov	r15, r1
    19d4:	ec 0e       	add	r14, r28
    19d6:	fd 1e       	adc	r15, r29
    19d8:	0b c0       	rjmp	.+22     	; 0x19f0 <prvUnlockQueue+0x6c>
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19da:	88 85       	ldd	r24, Y+8	; 0x08
    19dc:	88 23       	and	r24, r24
    19de:	51 f0       	breq	.+20     	; 0x19f4 <prvUnlockQueue+0x70>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19e0:	c7 01       	movw	r24, r14
    19e2:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    19e6:	88 23       	and	r24, r24
    19e8:	11 f0       	breq	.+4      	; 0x19ee <prvUnlockQueue+0x6a>
				{
					vTaskMissedYield();
    19ea:	0e 94 38 04 	call	0x870	; 0x870 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    19ee:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    19f0:	11 16       	cp	r1, r17
    19f2:	9c f3       	brlt	.-26     	; 0x19da <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    19f4:	8f ef       	ldi	r24, 0xFF	; 255
    19f6:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    19f8:	0f 90       	pop	r0
    19fa:	0f be       	out	0x3f, r0	; 63
}
    19fc:	df 91       	pop	r29
    19fe:	cf 91       	pop	r28
    1a00:	1f 91       	pop	r17
    1a02:	ff 90       	pop	r15
    1a04:	ef 90       	pop	r14
    1a06:	08 95       	ret

00001a08 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a08:	6f 92       	push	r6
    1a0a:	7f 92       	push	r7
    1a0c:	8f 92       	push	r8
    1a0e:	9f 92       	push	r9
    1a10:	af 92       	push	r10
    1a12:	bf 92       	push	r11
    1a14:	cf 92       	push	r12
    1a16:	df 92       	push	r13
    1a18:	ef 92       	push	r14
    1a1a:	ff 92       	push	r15
    1a1c:	0f 93       	push	r16
    1a1e:	1f 93       	push	r17
    1a20:	df 93       	push	r29
    1a22:	cf 93       	push	r28
    1a24:	00 d0       	rcall	.+0      	; 0x1a26 <xQueueGenericReceive+0x1e>
    1a26:	0f 92       	push	r0
    1a28:	0f 92       	push	r0
    1a2a:	cd b7       	in	r28, 0x3d	; 61
    1a2c:	de b7       	in	r29, 0x3e	; 62
    1a2e:	4b 01       	movw	r8, r22
    1a30:	5d 83       	std	Y+5, r21	; 0x05
    1a32:	4c 83       	std	Y+4, r20	; 0x04
    1a34:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1a36:	8c 01       	movw	r16, r24
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a38:	41 e1       	ldi	r20, 0x11	; 17
    1a3a:	a4 2e       	mov	r10, r20
    1a3c:	b1 2c       	mov	r11, r1
    1a3e:	a8 0e       	add	r10, r24
    1a40:	b9 1e       	adc	r11, r25
    1a42:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a44:	6e 01       	movw	r12, r28
    1a46:	08 94       	sec
    1a48:	c1 1c       	adc	r12, r1
    1a4a:	d1 1c       	adc	r13, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a4c:	34 e0       	ldi	r19, 0x04	; 4
    1a4e:	63 2e       	mov	r6, r19
    1a50:	71 2c       	mov	r7, r1
    1a52:	6c 0e       	add	r6, r28
    1a54:	7d 1e       	adc	r7, r29
    1a56:	01 c0       	rjmp	.+2      	; 0x1a5a <xQueueGenericReceive+0x52>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a58:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a5a:	0f b6       	in	r0, 0x3f	; 63
    1a5c:	f8 94       	cli
    1a5e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a60:	f8 01       	movw	r30, r16
    1a62:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a64:	ff 20       	and	r15, r15
    1a66:	11 f1       	breq	.+68     	; 0x1aac <xQueueGenericReceive+0xa4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a68:	c6 80       	ldd	r12, Z+6	; 0x06
    1a6a:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a6c:	c8 01       	movw	r24, r16
    1a6e:	b4 01       	movw	r22, r8
    1a70:	0e 94 37 0b 	call	0x166e	; 0x166e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a74:	ee 20       	and	r14, r14
    1a76:	49 f4       	brne	.+18     	; 0x1a8a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1a78:	fa 94       	dec	r15
    1a7a:	f8 01       	movw	r30, r16
    1a7c:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a7e:	80 85       	ldd	r24, Z+8	; 0x08
    1a80:	88 23       	and	r24, r24
    1a82:	81 f0       	breq	.+32     	; 0x1aa4 <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a84:	c8 01       	movw	r24, r16
    1a86:	08 96       	adiw	r24, 0x08	; 8
    1a88:	07 c0       	rjmp	.+14     	; 0x1a98 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a8a:	f8 01       	movw	r30, r16
    1a8c:	d7 82       	std	Z+7, r13	; 0x07
    1a8e:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a90:	81 89       	ldd	r24, Z+17	; 0x11
    1a92:	88 23       	and	r24, r24
    1a94:	39 f0       	breq	.+14     	; 0x1aa4 <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a96:	c5 01       	movw	r24, r10
    1a98:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    1a9c:	88 23       	and	r24, r24
    1a9e:	11 f0       	breq	.+4      	; 0x1aa4 <xQueueGenericReceive+0x9c>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1aa0:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1aa4:	0f 90       	pop	r0
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	54 c0       	rjmp	.+168    	; 0x1b54 <xQueueGenericReceive+0x14c>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1aac:	8c 81       	ldd	r24, Y+4	; 0x04
    1aae:	9d 81       	ldd	r25, Y+5	; 0x05
    1ab0:	89 2b       	or	r24, r25
    1ab2:	21 f4       	brne	.+8      	; 0x1abc <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	80 e0       	ldi	r24, 0x00	; 0
    1aba:	4c c0       	rjmp	.+152    	; 0x1b54 <xQueueGenericReceive+0x14c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1abc:	22 23       	and	r18, r18
    1abe:	19 f4       	brne	.+6      	; 0x1ac6 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ac0:	c6 01       	movw	r24, r12
    1ac2:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1ac6:	0f 90       	pop	r0
    1ac8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1aca:	0e 94 9b 03 	call	0x736	; 0x736 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	0f 92       	push	r0
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ad8:	8f 3f       	cpi	r24, 0xFF	; 255
    1ada:	09 f4       	brne	.+2      	; 0x1ade <xQueueGenericReceive+0xd6>
    1adc:	15 8e       	std	Z+29, r1	; 0x1d
    1ade:	f8 01       	movw	r30, r16
    1ae0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ae2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ae4:	09 f4       	brne	.+2      	; 0x1ae8 <xQueueGenericReceive+0xe0>
    1ae6:	16 8e       	std	Z+30, r1	; 0x1e
    1ae8:	0f 90       	pop	r0
    1aea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aec:	c6 01       	movw	r24, r12
    1aee:	b3 01       	movw	r22, r6
    1af0:	0e 94 05 04 	call	0x80a	; 0x80a <xTaskCheckForTimeOut>
    1af4:	88 23       	and	r24, r24
    1af6:	f9 f4       	brne	.+62     	; 0x1b36 <xQueueGenericReceive+0x12e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1afe:	f8 01       	movw	r30, r16
    1b00:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b06:	88 23       	and	r24, r24
    1b08:	81 f4       	brne	.+32     	; 0x1b2a <xQueueGenericReceive+0x122>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b0a:	6c 81       	ldd	r22, Y+4	; 0x04
    1b0c:	7d 81       	ldd	r23, Y+5	; 0x05
    1b0e:	c5 01       	movw	r24, r10
    1b10:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b14:	c8 01       	movw	r24, r16
    1b16:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b1a:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
    1b1e:	88 23       	and	r24, r24
    1b20:	09 f0       	breq	.+2      	; 0x1b24 <xQueueGenericReceive+0x11c>
    1b22:	9a cf       	rjmp	.-204    	; 0x1a58 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    1b24:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    1b28:	97 cf       	rjmp	.-210    	; 0x1a58 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b2a:	c8 01       	movw	r24, r16
    1b2c:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b30:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
    1b34:	91 cf       	rjmp	.-222    	; 0x1a58 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b36:	c8 01       	movw	r24, r16
    1b38:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b3c:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b46:	f8 01       	movw	r30, r16
    1b48:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b4e:	88 23       	and	r24, r24
    1b50:	09 f0       	breq	.+2      	; 0x1b54 <xQueueGenericReceive+0x14c>
    1b52:	82 cf       	rjmp	.-252    	; 0x1a58 <xQueueGenericReceive+0x50>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1b54:	0f 90       	pop	r0
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	cf 91       	pop	r28
    1b60:	df 91       	pop	r29
    1b62:	1f 91       	pop	r17
    1b64:	0f 91       	pop	r16
    1b66:	ff 90       	pop	r15
    1b68:	ef 90       	pop	r14
    1b6a:	df 90       	pop	r13
    1b6c:	cf 90       	pop	r12
    1b6e:	bf 90       	pop	r11
    1b70:	af 90       	pop	r10
    1b72:	9f 90       	pop	r9
    1b74:	8f 90       	pop	r8
    1b76:	7f 90       	pop	r7
    1b78:	6f 90       	pop	r6
    1b7a:	08 95       	ret

00001b7c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1b7c:	6f 92       	push	r6
    1b7e:	7f 92       	push	r7
    1b80:	9f 92       	push	r9
    1b82:	af 92       	push	r10
    1b84:	bf 92       	push	r11
    1b86:	cf 92       	push	r12
    1b88:	df 92       	push	r13
    1b8a:	ef 92       	push	r14
    1b8c:	ff 92       	push	r15
    1b8e:	0f 93       	push	r16
    1b90:	1f 93       	push	r17
    1b92:	df 93       	push	r29
    1b94:	cf 93       	push	r28
    1b96:	00 d0       	rcall	.+0      	; 0x1b98 <xQueueGenericSend+0x1c>
    1b98:	0f 92       	push	r0
    1b9a:	0f 92       	push	r0
    1b9c:	cd b7       	in	r28, 0x3d	; 61
    1b9e:	de b7       	in	r29, 0x3e	; 62
    1ba0:	6b 01       	movw	r12, r22
    1ba2:	5d 83       	std	Y+5, r21	; 0x05
    1ba4:	4c 83       	std	Y+4, r20	; 0x04
    1ba6:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1ba8:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1baa:	68 e0       	ldi	r22, 0x08	; 8
    1bac:	e6 2e       	mov	r14, r22
    1bae:	f1 2c       	mov	r15, r1
    1bb0:	e8 0e       	add	r14, r24
    1bb2:	f9 1e       	adc	r15, r25
    1bb4:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bb6:	5e 01       	movw	r10, r28
    1bb8:	08 94       	sec
    1bba:	a1 1c       	adc	r10, r1
    1bbc:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bbe:	54 e0       	ldi	r21, 0x04	; 4
    1bc0:	65 2e       	mov	r6, r21
    1bc2:	71 2c       	mov	r7, r1
    1bc4:	6c 0e       	add	r6, r28
    1bc6:	7d 1e       	adc	r7, r29
    1bc8:	01 c0       	rjmp	.+2      	; 0x1bcc <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1bca:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1bd2:	f8 01       	movw	r30, r16
    1bd4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bd6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bd8:	98 17       	cp	r25, r24
    1bda:	18 f0       	brcs	.+6      	; 0x1be2 <xQueueGenericSend+0x66>
    1bdc:	f2 e0       	ldi	r31, 0x02	; 2
    1bde:	9f 16       	cp	r9, r31
    1be0:	c9 f4       	brne	.+50     	; 0x1c14 <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1be2:	c8 01       	movw	r24, r16
    1be4:	b6 01       	movw	r22, r12
    1be6:	49 2d       	mov	r20, r9
    1be8:	0e 94 ed 0a 	call	0x15da	; 0x15da <prvCopyDataToQueue>
    1bec:	98 2f       	mov	r25, r24
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bee:	f8 01       	movw	r30, r16
    1bf0:	81 89       	ldd	r24, Z+17	; 0x11
    1bf2:	88 23       	and	r24, r24
    1bf4:	39 f0       	breq	.+14     	; 0x1c04 <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bf6:	c8 01       	movw	r24, r16
    1bf8:	41 96       	adiw	r24, 0x11	; 17
    1bfa:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    1bfe:	88 23       	and	r24, r24
    1c00:	29 f0       	breq	.+10     	; 0x1c0c <xQueueGenericSend+0x90>
    1c02:	02 c0       	rjmp	.+4      	; 0x1c08 <xQueueGenericSend+0x8c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1c04:	99 23       	and	r25, r25
    1c06:	11 f0       	breq	.+4      	; 0x1c0c <xQueueGenericSend+0x90>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1c08:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1c0c:	0f 90       	pop	r0
    1c0e:	0f be       	out	0x3f, r0	; 63
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	4c c0       	rjmp	.+152    	; 0x1cac <xQueueGenericSend+0x130>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c14:	8c 81       	ldd	r24, Y+4	; 0x04
    1c16:	9d 81       	ldd	r25, Y+5	; 0x05
    1c18:	89 2b       	or	r24, r25
    1c1a:	19 f4       	brne	.+6      	; 0x1c22 <xQueueGenericSend+0xa6>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63
    1c20:	44 c0       	rjmp	.+136    	; 0x1caa <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1c22:	22 23       	and	r18, r18
    1c24:	19 f4       	brne	.+6      	; 0x1c2c <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c26:	c5 01       	movw	r24, r10
    1c28:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c2c:	0f 90       	pop	r0
    1c2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c30:	0e 94 9b 03 	call	0x736	; 0x736 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	0f 92       	push	r0
    1c3a:	f8 01       	movw	r30, r16
    1c3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c40:	09 f4       	brne	.+2      	; 0x1c44 <xQueueGenericSend+0xc8>
    1c42:	15 8e       	std	Z+29, r1	; 0x1d
    1c44:	f8 01       	movw	r30, r16
    1c46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c48:	8f 3f       	cpi	r24, 0xFF	; 255
    1c4a:	09 f4       	brne	.+2      	; 0x1c4e <xQueueGenericSend+0xd2>
    1c4c:	16 8e       	std	Z+30, r1	; 0x1e
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c52:	c5 01       	movw	r24, r10
    1c54:	b3 01       	movw	r22, r6
    1c56:	0e 94 05 04 	call	0x80a	; 0x80a <xTaskCheckForTimeOut>
    1c5a:	88 23       	and	r24, r24
    1c5c:	09 f5       	brne	.+66     	; 0x1ca0 <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1c64:	f8 01       	movw	r30, r16
    1c66:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c6c:	f8 01       	movw	r30, r16
    1c6e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c70:	98 17       	cp	r25, r24
    1c72:	81 f4       	brne	.+32     	; 0x1c94 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c74:	6c 81       	ldd	r22, Y+4	; 0x04
    1c76:	7d 81       	ldd	r23, Y+5	; 0x05
    1c78:	c7 01       	movw	r24, r14
    1c7a:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1c7e:	c8 01       	movw	r24, r16
    1c80:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1c84:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
    1c88:	88 23       	and	r24, r24
    1c8a:	09 f0       	breq	.+2      	; 0x1c8e <xQueueGenericSend+0x112>
    1c8c:	9e cf       	rjmp	.-196    	; 0x1bca <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1c8e:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    1c92:	9b cf       	rjmp	.-202    	; 0x1bca <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c94:	c8 01       	movw	r24, r16
    1c96:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c9a:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
    1c9e:	95 cf       	rjmp	.-214    	; 0x1bca <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1ca0:	c8 01       	movw	r24, r16
    1ca2:	0e 94 c2 0c 	call	0x1984	; 0x1984 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ca6:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
    1caa:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1cac:	0f 90       	pop	r0
    1cae:	0f 90       	pop	r0
    1cb0:	0f 90       	pop	r0
    1cb2:	0f 90       	pop	r0
    1cb4:	0f 90       	pop	r0
    1cb6:	cf 91       	pop	r28
    1cb8:	df 91       	pop	r29
    1cba:	1f 91       	pop	r17
    1cbc:	0f 91       	pop	r16
    1cbe:	ff 90       	pop	r15
    1cc0:	ef 90       	pop	r14
    1cc2:	df 90       	pop	r13
    1cc4:	cf 90       	pop	r12
    1cc6:	bf 90       	pop	r11
    1cc8:	af 90       	pop	r10
    1cca:	9f 90       	pop	r9
    1ccc:	7f 90       	pop	r7
    1cce:	6f 90       	pop	r6
    1cd0:	08 95       	ret

00001cd2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1cd2:	cf 93       	push	r28
    1cd4:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1cd6:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cd8:	0f b6       	in	r0, 0x3f	; 63
    1cda:	f8 94       	cli
    1cdc:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1cde:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1ce0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1ce2:	e2 9f       	mul	r30, r18
    1ce4:	c0 01       	movw	r24, r0
    1ce6:	11 24       	eor	r1, r1
    1ce8:	48 81       	ld	r20, Y
    1cea:	59 81       	ldd	r21, Y+1	; 0x01
    1cec:	84 0f       	add	r24, r20
    1cee:	95 1f       	adc	r25, r21
    1cf0:	9b 83       	std	Y+3, r25	; 0x03
    1cf2:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1cf4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1cf6:	5d 83       	std	Y+5, r21	; 0x05
    1cf8:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1cfa:	30 e0       	ldi	r19, 0x00	; 0
    1cfc:	21 50       	subi	r18, 0x01	; 1
    1cfe:	30 40       	sbci	r19, 0x00	; 0
    1d00:	f0 e0       	ldi	r31, 0x00	; 0
    1d02:	2e 9f       	mul	r18, r30
    1d04:	c0 01       	movw	r24, r0
    1d06:	2f 9f       	mul	r18, r31
    1d08:	90 0d       	add	r25, r0
    1d0a:	3e 9f       	mul	r19, r30
    1d0c:	90 0d       	add	r25, r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	48 0f       	add	r20, r24
    1d12:	59 1f       	adc	r21, r25
    1d14:	5f 83       	std	Y+7, r21	; 0x07
    1d16:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1d18:	8f ef       	ldi	r24, 0xFF	; 255
    1d1a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1d1c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1d1e:	66 23       	and	r22, r22
    1d20:	61 f4       	brne	.+24     	; 0x1d3a <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d22:	88 85       	ldd	r24, Y+8	; 0x08
    1d24:	88 23       	and	r24, r24
    1d26:	89 f0       	breq	.+34     	; 0x1d4a <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d28:	ce 01       	movw	r24, r28
    1d2a:	08 96       	adiw	r24, 0x08	; 8
    1d2c:	0e 94 6a 05 	call	0xad4	; 0xad4 <xTaskRemoveFromEventList>
    1d30:	88 23       	and	r24, r24
    1d32:	59 f0       	breq	.+22     	; 0x1d4a <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1d34:	0e 94 47 12 	call	0x248e	; 0x248e <vPortYield>
    1d38:	08 c0       	rjmp	.+16     	; 0x1d4a <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1d3a:	ce 01       	movw	r24, r28
    1d3c:	08 96       	adiw	r24, 0x08	; 8
    1d3e:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1d42:	ce 01       	movw	r24, r28
    1d44:	41 96       	adiw	r24, 0x11	; 17
    1d46:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1d4a:	0f 90       	pop	r0
    1d4c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	df 91       	pop	r29
    1d52:	cf 91       	pop	r28
    1d54:	08 95       	ret

00001d56 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1d56:	0f 93       	push	r16
    1d58:	1f 93       	push	r17
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	08 2f       	mov	r16, r24
    1d60:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1d62:	66 23       	and	r22, r22
    1d64:	19 f4       	brne	.+6      	; 0x1d6c <xQueueGenericCreate+0x16>
    1d66:	80 e0       	ldi	r24, 0x00	; 0
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	03 c0       	rjmp	.+6      	; 0x1d72 <xQueueGenericCreate+0x1c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d6c:	68 9f       	mul	r22, r24
    1d6e:	c0 01       	movw	r24, r0
    1d70:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1d72:	4f 96       	adiw	r24, 0x1f	; 31
    1d74:	0e 94 31 11 	call	0x2262	; 0x2262 <pvPortMalloc>
    1d78:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1d7a:	00 97       	sbiw	r24, 0x00	; 0
    1d7c:	71 f0       	breq	.+28     	; 0x1d9a <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1d7e:	11 23       	and	r17, r17
    1d80:	19 f4       	brne	.+6      	; 0x1d88 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1d82:	99 83       	std	Y+1, r25	; 0x01
    1d84:	88 83       	st	Y, r24
    1d86:	03 c0       	rjmp	.+6      	; 0x1d8e <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1d88:	4f 96       	adiw	r24, 0x1f	; 31
    1d8a:	99 83       	std	Y+1, r25	; 0x01
    1d8c:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1d8e:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1d90:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1d92:	ce 01       	movw	r24, r28
    1d94:	61 e0       	ldi	r22, 0x01	; 1
    1d96:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	df 91       	pop	r29
    1d9e:	cf 91       	pop	r28
    1da0:	1f 91       	pop	r17
    1da2:	0f 91       	pop	r16
    1da4:	08 95       	ret

00001da6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1da6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1da8:	9c 01       	movw	r18, r24
    1daa:	2d 5f       	subi	r18, 0xFD	; 253
    1dac:	3f 4f       	sbci	r19, 0xFF	; 255
    1dae:	32 83       	std	Z+2, r19	; 0x02
    1db0:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1db2:	8f ef       	ldi	r24, 0xFF	; 255
    1db4:	9f ef       	ldi	r25, 0xFF	; 255
    1db6:	94 83       	std	Z+4, r25	; 0x04
    1db8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1dba:	36 83       	std	Z+6, r19	; 0x06
    1dbc:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1dbe:	30 87       	std	Z+8, r19	; 0x08
    1dc0:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1dc2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1dc4:	08 95       	ret

00001dc6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1dc6:	fc 01       	movw	r30, r24
    1dc8:	11 86       	std	Z+9, r1	; 0x09
    1dca:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1dcc:	08 95       	ret

00001dce <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1dce:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	a1 81       	ldd	r26, Z+1	; 0x01
    1dd4:	b2 81       	ldd	r27, Z+2	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1dd6:	fb 01       	movw	r30, r22
    1dd8:	b3 83       	std	Z+3, r27	; 0x03
    1dda:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1ddc:	14 96       	adiw	r26, 0x04	; 4
    1dde:	8d 91       	ld	r24, X+
    1de0:	9c 91       	ld	r25, X
    1de2:	15 97       	sbiw	r26, 0x05	; 5
    1de4:	95 83       	std	Z+5, r25	; 0x05
    1de6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1de8:	14 96       	adiw	r26, 0x04	; 4
    1dea:	ed 91       	ld	r30, X+
    1dec:	fc 91       	ld	r31, X
    1dee:	15 97       	sbiw	r26, 0x05	; 5
    1df0:	73 83       	std	Z+3, r23	; 0x03
    1df2:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1df4:	15 96       	adiw	r26, 0x05	; 5
    1df6:	7c 93       	st	X, r23
    1df8:	6e 93       	st	-X, r22
    1dfa:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1dfc:	fb 01       	movw	r30, r22
    1dfe:	51 87       	std	Z+9, r21	; 0x09
    1e00:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    1e02:	fa 01       	movw	r30, r20
    1e04:	80 81       	ld	r24, Z
    1e06:	8f 5f       	subi	r24, 0xFF	; 255
    1e08:	80 83       	st	Z, r24
}
    1e0a:	08 95       	ret

00001e0c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	9c 01       	movw	r18, r24
    1e12:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1e14:	48 81       	ld	r20, Y
    1e16:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1e18:	8f ef       	ldi	r24, 0xFF	; 255
    1e1a:	4f 3f       	cpi	r20, 0xFF	; 255
    1e1c:	58 07       	cpc	r21, r24
    1e1e:	21 f4       	brne	.+8      	; 0x1e28 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1e20:	f9 01       	movw	r30, r18
    1e22:	a7 81       	ldd	r26, Z+7	; 0x07
    1e24:	b0 85       	ldd	r27, Z+8	; 0x08
    1e26:	0d c0       	rjmp	.+26     	; 0x1e42 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e28:	d9 01       	movw	r26, r18
    1e2a:	13 96       	adiw	r26, 0x03	; 3
    1e2c:	12 96       	adiw	r26, 0x02	; 2
    1e2e:	ed 91       	ld	r30, X+
    1e30:	fc 91       	ld	r31, X
    1e32:	13 97       	sbiw	r26, 0x03	; 3
    1e34:	80 81       	ld	r24, Z
    1e36:	91 81       	ldd	r25, Z+1	; 0x01
    1e38:	48 17       	cp	r20, r24
    1e3a:	59 07       	cpc	r21, r25
    1e3c:	10 f0       	brcs	.+4      	; 0x1e42 <vListInsert+0x36>
    1e3e:	df 01       	movw	r26, r30
    1e40:	f5 cf       	rjmp	.-22     	; 0x1e2c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1e42:	12 96       	adiw	r26, 0x02	; 2
    1e44:	ed 91       	ld	r30, X+
    1e46:	fc 91       	ld	r31, X
    1e48:	13 97       	sbiw	r26, 0x03	; 3
    1e4a:	fb 83       	std	Y+3, r31	; 0x03
    1e4c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1e4e:	d5 83       	std	Z+5, r29	; 0x05
    1e50:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1e52:	bd 83       	std	Y+5, r27	; 0x05
    1e54:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1e56:	13 96       	adiw	r26, 0x03	; 3
    1e58:	dc 93       	st	X, r29
    1e5a:	ce 93       	st	-X, r28
    1e5c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e5e:	39 87       	std	Y+9, r19	; 0x09
    1e60:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1e62:	f9 01       	movw	r30, r18
    1e64:	80 81       	ld	r24, Z
    1e66:	8f 5f       	subi	r24, 0xFF	; 255
    1e68:	80 83       	st	Z, r24
}
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	08 95       	ret

00001e70 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1e76:	18 96       	adiw	r26, 0x08	; 8
    1e78:	cd 91       	ld	r28, X+
    1e7a:	dc 91       	ld	r29, X
    1e7c:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e7e:	12 96       	adiw	r26, 0x02	; 2
    1e80:	4d 91       	ld	r20, X+
    1e82:	5c 91       	ld	r21, X
    1e84:	13 97       	sbiw	r26, 0x03	; 3
    1e86:	14 96       	adiw	r26, 0x04	; 4
    1e88:	8d 91       	ld	r24, X+
    1e8a:	9c 91       	ld	r25, X
    1e8c:	15 97       	sbiw	r26, 0x05	; 5
    1e8e:	fa 01       	movw	r30, r20
    1e90:	95 83       	std	Z+5, r25	; 0x05
    1e92:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e94:	14 96       	adiw	r26, 0x04	; 4
    1e96:	2d 91       	ld	r18, X+
    1e98:	3c 91       	ld	r19, X
    1e9a:	15 97       	sbiw	r26, 0x05	; 5
    1e9c:	f9 01       	movw	r30, r18
    1e9e:	53 83       	std	Z+3, r21	; 0x03
    1ea0:	42 83       	std	Z+2, r20	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea6:	8a 17       	cp	r24, r26
    1ea8:	9b 07       	cpc	r25, r27
    1eaa:	11 f4       	brne	.+4      	; 0x1eb0 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1eac:	3a 83       	std	Y+2, r19	; 0x02
    1eae:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1eb0:	19 96       	adiw	r26, 0x09	; 9
    1eb2:	1c 92       	st	X, r1
    1eb4:	1e 92       	st	-X, r1
    1eb6:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1eb8:	88 81       	ld	r24, Y
    1eba:	81 50       	subi	r24, 0x01	; 1
    1ebc:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
    1ebe:	df 91       	pop	r29
    1ec0:	cf 91       	pop	r28
    1ec2:	08 95       	ret

00001ec4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1ec4:	ef 92       	push	r14
    1ec6:	ff 92       	push	r15
    1ec8:	0f 93       	push	r16
    1eca:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1ecc:	dc 01       	movw	r26, r24
    1ece:	15 96       	adiw	r26, 0x05	; 5
    1ed0:	ed 91       	ld	r30, X+
    1ed2:	fc 91       	ld	r31, X
    1ed4:	16 97       	sbiw	r26, 0x06	; 6
    1ed6:	e6 80       	ldd	r14, Z+6	; 0x06
    1ed8:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1eda:	87 01       	movw	r16, r14
    1edc:	04 5f       	subi	r16, 0xF4	; 244
    1ede:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee0:	c8 01       	movw	r24, r16
    1ee2:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1ee6:	8b ea       	ldi	r24, 0xAB	; 171
    1ee8:	92 e0       	ldi	r25, 0x02	; 2
    1eea:	b8 01       	movw	r22, r16
    1eec:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
    1ef0:	20 e0       	ldi	r18, 0x00	; 0
    1ef2:	e0 91 7a 02 	lds	r30, 0x027A
    1ef6:	f0 91 7b 02 	lds	r31, 0x027B
    1efa:	d7 01       	movw	r26, r14
    1efc:	56 96       	adiw	r26, 0x16	; 22
    1efe:	9c 91       	ld	r25, X
    1f00:	86 89       	ldd	r24, Z+22	; 0x16
    1f02:	98 17       	cp	r25, r24
    1f04:	08 f0       	brcs	.+2      	; 0x1f08 <xCoRoutineRemoveFromEventList+0x44>
    1f06:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1f08:	82 2f       	mov	r24, r18
    1f0a:	1f 91       	pop	r17
    1f0c:	0f 91       	pop	r16
    1f0e:	ff 90       	pop	r15
    1f10:	ef 90       	pop	r14
    1f12:	08 95       	ret

00001f14 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1f14:	ff 92       	push	r15
    1f16:	0f 93       	push	r16
    1f18:	1f 93       	push	r17
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f1e:	99 e0       	ldi	r25, 0x09	; 9
    1f20:	f9 2e       	mov	r15, r25
    1f22:	21 c0       	rjmp	.+66     	; 0x1f66 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1f24:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1f26:	e0 91 b0 02 	lds	r30, 0x02B0
    1f2a:	f0 91 b1 02 	lds	r31, 0x02B1
    1f2e:	06 81       	ldd	r16, Z+6	; 0x06
    1f30:	17 81       	ldd	r17, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f32:	c8 01       	movw	r24, r16
    1f34:	0c 96       	adiw	r24, 0x0c	; 12
    1f36:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1f3a:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f3c:	e8 01       	movw	r28, r16
    1f3e:	22 96       	adiw	r28, 0x02	; 2
    1f40:	ce 01       	movw	r24, r28
    1f42:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f46:	f8 01       	movw	r30, r16
    1f48:	96 89       	ldd	r25, Z+22	; 0x16
    1f4a:	80 91 7c 02 	lds	r24, 0x027C
    1f4e:	89 17       	cp	r24, r25
    1f50:	10 f4       	brcc	.+4      	; 0x1f56 <vCoRoutineSchedule+0x42>
    1f52:	90 93 7c 02 	sts	0x027C, r25
    1f56:	9f 9d       	mul	r25, r15
    1f58:	c0 01       	movw	r24, r0
    1f5a:	11 24       	eor	r1, r1
    1f5c:	8d 57       	subi	r24, 0x7D	; 125
    1f5e:	9d 4f       	sbci	r25, 0xFD	; 253
    1f60:	be 01       	movw	r22, r28
    1f62:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1f66:	80 91 ab 02 	lds	r24, 0x02AB
    1f6a:	88 23       	and	r24, r24
    1f6c:	d9 f6       	brne	.-74     	; 0x1f24 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1f6e:	0e 94 a1 03 	call	0x742	; 0x742 <xTaskGetTickCount>
    1f72:	20 91 7d 02 	lds	r18, 0x027D
    1f76:	30 91 7e 02 	lds	r19, 0x027E
    1f7a:	82 1b       	sub	r24, r18
    1f7c:	93 0b       	sbc	r25, r19
    1f7e:	90 93 80 02 	sts	0x0280, r25
    1f82:	80 93 7f 02 	sts	0x027F, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f86:	89 e0       	ldi	r24, 0x09	; 9
    1f88:	f8 2e       	mov	r15, r24
    1f8a:	53 c0       	rjmp	.+166    	; 0x2032 <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1f8c:	01 96       	adiw	r24, 0x01	; 1
    1f8e:	90 93 82 02 	sts	0x0282, r25
    1f92:	80 93 81 02 	sts	0x0281, r24
		xPassedTicks--;
    1f96:	21 50       	subi	r18, 0x01	; 1
    1f98:	30 40       	sbci	r19, 0x00	; 0
    1f9a:	30 93 80 02 	sts	0x0280, r19
    1f9e:	20 93 7f 02 	sts	0x027F, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1fa2:	89 2b       	or	r24, r25
    1fa4:	09 f0       	breq	.+2      	; 0x1fa8 <vCoRoutineSchedule+0x94>
    1fa6:	3e c0       	rjmp	.+124    	; 0x2024 <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1fa8:	20 91 a7 02 	lds	r18, 0x02A7
    1fac:	30 91 a8 02 	lds	r19, 0x02A8
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1fb0:	80 91 a9 02 	lds	r24, 0x02A9
    1fb4:	90 91 aa 02 	lds	r25, 0x02AA
    1fb8:	90 93 a8 02 	sts	0x02A8, r25
    1fbc:	80 93 a7 02 	sts	0x02A7, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1fc0:	30 93 aa 02 	sts	0x02AA, r19
    1fc4:	20 93 a9 02 	sts	0x02A9, r18
    1fc8:	2d c0       	rjmp	.+90     	; 0x2024 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1fca:	05 80       	ldd	r0, Z+5	; 0x05
    1fcc:	f6 81       	ldd	r31, Z+6	; 0x06
    1fce:	e0 2d       	mov	r30, r0
    1fd0:	c6 81       	ldd	r28, Z+6	; 0x06
    1fd2:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1fd4:	20 91 81 02 	lds	r18, 0x0281
    1fd8:	30 91 82 02 	lds	r19, 0x0282
    1fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fde:	9b 81       	ldd	r25, Y+3	; 0x03
    1fe0:	28 17       	cp	r18, r24
    1fe2:	39 07       	cpc	r19, r25
    1fe4:	30 f1       	brcs	.+76     	; 0x2032 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1fe6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1fe8:	8e 01       	movw	r16, r28
    1fea:	0e 5f       	subi	r16, 0xFE	; 254
    1fec:	1f 4f       	sbci	r17, 0xFF	; 255
    1fee:	c8 01       	movw	r24, r16
    1ff0:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1ff4:	8c 89       	ldd	r24, Y+20	; 0x14
    1ff6:	9d 89       	ldd	r25, Y+21	; 0x15
    1ff8:	89 2b       	or	r24, r25
    1ffa:	21 f0       	breq	.+8      	; 0x2004 <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1ffc:	ce 01       	movw	r24, r28
    1ffe:	0c 96       	adiw	r24, 0x0c	; 12
    2000:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2004:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2006:	9e 89       	ldd	r25, Y+22	; 0x16
    2008:	80 91 7c 02 	lds	r24, 0x027C
    200c:	89 17       	cp	r24, r25
    200e:	10 f4       	brcc	.+4      	; 0x2014 <vCoRoutineSchedule+0x100>
    2010:	90 93 7c 02 	sts	0x027C, r25
    2014:	9f 9d       	mul	r25, r15
    2016:	c0 01       	movw	r24, r0
    2018:	11 24       	eor	r1, r1
    201a:	8d 57       	subi	r24, 0x7D	; 125
    201c:	9d 4f       	sbci	r25, 0xFD	; 253
    201e:	b8 01       	movw	r22, r16
    2020:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2024:	e0 91 a7 02 	lds	r30, 0x02A7
    2028:	f0 91 a8 02 	lds	r31, 0x02A8
    202c:	80 81       	ld	r24, Z
    202e:	88 23       	and	r24, r24
    2030:	61 f6       	brne	.-104    	; 0x1fca <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2032:	20 91 7f 02 	lds	r18, 0x027F
    2036:	30 91 80 02 	lds	r19, 0x0280
    203a:	80 91 81 02 	lds	r24, 0x0281
    203e:	90 91 82 02 	lds	r25, 0x0282
    2042:	21 15       	cp	r18, r1
    2044:	31 05       	cpc	r19, r1
    2046:	09 f0       	breq	.+2      	; 0x204a <vCoRoutineSchedule+0x136>
    2048:	a1 cf       	rjmp	.-190    	; 0x1f8c <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    204a:	90 93 7e 02 	sts	0x027E, r25
    204e:	80 93 7d 02 	sts	0x027D, r24
    2052:	90 91 7c 02 	lds	r25, 0x027C

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2056:	29 e0       	ldi	r18, 0x09	; 9
    2058:	06 c0       	rjmp	.+12     	; 0x2066 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    205a:	99 23       	and	r25, r25
    205c:	19 f4       	brne	.+6      	; 0x2064 <vCoRoutineSchedule+0x150>
    205e:	10 92 7c 02 	sts	0x027C, r1
    2062:	32 c0       	rjmp	.+100    	; 0x20c8 <vCoRoutineSchedule+0x1b4>
    2064:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2066:	92 9f       	mul	r25, r18
    2068:	d0 01       	movw	r26, r0
    206a:	11 24       	eor	r1, r1
    206c:	ad 57       	subi	r26, 0x7D	; 125
    206e:	bd 4f       	sbci	r27, 0xFD	; 253
    2070:	8c 91       	ld	r24, X
    2072:	88 23       	and	r24, r24
    2074:	91 f3       	breq	.-28     	; 0x205a <vCoRoutineSchedule+0x146>
    2076:	90 93 7c 02 	sts	0x027C, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    207a:	11 96       	adiw	r26, 0x01	; 1
    207c:	ed 91       	ld	r30, X+
    207e:	fc 91       	ld	r31, X
    2080:	12 97       	sbiw	r26, 0x02	; 2
    2082:	02 80       	ldd	r0, Z+2	; 0x02
    2084:	f3 81       	ldd	r31, Z+3	; 0x03
    2086:	e0 2d       	mov	r30, r0
    2088:	12 96       	adiw	r26, 0x02	; 2
    208a:	fc 93       	st	X, r31
    208c:	ee 93       	st	-X, r30
    208e:	11 97       	sbiw	r26, 0x01	; 1
    2090:	cd 01       	movw	r24, r26
    2092:	03 96       	adiw	r24, 0x03	; 3
    2094:	e8 17       	cp	r30, r24
    2096:	f9 07       	cpc	r31, r25
    2098:	31 f4       	brne	.+12     	; 0x20a6 <vCoRoutineSchedule+0x192>
    209a:	82 81       	ldd	r24, Z+2	; 0x02
    209c:	93 81       	ldd	r25, Z+3	; 0x03
    209e:	12 96       	adiw	r26, 0x02	; 2
    20a0:	9c 93       	st	X, r25
    20a2:	8e 93       	st	-X, r24
    20a4:	11 97       	sbiw	r26, 0x01	; 1
    20a6:	11 96       	adiw	r26, 0x01	; 1
    20a8:	ed 91       	ld	r30, X+
    20aa:	fc 91       	ld	r31, X
    20ac:	12 97       	sbiw	r26, 0x02	; 2
    20ae:	06 80       	ldd	r0, Z+6	; 0x06
    20b0:	f7 81       	ldd	r31, Z+7	; 0x07
    20b2:	e0 2d       	mov	r30, r0
    20b4:	f0 93 7b 02 	sts	0x027B, r31
    20b8:	e0 93 7a 02 	sts	0x027A, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    20bc:	20 81       	ld	r18, Z
    20be:	31 81       	ldd	r19, Z+1	; 0x01
    20c0:	cf 01       	movw	r24, r30
    20c2:	67 89       	ldd	r22, Z+23	; 0x17
    20c4:	f9 01       	movw	r30, r18
    20c6:	19 95       	eicall

	return;
}
    20c8:	df 91       	pop	r29
    20ca:	cf 91       	pop	r28
    20cc:	1f 91       	pop	r17
    20ce:	0f 91       	pop	r16
    20d0:	ff 90       	pop	r15
    20d2:	08 95       	ret

000020d4 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    20d4:	0f 93       	push	r16
    20d6:	1f 93       	push	r17
    20d8:	cf 93       	push	r28
    20da:	df 93       	push	r29
    20dc:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    20de:	00 91 81 02 	lds	r16, 0x0281
    20e2:	10 91 82 02 	lds	r17, 0x0282
    20e6:	08 0f       	add	r16, r24
    20e8:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20ea:	80 91 7a 02 	lds	r24, 0x027A
    20ee:	90 91 7b 02 	lds	r25, 0x027B
    20f2:	02 96       	adiw	r24, 0x02	; 2
    20f4:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    20f8:	e0 91 7a 02 	lds	r30, 0x027A
    20fc:	f0 91 7b 02 	lds	r31, 0x027B
    2100:	13 83       	std	Z+3, r17	; 0x03
    2102:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2104:	80 91 81 02 	lds	r24, 0x0281
    2108:	90 91 82 02 	lds	r25, 0x0282
    210c:	bf 01       	movw	r22, r30
    210e:	6e 5f       	subi	r22, 0xFE	; 254
    2110:	7f 4f       	sbci	r23, 0xFF	; 255
    2112:	08 17       	cp	r16, r24
    2114:	19 07       	cpc	r17, r25
    2116:	28 f4       	brcc	.+10     	; 0x2122 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2118:	80 91 a9 02 	lds	r24, 0x02A9
    211c:	90 91 aa 02 	lds	r25, 0x02AA
    2120:	04 c0       	rjmp	.+8      	; 0x212a <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2122:	80 91 a7 02 	lds	r24, 0x02A7
    2126:	90 91 a8 02 	lds	r25, 0x02A8
    212a:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vListInsert>
	}

	if( pxEventList )
    212e:	20 97       	sbiw	r28, 0x00	; 0
    2130:	49 f0       	breq	.+18     	; 0x2144 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2132:	60 91 7a 02 	lds	r22, 0x027A
    2136:	70 91 7b 02 	lds	r23, 0x027B
    213a:	64 5f       	subi	r22, 0xF4	; 244
    213c:	7f 4f       	sbci	r23, 0xFF	; 255
    213e:	ce 01       	movw	r24, r28
    2140:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vListInsert>
	}
}
    2144:	df 91       	pop	r29
    2146:	cf 91       	pop	r28
    2148:	1f 91       	pop	r17
    214a:	0f 91       	pop	r16
    214c:	08 95       	ret

0000214e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    214e:	af 92       	push	r10
    2150:	bf 92       	push	r11
    2152:	cf 92       	push	r12
    2154:	df 92       	push	r13
    2156:	ef 92       	push	r14
    2158:	ff 92       	push	r15
    215a:	0f 93       	push	r16
    215c:	1f 93       	push	r17
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	6c 01       	movw	r12, r24
    2164:	b6 2e       	mov	r11, r22
    2166:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2168:	8a e1       	ldi	r24, 0x1A	; 26
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	0e 94 31 11 	call	0x2262	; 0x2262 <pvPortMalloc>
    2170:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2172:	00 97       	sbiw	r24, 0x00	; 0
    2174:	11 f4       	brne	.+4      	; 0x217a <xCoRoutineCreate+0x2c>
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	59 c0       	rjmp	.+178    	; 0x222c <__stack+0x2d>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    217a:	80 91 7a 02 	lds	r24, 0x027A
    217e:	90 91 7b 02 	lds	r25, 0x027B
    2182:	89 2b       	or	r24, r25
    2184:	21 f5       	brne	.+72     	; 0x21ce <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2186:	d0 93 7b 02 	sts	0x027B, r29
    218a:	c0 93 7a 02 	sts	0x027A, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    218e:	83 e8       	ldi	r24, 0x83	; 131
    2190:	92 e0       	ldi	r25, 0x02	; 2
    2192:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
    2196:	8c e8       	ldi	r24, 0x8C	; 140
    2198:	92 e0       	ldi	r25, 0x02	; 2
    219a:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    219e:	25 e9       	ldi	r18, 0x95	; 149
    21a0:	e2 2e       	mov	r14, r18
    21a2:	22 e0       	ldi	r18, 0x02	; 2
    21a4:	f2 2e       	mov	r15, r18
    21a6:	c7 01       	movw	r24, r14
    21a8:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    21ac:	0e e9       	ldi	r16, 0x9E	; 158
    21ae:	12 e0       	ldi	r17, 0x02	; 2
    21b0:	c8 01       	movw	r24, r16
    21b2:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    21b6:	8b ea       	ldi	r24, 0xAB	; 171
    21b8:	92 e0       	ldi	r25, 0x02	; 2
    21ba:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    21be:	f0 92 a8 02 	sts	0x02A8, r15
    21c2:	e0 92 a7 02 	sts	0x02A7, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    21c6:	10 93 aa 02 	sts	0x02AA, r17
    21ca:	00 93 a9 02 	sts	0x02A9, r16
    21ce:	eb 2c       	mov	r14, r11
    21d0:	bb 20       	and	r11, r11
    21d2:	11 f0       	breq	.+4      	; 0x21d8 <xCoRoutineCreate+0x8a>
    21d4:	ee 24       	eor	r14, r14
    21d6:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    21d8:	19 8e       	std	Y+25, r1	; 0x19
    21da:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    21dc:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    21de:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    21e0:	fe 01       	movw	r30, r28
    21e2:	c1 92       	st	Z+, r12
    21e4:	d1 92       	st	Z+, r13
    21e6:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    21e8:	cf 01       	movw	r24, r30
    21ea:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    21ee:	ce 01       	movw	r24, r28
    21f0:	0c 96       	adiw	r24, 0x0c	; 12
    21f2:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    21f6:	d9 87       	std	Y+9, r29	; 0x09
    21f8:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    21fa:	db 8b       	std	Y+19, r29	; 0x13
    21fc:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    21fe:	82 e0       	ldi	r24, 0x02	; 2
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	8e 19       	sub	r24, r14
    2204:	91 09       	sbc	r25, r1
    2206:	9d 87       	std	Y+13, r25	; 0x0d
    2208:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    220a:	9e 89       	ldd	r25, Y+22	; 0x16
    220c:	80 91 7c 02 	lds	r24, 0x027C
    2210:	89 17       	cp	r24, r25
    2212:	10 f4       	brcc	.+4      	; 0x2218 <__stack+0x19>
    2214:	90 93 7c 02 	sts	0x027C, r25
    2218:	89 e0       	ldi	r24, 0x09	; 9
    221a:	98 9f       	mul	r25, r24
    221c:	c0 01       	movw	r24, r0
    221e:	11 24       	eor	r1, r1
    2220:	8d 57       	subi	r24, 0x7D	; 125
    2222:	9d 4f       	sbci	r25, 0xFD	; 253
    2224:	b8 01       	movw	r22, r16
    2226:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <vListInsertEnd>
    222a:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    222c:	df 91       	pop	r29
    222e:	cf 91       	pop	r28
    2230:	1f 91       	pop	r17
    2232:	0f 91       	pop	r16
    2234:	ff 90       	pop	r15
    2236:	ef 90       	pop	r14
    2238:	df 90       	pop	r13
    223a:	cf 90       	pop	r12
    223c:	bf 90       	pop	r11
    223e:	af 90       	pop	r10
    2240:	08 95       	ret

00002242 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2242:	08 95       	ret

00002244 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2244:	10 92 b5 02 	sts	0x02B5, r1
    2248:	10 92 b4 02 	sts	0x02B4, r1
}
    224c:	08 95       	ret

0000224e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    224e:	2b ed       	ldi	r18, 0xDB	; 219
    2250:	35 e0       	ldi	r19, 0x05	; 5
    2252:	80 91 b4 02 	lds	r24, 0x02B4
    2256:	90 91 b5 02 	lds	r25, 0x02B5
    225a:	28 1b       	sub	r18, r24
    225c:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    225e:	c9 01       	movw	r24, r18
    2260:	08 95       	ret

00002262 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
    2266:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2268:	0e 94 9b 03 	call	0x736	; 0x736 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    226c:	80 91 b6 02 	lds	r24, 0x02B6
    2270:	90 91 b7 02 	lds	r25, 0x02B7
    2274:	89 2b       	or	r24, r25
    2276:	31 f4       	brne	.+12     	; 0x2284 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2278:	89 eb       	ldi	r24, 0xB9	; 185
    227a:	92 e0       	ldi	r25, 0x02	; 2
    227c:	90 93 b7 02 	sts	0x02B7, r25
    2280:	80 93 b6 02 	sts	0x02B6, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2284:	20 91 b4 02 	lds	r18, 0x02B4
    2288:	30 91 b5 02 	lds	r19, 0x02B5
    228c:	ce 01       	movw	r24, r28
    228e:	82 0f       	add	r24, r18
    2290:	93 1f       	adc	r25, r19
    2292:	45 e0       	ldi	r20, 0x05	; 5
    2294:	8b 3d       	cpi	r24, 0xDB	; 219
    2296:	94 07       	cpc	r25, r20
    2298:	70 f4       	brcc	.+28     	; 0x22b6 <pvPortMalloc+0x54>
    229a:	28 17       	cp	r18, r24
    229c:	39 07       	cpc	r19, r25
    229e:	58 f4       	brcc	.+22     	; 0x22b6 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    22a0:	c0 91 b6 02 	lds	r28, 0x02B6
    22a4:	d0 91 b7 02 	lds	r29, 0x02B7
    22a8:	c2 0f       	add	r28, r18
    22aa:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    22ac:	90 93 b5 02 	sts	0x02B5, r25
    22b0:	80 93 b4 02 	sts	0x02B4, r24
    22b4:	02 c0       	rjmp	.+4      	; 0x22ba <pvPortMalloc+0x58>
    22b6:	c0 e0       	ldi	r28, 0x00	; 0
    22b8:	d0 e0       	ldi	r29, 0x00	; 0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    22ba:	0e 94 dd 06 	call	0xdba	; 0xdba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    22be:	ce 01       	movw	r24, r28
    22c0:	df 91       	pop	r29
    22c2:	cf 91       	pop	r28
    22c4:	08 95       	ret

000022c6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    22c6:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    22c8:	91 e1       	ldi	r25, 0x11	; 17
    22ca:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    22cc:	22 e2       	ldi	r18, 0x22	; 34
    22ce:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    22d0:	83 e3       	ldi	r24, 0x33	; 51
    22d2:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22d4:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22d6:	72 93       	st	-Z, r23
	pxTopOfStack--;
  
  //-------------------ADDED FOR ATMEGA 2560--------------------------
  usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22d8:	12 92       	st	-Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    22da:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    22dc:	80 e8       	ldi	r24, 0x80	; 128
    22de:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    22e0:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    22e2:	82 e0       	ldi	r24, 0x02	; 2
    22e4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    22e6:	83 e0       	ldi	r24, 0x03	; 3
    22e8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    22ea:	84 e0       	ldi	r24, 0x04	; 4
    22ec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    22ee:	85 e0       	ldi	r24, 0x05	; 5
    22f0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    22f2:	86 e0       	ldi	r24, 0x06	; 6
    22f4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    22f6:	87 e0       	ldi	r24, 0x07	; 7
    22f8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    22fa:	88 e0       	ldi	r24, 0x08	; 8
    22fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    22fe:	89 e0       	ldi	r24, 0x09	; 9
    2300:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2302:	80 e1       	ldi	r24, 0x10	; 16
    2304:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2306:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2308:	82 e1       	ldi	r24, 0x12	; 18
    230a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    230c:	83 e1       	ldi	r24, 0x13	; 19
    230e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2310:	84 e1       	ldi	r24, 0x14	; 20
    2312:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2314:	85 e1       	ldi	r24, 0x15	; 21
    2316:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2318:	86 e1       	ldi	r24, 0x16	; 22
    231a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    231c:	87 e1       	ldi	r24, 0x17	; 23
    231e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2320:	88 e1       	ldi	r24, 0x18	; 24
    2322:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2324:	89 e1       	ldi	r24, 0x19	; 25
    2326:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2328:	80 e2       	ldi	r24, 0x20	; 32
    232a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    232c:	81 e2       	ldi	r24, 0x21	; 33
    232e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2330:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2332:	83 e2       	ldi	r24, 0x23	; 35
    2334:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2336:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2338:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    233a:	86 e2       	ldi	r24, 0x26	; 38
    233c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    233e:	87 e2       	ldi	r24, 0x27	; 39
    2340:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2342:	88 e2       	ldi	r24, 0x28	; 40
    2344:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2346:	89 e2       	ldi	r24, 0x29	; 41
    2348:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    234a:	80 e3       	ldi	r24, 0x30	; 48
    234c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    234e:	81 e3       	ldi	r24, 0x31	; 49
    2350:	82 93       	st	-Z, r24
    2352:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2354:	cf 01       	movw	r24, r30
    2356:	08 95       	ret

00002358 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2358:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    235c:	89 ef       	ldi	r24, 0xF9	; 249
    235e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2362:	8b e0       	ldi	r24, 0x0B	; 11
    2364:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2368:	ef e6       	ldi	r30, 0x6F	; 111
    236a:	f0 e0       	ldi	r31, 0x00	; 0
    236c:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    236e:	80 61       	ori	r24, 0x10	; 16
	TIMSK1 = ucLowByte;
    2370:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2372:	a0 91 1d 02 	lds	r26, 0x021D
    2376:	b0 91 1e 02 	lds	r27, 0x021E
    237a:	cd 91       	ld	r28, X+
    237c:	cd bf       	out	0x3d, r28	; 61
    237e:	dd 91       	ld	r29, X+
    2380:	de bf       	out	0x3e, r29	; 62
    2382:	ff 91       	pop	r31
    2384:	ef 91       	pop	r30
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	bf 91       	pop	r27
    238c:	af 91       	pop	r26
    238e:	9f 91       	pop	r25
    2390:	8f 91       	pop	r24
    2392:	7f 91       	pop	r23
    2394:	6f 91       	pop	r22
    2396:	5f 91       	pop	r21
    2398:	4f 91       	pop	r20
    239a:	3f 91       	pop	r19
    239c:	2f 91       	pop	r18
    239e:	1f 91       	pop	r17
    23a0:	0f 91       	pop	r16
    23a2:	ff 90       	pop	r15
    23a4:	ef 90       	pop	r14
    23a6:	df 90       	pop	r13
    23a8:	cf 90       	pop	r12
    23aa:	bf 90       	pop	r11
    23ac:	af 90       	pop	r10
    23ae:	9f 90       	pop	r9
    23b0:	8f 90       	pop	r8
    23b2:	7f 90       	pop	r7
    23b4:	6f 90       	pop	r6
    23b6:	5f 90       	pop	r5
    23b8:	4f 90       	pop	r4
    23ba:	3f 90       	pop	r3
    23bc:	2f 90       	pop	r2
    23be:	1f 90       	pop	r1
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    23c6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    23c8:	81 e0       	ldi	r24, 0x01	; 1
    23ca:	08 95       	ret

000023cc <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    23cc:	08 95       	ret

000023ce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    23ce:	0f 92       	push	r0
    23d0:	0f b6       	in	r0, 0x3f	; 63
    23d2:	f8 94       	cli
    23d4:	0f 92       	push	r0
    23d6:	1f 92       	push	r1
    23d8:	11 24       	eor	r1, r1
    23da:	2f 92       	push	r2
    23dc:	3f 92       	push	r3
    23de:	4f 92       	push	r4
    23e0:	5f 92       	push	r5
    23e2:	6f 92       	push	r6
    23e4:	7f 92       	push	r7
    23e6:	8f 92       	push	r8
    23e8:	9f 92       	push	r9
    23ea:	af 92       	push	r10
    23ec:	bf 92       	push	r11
    23ee:	cf 92       	push	r12
    23f0:	df 92       	push	r13
    23f2:	ef 92       	push	r14
    23f4:	ff 92       	push	r15
    23f6:	0f 93       	push	r16
    23f8:	1f 93       	push	r17
    23fa:	2f 93       	push	r18
    23fc:	3f 93       	push	r19
    23fe:	4f 93       	push	r20
    2400:	5f 93       	push	r21
    2402:	6f 93       	push	r22
    2404:	7f 93       	push	r23
    2406:	8f 93       	push	r24
    2408:	9f 93       	push	r25
    240a:	af 93       	push	r26
    240c:	bf 93       	push	r27
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	ef 93       	push	r30
    2414:	ff 93       	push	r31
    2416:	a0 91 1d 02 	lds	r26, 0x021D
    241a:	b0 91 1e 02 	lds	r27, 0x021E
    241e:	0d b6       	in	r0, 0x3d	; 61
    2420:	0d 92       	st	X+, r0
    2422:	0e b6       	in	r0, 0x3e	; 62
    2424:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2426:	0e 94 aa 05 	call	0xb54	; 0xb54 <xTaskIncrementTick>
    242a:	88 23       	and	r24, r24
    242c:	11 f0       	breq	.+4      	; 0x2432 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    242e:	0e 94 c0 03 	call	0x780	; 0x780 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2432:	a0 91 1d 02 	lds	r26, 0x021D
    2436:	b0 91 1e 02 	lds	r27, 0x021E
    243a:	cd 91       	ld	r28, X+
    243c:	cd bf       	out	0x3d, r28	; 61
    243e:	dd 91       	ld	r29, X+
    2440:	de bf       	out	0x3e, r29	; 62
    2442:	ff 91       	pop	r31
    2444:	ef 91       	pop	r30
    2446:	df 91       	pop	r29
    2448:	cf 91       	pop	r28
    244a:	bf 91       	pop	r27
    244c:	af 91       	pop	r26
    244e:	9f 91       	pop	r25
    2450:	8f 91       	pop	r24
    2452:	7f 91       	pop	r23
    2454:	6f 91       	pop	r22
    2456:	5f 91       	pop	r21
    2458:	4f 91       	pop	r20
    245a:	3f 91       	pop	r19
    245c:	2f 91       	pop	r18
    245e:	1f 91       	pop	r17
    2460:	0f 91       	pop	r16
    2462:	ff 90       	pop	r15
    2464:	ef 90       	pop	r14
    2466:	df 90       	pop	r13
    2468:	cf 90       	pop	r12
    246a:	bf 90       	pop	r11
    246c:	af 90       	pop	r10
    246e:	9f 90       	pop	r9
    2470:	8f 90       	pop	r8
    2472:	7f 90       	pop	r7
    2474:	6f 90       	pop	r6
    2476:	5f 90       	pop	r5
    2478:	4f 90       	pop	r4
    247a:	3f 90       	pop	r3
    247c:	2f 90       	pop	r2
    247e:	1f 90       	pop	r1
    2480:	0f 90       	pop	r0
    2482:	0f be       	out	0x3f, r0	; 63
    2484:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2486:	08 95       	ret

00002488 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2488:	0e 94 e7 11 	call	0x23ce	; 0x23ce <vPortYieldFromTick>
		asm volatile ( "reti" );
    248c:	18 95       	reti

0000248e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    248e:	0f 92       	push	r0
    2490:	0f b6       	in	r0, 0x3f	; 63
    2492:	f8 94       	cli
    2494:	0f 92       	push	r0
    2496:	1f 92       	push	r1
    2498:	11 24       	eor	r1, r1
    249a:	2f 92       	push	r2
    249c:	3f 92       	push	r3
    249e:	4f 92       	push	r4
    24a0:	5f 92       	push	r5
    24a2:	6f 92       	push	r6
    24a4:	7f 92       	push	r7
    24a6:	8f 92       	push	r8
    24a8:	9f 92       	push	r9
    24aa:	af 92       	push	r10
    24ac:	bf 92       	push	r11
    24ae:	cf 92       	push	r12
    24b0:	df 92       	push	r13
    24b2:	ef 92       	push	r14
    24b4:	ff 92       	push	r15
    24b6:	0f 93       	push	r16
    24b8:	1f 93       	push	r17
    24ba:	2f 93       	push	r18
    24bc:	3f 93       	push	r19
    24be:	4f 93       	push	r20
    24c0:	5f 93       	push	r21
    24c2:	6f 93       	push	r22
    24c4:	7f 93       	push	r23
    24c6:	8f 93       	push	r24
    24c8:	9f 93       	push	r25
    24ca:	af 93       	push	r26
    24cc:	bf 93       	push	r27
    24ce:	cf 93       	push	r28
    24d0:	df 93       	push	r29
    24d2:	ef 93       	push	r30
    24d4:	ff 93       	push	r31
    24d6:	a0 91 1d 02 	lds	r26, 0x021D
    24da:	b0 91 1e 02 	lds	r27, 0x021E
    24de:	0d b6       	in	r0, 0x3d	; 61
    24e0:	0d 92       	st	X+, r0
    24e2:	0e b6       	in	r0, 0x3e	; 62
    24e4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    24e6:	0e 94 c0 03 	call	0x780	; 0x780 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    24ea:	a0 91 1d 02 	lds	r26, 0x021D
    24ee:	b0 91 1e 02 	lds	r27, 0x021E
    24f2:	cd 91       	ld	r28, X+
    24f4:	cd bf       	out	0x3d, r28	; 61
    24f6:	dd 91       	ld	r29, X+
    24f8:	de bf       	out	0x3e, r29	; 62
    24fa:	ff 91       	pop	r31
    24fc:	ef 91       	pop	r30
    24fe:	df 91       	pop	r29
    2500:	cf 91       	pop	r28
    2502:	bf 91       	pop	r27
    2504:	af 91       	pop	r26
    2506:	9f 91       	pop	r25
    2508:	8f 91       	pop	r24
    250a:	7f 91       	pop	r23
    250c:	6f 91       	pop	r22
    250e:	5f 91       	pop	r21
    2510:	4f 91       	pop	r20
    2512:	3f 91       	pop	r19
    2514:	2f 91       	pop	r18
    2516:	1f 91       	pop	r17
    2518:	0f 91       	pop	r16
    251a:	ff 90       	pop	r15
    251c:	ef 90       	pop	r14
    251e:	df 90       	pop	r13
    2520:	cf 90       	pop	r12
    2522:	bf 90       	pop	r11
    2524:	af 90       	pop	r10
    2526:	9f 90       	pop	r9
    2528:	8f 90       	pop	r8
    252a:	7f 90       	pop	r7
    252c:	6f 90       	pop	r6
    252e:	5f 90       	pop	r5
    2530:	4f 90       	pop	r4
    2532:	3f 90       	pop	r3
    2534:	2f 90       	pop	r2
    2536:	1f 90       	pop	r1
    2538:	0f 90       	pop	r0
    253a:	0f be       	out	0x3f, r0	; 63
    253c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    253e:	08 95       	ret

00002540 <__udivmodsi4>:
    2540:	a1 e2       	ldi	r26, 0x21	; 33
    2542:	1a 2e       	mov	r1, r26
    2544:	aa 1b       	sub	r26, r26
    2546:	bb 1b       	sub	r27, r27
    2548:	fd 01       	movw	r30, r26
    254a:	0d c0       	rjmp	.+26     	; 0x2566 <__udivmodsi4_ep>

0000254c <__udivmodsi4_loop>:
    254c:	aa 1f       	adc	r26, r26
    254e:	bb 1f       	adc	r27, r27
    2550:	ee 1f       	adc	r30, r30
    2552:	ff 1f       	adc	r31, r31
    2554:	a2 17       	cp	r26, r18
    2556:	b3 07       	cpc	r27, r19
    2558:	e4 07       	cpc	r30, r20
    255a:	f5 07       	cpc	r31, r21
    255c:	20 f0       	brcs	.+8      	; 0x2566 <__udivmodsi4_ep>
    255e:	a2 1b       	sub	r26, r18
    2560:	b3 0b       	sbc	r27, r19
    2562:	e4 0b       	sbc	r30, r20
    2564:	f5 0b       	sbc	r31, r21

00002566 <__udivmodsi4_ep>:
    2566:	66 1f       	adc	r22, r22
    2568:	77 1f       	adc	r23, r23
    256a:	88 1f       	adc	r24, r24
    256c:	99 1f       	adc	r25, r25
    256e:	1a 94       	dec	r1
    2570:	69 f7       	brne	.-38     	; 0x254c <__udivmodsi4_loop>
    2572:	60 95       	com	r22
    2574:	70 95       	com	r23
    2576:	80 95       	com	r24
    2578:	90 95       	com	r25
    257a:	9b 01       	movw	r18, r22
    257c:	ac 01       	movw	r20, r24
    257e:	bd 01       	movw	r22, r26
    2580:	cf 01       	movw	r24, r30
    2582:	08 95       	ret

00002584 <memcpy>:
    2584:	fb 01       	movw	r30, r22
    2586:	dc 01       	movw	r26, r24
    2588:	02 c0       	rjmp	.+4      	; 0x258e <memcpy+0xa>
    258a:	01 90       	ld	r0, Z+
    258c:	0d 92       	st	X+, r0
    258e:	41 50       	subi	r20, 0x01	; 1
    2590:	50 40       	sbci	r21, 0x00	; 0
    2592:	d8 f7       	brcc	.-10     	; 0x258a <memcpy+0x6>
    2594:	08 95       	ret

00002596 <_exit>:
    2596:	f8 94       	cli

00002598 <__stop_program>:
    2598:	ff cf       	rjmp	.-2      	; 0x2598 <__stop_program>
